\documentclass[a4paper,10pt,twoside]{article}
\setcounter{secnumdepth}{0} %разделы без нумерации 
\setcounter{tocdepth}{2} % не показывать под-подразделы в оглавлении

\usepackage{polyglossia}
\setmainlanguage{russian}
\newfontfamily\cyrillicfont{Times New Roman}
\setmainfont{Times New Roman}
\usepackage{indentfirst}
\frenchspacing
\usepackage[svgnames]{xcolor} %для цветных блоков с текстом
\usepackage{dashrule}
\usepackage{mdframed} %для блоков с текстом
\usepackage{geometry} % Меняем поля страницы
\geometry{left=2cm}% левое поле
\geometry{right=1.5cm}% правое поле
\geometry{top=1cm}% верхнее поле
\geometry{bottom=2cm}% нижнее поле
\usepackage{mathptmx}
\usepackage{graphicx} %вставлять картинки
\usepackage{array}
\usepackage{tabu}
\usepackage{keystroke}
\usepackage{menukeys}
\usepackage[normalem]{ulem} %для перечёркиваний
\usepackage{fixltx2e} %нижний индекс
\usepackage{marvosym}
\usepackage{textcomp}
\usepackage{enumitem} %иерархические списки
\usepackage{sectsty} % размер заголовков
\usepackage{longtable} %многостраничные таблицы
\usepackage{lipsum} %частные отступы для абзацев
\usepackage[unicode]{hyperref}
\usepackage{soul}
\hypersetup{
        colorlinks=true,
        linktoc=all,
        linkcolor=NavyBlue,
}
%\usepackage[pdftex]{hyperref}
%\usepackage{makeidx} %алфавитный указатель

\graphicspath{ {/home/mint/trans/freeoffice2016/pr_pics/} } %путь до картинок

\title{Presentations\\ Руководство пользователя}
\author{}
\date{}


\sectionfont{\fontsize{27}{24}\selectfont}
\subsectionfont{\fontsize{14}{18}\selectfont}
\subsubsectionfont{\fontsize{12}{12}\selectfont}
%\paragraphfont{\fontsize{11}{9}\selectfont}

\newenvironment{myindentpar}[1]%частные отступы для абзацев
 {\begin{list}{}%
         {\setlength{\leftmargin}{#1}}%
         \item[]%
 }
 {\end{list}}

\makeatletter
\renewcommand\paragraph{%
   \@startsection{paragraph}{4}{0mm}%
      {-\baselineskip}%
      {.5\baselineskip}%
      {\normalfont\normalsize\bfseries}}
\makeatother

\begin{document}

	\section{Обслуживание и настройка}

Инструкция предназначена для описания процесса развертывания сервера IPA (Identification Policy and Audit). Сервер IPA предназначен для организации единой службы аутентификации для OC семейства ROSA Linux, других популярных современных версий ОС Linux, Windows, а также некоторых других операционных систем.

Конструктивно сервер IPA представляет собой связку из сервера MIT Kerberos, LDAP 389 Directory, сервера NTP для обеспечения единого времени и сервера имен для обслуживаемых доменов. Возможна настройка общего хранилища на базе NFS с аутентификацией по билетам Kerberos, а также доступны некоторые политики безопасности (только для Linux/UNIX), включая политики sudo, парольные политики, включение в домен рабочих станций и т.п.

Также предоставляется удобный интерфейс администрирования с помощью встроенного HTTP(S) сервера. Управлять развернутым IPA сервером можно прямо из браузера по защищенному HTTPS соединению. Также поддерживается объединение доменов AD и IPA с помощью функций взаимного доверия (TRUST). Сервер IPA поддерживает функцию двухфакторной аутентификации (с помощью внешнего привлекаемого сервера RADIUS). Помимо веб-интерфейса, доступно администрирование сервера с помощью интерфейса командной строки.

Список поддерживаемых клиентских ОС:
\begin{itemize}
 \item ОС семейства Linux:
 \begin{itemize}
  \item ROSA Linux Enterprise Desktop X2 (RED X2) и выше
\item РОСА «КОБАЛЬТ» SX 1.0 и выше
\item ROSA Enterprise Linux Server (RELS) 6.3 и выше
\item ROSA Fresh R6 и выше
\item Red Hat Enterprise Linux версии 5.х и выше
\item CentOS Linux версии 6.х и выше
\item Fedora Linux 18 и выше
\item Ubuntu Linux версии 13.04 и выше
\item SUSE (SLES) Linux 10 и выше
 \end{itemize}
\item ОС семейства Microsoft Windows:
\begin{itemize}
 \item Microsoft Windows 7 и выше;
\end{itemize}
\item UNIX-совместимые ОС:
\begin{itemize}
 \item \item FreeBSD 9 и выше;
\end{itemize}
\item ОС семейства UNIX:
\begin{itemize}
 \item Solaris 8 и выше;
\item Mac OS X версии 10.4 (Tiger) и выше;
\item HP-UX 11.23 и выше;
\item IBM AIX версии 5.3 и выше.

\end{itemize}
\item Планируется поддержка:
\begin{itemize}
 \item ALT Linux СПТ 8 и выше.
\end{itemize}
\end{itemize}

ОС РОСА «КОБАЛЬТ» SX 1.0 имеет показатели защищенности от НСД — по 5-му классу защищенности и 4-й уровень контроля отсутствия НДВ, и может применяться в АС(автоматизированных системах) с классом защиты информации не выше 1Г. Перечисленные выше ОС поддерживают работу в среде IPA, но большинство из них не имеют аналогичного класса защищенности и не могут применяться в защищенных АС без использования дополнительных средств защиты либо без согласования с органом по аттестации.


Предполагается, что на момент настройки контроллера домена у нас есть сервер с установленной ОС Rosa Cobalt в варианте «минимальная установка».

\textbf{Все приведенные команды и настройки проводятся под учетной записью суперпользователя (root).}

В примерах, приводимых в данной инструкции мы будем предполагать, что наш сервер имеет следующие сетевые настройки:

 Имя: dc1.test.dom
 
 IP:192.168.76.47/24
 
Также обязателен статический IP

\subsection{Настройка имени сервера (hostname)}
Перед установкой IPA необходимо задать имя сервера (hostname). В отличие от предыдущих версий ОС, в настоящей версии не используется способ с занесением имени сервера вручную в файл /etc/sysconfig/network и перезагрузкой системы. Чтобы задать имя сервера есть несколько способов:

\begin{itemize}
 \item С помощью утилиты hostnamectl
\item С помощью текстового интерфейса пользователя NetworkManager: nmtui
\item С помощью прямого редактирования файла /etc/hostname (после этого потребуется перезагрузка)
\end{itemize}

\subsubsection{Способ 1: hostnamectl}
Чтобы узнать текущее значение hostname системы:
\begin{verbatim}
 # hostnamectl status
\end{verbatim}

Чтобы установить новое значение имени сервера (например,  geeklab):
\begin{verbatim}
 # hostnamectl set-hostname geeklab    ## static
# hostnamectl set-hostname "Geeks LAB"   ## pretty
\end{verbatim}

Выйдите и снова авторизуйтесь в системе, и проверьте установленное значение:
\begin{verbatim}
 # hostnamectl
   Static hostname: geekslab
   Pretty hostname: Geeks LAB
         Icon name: computer
           Chassis: n/a
        Machine ID: 55cc1c57c7f24ed0b0d352648024cea6
           Boot ID: a12ec8e04e6b4534841d14dc8425e38c
    Virtualization: vmware
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-123.el7.x86_64
      Architecture: x86_64
\end{verbatim}
\subsubsection{}

\subsubsection{Способ 2: nmtui}
Изменить значение имени сервера можно также с помощью утилиты nmtui. 

Текстовый интерфейс программы NetworkManager, \textbf{\textit{nmtui}}, предоставляет возможность установки параметров сети с помощью NetworkManager. Утилита содержится в пакете \textit{NetworkManager-tui}. Ко времени написания этого руководства, утилита устанавливается отдельно от пакета NetworkManager. Чтобы установить утилиту, введите команду с правами пользователя root:
\begin{verbatim}
 # yum install NetworkManager-tui
\end{verbatim}
Условием запуска утилиты является работающий в фоновом режиме NetworkManager. Проверить статус NetworkManager можно с помощью команды:
\begin{verbatim}
 systemctl status NetworkManager
\end{verbatim}

Если NetworkManager неактивен, его можно запустить с помощью команды:
\begin{verbatim}
 systemctl start NetworkManager
\end{verbatim}

Запустим утилиту:
\begin{verbatim}
 nmtui
\end{verbatim} 

Выберите параметр «изменить имя узла» и нажмите клавишу ввод. Введите имя сервера и подтвердите смену значения.Чтобы изменения вступили в силу, перезагрузите службу systemd-hostnamed:
\begin{verbatim}
 # service systemd-hostnamed restart
\end{verbatim} 

Выйдите и снова авторизуйтесь в системе, и проверьте установленное значение:

\begin{verbatim}
 # hostnamectl
   Static hostname: geeklab
         Icon name: computer
           Chassis: n/a
        Machine ID: 55cc1c57c7f24ed0b0d352648024cea6
           Boot ID: a12ec8e04e6b4534841d14dc8425e38c
    Virtualization: vmware
  Operating System: CentOS Linux 7 (Core)http://master.test.dom/
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-123.el7.x86_64
      Architecture: x86_64
\end{verbatim} 


\subsubsection{Способ 3: редактирование файла /etc/hostname вручную}
Этот способ требует перезапуска системы. Просмотрим текущие значения файла:
\begin{verbatim}
 # cat /etc/hostname
localhost.localdomain
\end{verbatim} 

Чтобы сменить значение имени сервер на geeklab, замените содержимое файла /etc/hostname на geeklab:
\begin{verbatim}
 # echo "geeklab" > /etc/hostname
# cat /etc/hostname
geeklab
\end{verbatim} 

Перезапустите систему и проверьте значение:
\begin{verbatim}
 # shutdown -r now
# hostname
geeklab
\end{verbatim} 

\paragraph{Подключение дополнительного репозитория}

Для установки IPA на ОС ROSA Enterprise Linux Server нужно подключить дополнительный локальный репозиторий. Для этого с правами пользователя root смонтируйте установочный диск DVD в каталог /mnt:
\begin{verbatim}
#mount /dev/sr0 /mnt
\end{verbatim}

\subsection{Установка сервера IPA и настройка его окружения}
Установим необходимые пакеты для сервера IPA:
\begin{verbatim}
yum install ipa-server-dns ipa-server
\end{verbatim} 

Затем проверим наличие корректных сетевых настроек в файле /etc/hosts. Он должен выглядеть примерно так:
\begin{verbatim}
 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6
 192.168.76.47 dc1.test.dom dc1
 \end{verbatim} 
 
Нас в первую очередь интересует нижняя строчка, которая должна указывать на наш сервер.

Теперь нужно убедиться, что в качестве первого DNS сервера у нас используется будущий сервер домена IPA. И, если планируется использовать короткие имена машин в сети, то прописана корректная опция domain или search. Для этого в файле /etc/resolv.conf должны быть записи вида:
\begin{verbatim}
 search test.dom
 nameserver 192.168.76.47
 \end{verbatim} 
 
 \subsubsection{Инициализация сервера IPA}
 Проведем инициализацию домена командой:
 \begin{verbatim}
ipa-server-install --setup-dns
\end{verbatim}

Инициализации происходит в интерактивном режиме. Нам задаются вопросы, мы на них отвечаем. При корректной сетевой настройке сервера на все вопросы нужно выбирать предлагаемое по умолчанию значение, просто нажимая клавишу [Enter]:

\begin{verbatim}
Server host name [dc1.test.dom]:
Please confirm the domain name [test.dom]:
Please provide a realm name [TEST.DOM]:
\end{verbatim} 

Введем пароль (минимум 8 знаков) для служебного пользователя службы каталогов

\begin{verbatim}
Directory Manager password:
\end{verbatim}   

Введем пароль для администратора IPA (пользователь admin)

\begin{verbatim}
IPA admin password:
\end{verbatim} 

Если нужно добавляем ретранслятор службы имен (DNS relay). Этот шаг необязателен, и необходим в том случае, если у предполагается использовать внешний сервер для обработки запросов службы имен DNS. Учитывайте, что по-умолчанию, сервер IPA предполагает, что будет пользоваться собственным сервером имен, который развертывает локально.

\begin{verbatim}
Do you want to configure DNS forwarders? [yes]:
\end{verbatim} 

Выбирайте [yes] (да), в случае, если присутствует внешний ретранслятор службы имен, иначе, выбирайте [no] – нет.

При этом установщик сам найдет записи nameserver в вашем файле /etc/resolv.conf и предложит добавить их автоматически.

\begin{verbatim}
Following DNS servers are configured in /etc/resolv.conf: 8.8.8.8
Do you want to configure these servers as DNS forwarders? [yes]:
\end{verbatim} 

Далее установщик предложит произвести поиск недостающей обратной зоны.

\begin{verbatim}
Do you want to search for missing reverse zones? [yes]:
\end{verbatim} 

\so{Внимание:} если ретранслятор службы имен не был настроен, или если ретранслятор уже знает сервер, отвечающий за обратную зону, соответствующую подсети, то обратная зона не будет создана автоматически и придется впоследствии настраивать ее вручную, например через веб-интерфейс управления IPA:

\begin{verbatim}
BIND DNS server will be configured to serve IPA domain with:
Forwarders:       No forwarders
Forward policy:   only
Reverse zone(s):  No reverse zone
\end{verbatim} 

Затем нам будет предложено еще раз проверить настройки и, если все корректно, запустить процедуру инициализации домена.

Процедура инициализации будет выглядеть следующим образом:

\begin{verbatim}
Continue to configure the system with these values? [no]: y

The following operations may take some minutes to complete.
Please wait until the prompt is returned.

Configuring NTP daemon (ntpd)
 [1/4]: stopping ntpd
 [2/4]: writing configuration
 [3/4]: configuring ntpd to start on boot
 [4/4]: starting ntpd
Done configuring NTP daemon (ntpd).
Configuring directory server for the CA (pkids): Estimated time 30 seconds
 [1/3]: creating directory server user
 [2/3]: creating directory server instance
 [3/3]: restarting directory server
Done configuring directory server for the CA (pkids).
Configuring certificate server (pki-cad): Estimated time 3 minutes 30 seconds
 [1/21]: creating certificate server user
 [2/21]: creating pki-ca instance
 [3/21]: configuring certificate server instance
 [4/21]: disabling nonces
 [5/21]: creating CA agent PKCS#12 file in /root
 [6/21]: creating RA agent certificate database
 [7/21]: importing CA chain to RA certificate database
 [8/21]: fixing RA database permissions
 [9/21]: setting up signing cert profile
 [10/21]: set up CRL publishing
 [11/21]: set certificate subject base
 [12/21]: enabling Subject Key Identifier
 [13/21]: setting audit signing renewal to 2 years
 [14/21]: configuring certificate server to start on boot
 [15/21]: restarting certificate server
 [16/21]: requesting RA certificate from CA
 [17/21]: issuing RA agent certificate
 [18/21]: adding RA agent as a trusted user
 [19/21]: configure certificate renewals
 [20/21]: configure Server-Cert certificate renewal
 [21/21]: Configure HTTP to proxy connections
Done configuring certificate server (pki-cad).
Configuring directory server (dirsrv): Estimated time 1 minute
 [1/38]: creating directory server user
 [2/38]: creating directory server instance
 [3/38]: adding default schema
 [4/38]: enabling memberof plugin
 [5/38]: enabling winsync plugin
 [6/38]: configuring replication version plugin
 [7/38]: enabling IPA enrollment plugin
 [8/38]: enabling ldapi
 [9/38]: disabling betxn plugins
 [10/38]: configuring uniqueness plugin
 [11/38]: configuring uuid plugin
 [12/38]: configuring modrdn plugin
 [13/38]: enabling entryUSN plugin
 [14/38]: configuring lockout plugin
 [15/38]: creating indices
 [16/38]: enabling referential integrity plugin
 [17/38]: configuring ssl for ds instance
 [18/38]: configuring certmap.conf
 [19/38]: configure autobind for root
 [20/38]: configure new location for managed entries
 [21/38]: restarting directory server
 [22/38]: adding default layout
 [23/38]: adding delegation layout
 [24/38]: adding replication acis
 [25/38]: creating container for managed entries
 [26/38]: configuring user private groups
 [27/38]: configuring netgroups from hostgroups
 [28/38]: creating default Sudo bind user
 [29/38]: creating default Auto Member layout
 [30/38]: adding range check plugin
 [31/38]: creating default HBAC rule allow_all
 [32/38]: Upload CA cert to the directory
 [33/38]: initializing group membership
 [34/38]: adding master entry
 [35/38]: configuring Posix uid/gid generation
 [36/38]: enabling compatibility plugin
 [37/38]: tuning directory server
 [38/38]: configuring directory to start on boot
Done configuring directory server (dirsrv).
Configuring Kerberos KDC (krb5kdc): Estimated time 30 seconds
 [1/10]: adding sasl mappings to the directory
 [2/10]: adding kerberos container to the directory
 [3/10]: configuring KDC
 [4/10]: initialize kerberos container
 [5/10]: adding default ACIs
 [6/10]: creating a keytab for the directory
 [7/10]: creating a keytab for the machine
 [8/10]: adding the password extension to the directory
 [9/10]: starting the KDC
 [10/10]: configuring KDC to start on boot
Done configuring Kerberos KDC (krb5kdc).
Configuring kadmin
 [1/2]: starting kadmin
 [2/2]: configuring kadmin to start on boot
Done configuring kadmin.
Configuring ipa_memcached
 [1/2]: starting ipa_memcached
 [2/2]: configuring ipa_memcached to start on boot
Done configuring ipa_memcached.
Configuring the web interface (httpd): Estimated time 1 minute
 [1/14]: setting mod_nss port to 443
 [2/14]: setting mod_nss protocol list to TLSv1.0 - TLSv1.2
 [3/14]: setting mod_nss password file
 [4/14]: enabling mod_nss renegotiate
 [5/14]: adding URL rewriting rules
 [6/14]: configuring httpd
 [7/14]: setting up ssl
 [8/14]: setting up browser autoconfig
 [9/14]: publish CA cert
 [10/14]: creating a keytab for httpd
 [11/14]: clean up any existing httpd ccache
 [12/14]: configuring SELinux for httpd
 [13/14]: restarting httpd
 [14/14]: configuring httpd to start on boot
Done configuring the web interface (httpd).
Applying LDAP updates
Restarting the directory server
Restarting the KDC
Configuring DNS (named)
 [1/9]: adding DNS container
 [2/9]: setting up our zone
 [3/9]: setting up reverse zone
 [4/9]: setting up our own record
 [5/9]: setting up kerberos principal
 [6/9]: setting up named.conf
 [7/9]: restarting named
 [8/9]: configuring named to start on boot
 [9/9]: changing resolv.conf to point to ourselves
Done configuring DNS (named).

Global DNS configuration in LDAP server is empty
You can use 'dnsconfig-mod' command to set global DNS options that
would override settings in local named.conf files

Restarting the web server
==============================================================================
Setup complete

Next steps:
  1. You must make sure these network ports are open:
  TCP Ports:
  * 80, 443: HTTP/HTTPS
  * 389, 636: LDAP/LDAPS
  * 88, 464: kerberos
  * 53: bind
  UDP Ports:
  * 88, 464: kerberos
  * 53: bind
  * 123: ntp

  2. You can now obtain a kerberos ticket using the command: 'kinit admin'
  This ticket will allow you to use the IPA tools (e.g., ipa user-add)
  and the web user interface.

Be sure to back up the CA certificate stored in /root/cacert.p12
This file is required to create replicas. The password for this
file is the Directory Manager password
\end{verbatim} 

После окончания процедуры инициализации, перезагрузите сервер. Это можно сделать, выполнив команду:
\begin{verbatim}
#reboot
\end{verbatim}

\so{Рекомендация администраторам:} не забудьте открыть 443 порт, который обычно по умолчанию закрыт.

\subsection{Настройка  сервера динамической конфигурации сети DHCP}
Данная инструкция не претендует на полное описание всех возможностей работы сервиса dhcp, а предлагает простой способ настройки  сервера динамической конфигурации сети для быстрого старта.

Для создания сервера dhcp, необходимо установить соответствующую службу командой:

\begin{verbatim}
yum install dhcp
\end{verbatim} 

Для настройки автоматического запуска демона при загрузке системы, используйте  команду:
\begin{verbatim}
systemctl enable dhcpd.service
\end{verbatim} 

Необходимо настроить один из интерфейсов сервера на статический адрес из той подсети, которую будет раздавать клиентам, иначе демон не будет работать корректно.

Для настройки сервиса нужно сначала скопировать файл с типовой конфигурацией сервиса 
/usr/share/doc/dhcp-<версия>/dhcpd.conf.sample                                                                                                                    в каталог /etc/dhcp/, переименовав его в файл dhcpd.conf командой:

\begin{verbatim}
cp /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.conf
\end{verbatim} 

После чего отредактировать файл /etc/dhcpd.conf, указав в нем нужные нам параметры, например, командой:

\begin{verbatim}
mcedit /etc/dhcp/dhcpd.conf
\end{verbatim} 

Приведем данный файл к виду:

\begin{verbatim}
option domain-name "test.dom";
option domain-name-servers 192.168.10.1;
default-lease-time 600;
max-lease-time 7200;
authoritative;
log-facility local7;

subnet 192.168.10.0 netmask 255.255.255.0 {
  range 192.168.10.10 192.168.10.200;
  option routers 192.168.10.254;
  option broadcast-address 192.168.10.255;
} 
\end{verbatim}

В данном примере предполагается, что станции, получающие сетевые настройки, работают в домене test.dom, с сервером DNS 192.168.10.1, шлюзом по умолчанию 192.168.10.254 и получают ip адреса в промежутке от 192.168.10.10 до 192.168.10.200 с маской подсети 255.255.255.0.

В таблице ниже приведено описание используемых в данном примере параметров.

\begin{longtable}{  m{5cm}  m{12cm}  }  
 \textbf{Параметр} & \textbf{Описание}\\\hline
 option domain-name & Определяет имя домена. Глобальный параметр. По умолчанию для всех подсетей.\\
 option domain-name-servers & Определяет список адресов серверов DNS через запятую. Глобальный параметр. По умолчанию для всех подсетей.\\
 default-lease-time & Время аренды по умолчанию.\\
max-lease-time & Определяет максимально допустимое время аренды. Независимо от длительности аренды, фигурирующей в запросе клиента, этот срок не может превышать значение, заданное данным параметром.\\
authoritative & Означает что в вашей сети данный сервер является ответственным за выдачу сетевых адресов.\\
log-facility & Определяет направление потока логов\\
subnet & Это основной логический блок конфигурации. Он определяет настройки для конкретной сети. В том числе в нем можно менять глобальные параметры, такие как domain-name, domain-name-servers и др.\\
range & Диапазон ip адресов доступный для аренды.\\
option routers & Адрес маршрутизатора по умолчанию\\
option broadcast-address & Адрес для широковещательной рассылки.\\
\end{longtable}

После сохранения изменений в конфигурационном файле, необходимо перезагрузить сервис dhcpd командой:

\begin{verbatim}
systemctl restart dhcpd.service
\end{verbatim} 

Сервер настроен.


\subsection{Настройка сервиса точного времени NTP}
Сервис точного времени NTP (\textit{Network Time Protocol} — протокол сетевого времени) предназначен для синхронизации времени между серверами и ПК в сети.

Существует ряд режимов работы сервиса NTP, наиболее популярный из них: клиент-серверный режим. В этом режиме клиент посылает запрос серверу, который обрабатывает его и посылает ответ. Такой режим работы обеспечивает синхронизацию времени клиента со временем эталонного сервера. Это направленный режим от сервера к клиенту. Данный режим  используется, когда нужна максимальная точность синхронизации времени и надежная защита передаваемой информации.

В данном руководстве предполагается наличие сети без выхода в сеть Интернет, и/или существует необходимость организовать свой собственный сервер точного времени.

Если у вас есть выход в сеть Интернет, то вы можете организовать аналогичный режим работы, при этом дополнительно настроить ваш сервер NTP на синхронизации времени с одного или нескольких серверов точного времени в Интернете.

Данная инструкция рассчитана на создание самого простого сервера NTP, с которого клиенты смогут получать данные для синхронизации времени.

Эта инструкция будет полезна в случае, если у вас есть закрытая сеть без выхода в Интернет. 

Для настройки сервера точного времени ntpd необходимо выполнить следующие действия:

\begin{enumerate}
 \item Установить сервис ntp, если он еще не установлен, командой:\\
 \begin{verbatim}
  yum install ntp
 \end{verbatim}
 \item Для настройки автоматического запуска демона при загрузке системы, используйте специальную команду:\\
 \begin{verbatim}
  systemctl enable ntpd
 \end{verbatim}
 \item Отредактируйте конфигурационный файл сервера /etc/ntp.conf , он должен содержать как минимум следующие данные:\\
 \begin{verbatim}
  driftfile /var/lib/ntp/ntp.drift
statsdir /var/log/ntpstats/
#каталог для сбора статистики
statistics loopstats peerstats clockstats
filegen loopstats file loopstats type day enable
filegen peerstats file peerstats type day enable
filegen clockstats file clockstats type day enable
server <ip адрес сервера ntp>
server 127.127.1.0
fudge 127.127.1.0 stratum 0
restrict -4 default kod notrap nomodify nopeer noquery
restrict -6 default kod notrap nomodify nopeer noquery
restrict 127.0.0.1
restrict <ваша сеть> mask <маска вашей сети> nomodify notrap
 \end{verbatim} 
 \item Запустите службу NTP:\\
\begin{verbatim}
# systemctl start ntpd
\end{verbatim} 
\end{enumerate}

Расшифровка основных параметров конфигурационного файла приведена в таблице ниже:

\begin{longtable}{  m{5cm}  m{12cm}  }  
 \textbf{Параметр} & \textbf{Описание}\\\hline
 driftfile & Указывает файл для хранения информации о частоте смещения времени. В этом файле хранится значение, получаемое в результате предшествующих корректировок времени. Если внешние NTP-серверы по той или иной причине становятся недоступными, значение будет взятого из него.\\
 statsdir & Каталог для сбора статистики работы сервиса\\
 server & Если ваш сервер будет сам обновлять свое время с некоторого внешнего сервера. Если верхних серверов NTP нет, то указывается 127.127.1.0. В этом случае будет использоваться локальное время ОС.\\
 restrict & Ограничивает работу сервиса в определенной подсети, например:\begin{verbatim}restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap                                                                                                                           \end{verbatim} 
Сервер NTP будет отвечать на запросы только из подсети  192.168.1.0/24.
Крайне рекомендуется использовать данный параметр, чтобы ограничить нагрузку на сервер.\\
\end{longtable}

Перезагрузите демон NTP командой:

\begin{verbatim}
# systemctl restart ntpd
\end{verbatim} 

\subsection{Управление пользователями и группами в консольном режиме}

\begin{longtable}{  m{5cm}  m{15cm}  }  
 \textbf{Утилита} & \textbf{Описание}\\\hline
 id & Показывает ID пользователей и групп\\
 useradd, usermod, userdel & Стандартные утилиты для добавления, изменения и удаления учётных записей пользователей.\\
 groupadd, groupmod, groupdel & Стандартные утилиты для добавления, изменения и удаления групп\\
 gpasswd & Утилита, используемая в основном для изменения паролей групп в файле \begin{verbatim}/etc/gshadow\end{verbatim}, который используется командой \textbf{newgrp}.\\
 pwck, grp & Утилиты, которые можно использовать для проверки паролей, групп и связанных с ними теневых файлов.\\
 pwconv, pwunconv & Утилиты, которые можно использовать для преобразования стандартных паролей в теневые пароли и наоборот.\\
 grpconv, grpunconv & По аналогии с предыдущими программами, эти утилиты можно использовать для преобразования теневой информации для групповых учётных записей.
\end{longtable}

\subsubsection{Добавление нового пользователя}
Для добавления в систему нового пользователя, введите следующую команду с привилегиями пользователя root:
\begin{verbatim}
useradd [параметры] username
\end{verbatim} 
Параметры этой команды описаны ниже в таблице

Возможные параметры консольной команды useradd:

\begin{longtable}{  m{5cm}  m{12cm}  }  
 -c 'комментарий' & Комментарий может быть любой строкой. Этот параметр обычно используется для указания полного имени пользователя.\\
 -d домашний\_каталог & Создание домашнего каталога вместо каталога по умолчанию, т.е.  /home/имя\_пользователя/.\\
 -e дата & Дата отключения учётной записи, в формате ГГГГ-ММ-ДД.\\
 f дней & Число дней между моментом истечения срока действия пароля и до момента отключения учётной записи.  Если был указан 0, учётная запись отключается сразу же после истечения срока действия пароля. Если было указано число -1, то после истечения срока действия пароля учётная запись пользователя не отключается.\\
 -g имя\_группы & Имя или номер группы для группы пользователя по умолчанию (первичной группы). На момент создания пользователя группа должна уже существовать.\\
 -G список\_группы & Список дополнительных (добавочных, отличных от группы по умолчанию) имён или номеров групп, в которых состоит пользователь, разделённых запятой. Перед созданием пользователя этой группы должны существовать.\\
 -m & Создать домашний каталог при его отсутствии\\
 M & не создавать домашний каталог\\
-N & Не создавать частную группу для пользователя.\\
-p пароль & Пароль, зашифрованный с помощью crypt.\\
-r & Создать системную учётную запись со значением UID меньше 1000 и без домашнего каталога\\
-s & Командный интерпретатор пользователя, по умолчанию /bin/bash.\\
-u uid & Пользовательский ID, значение должно быть уникальным и иметь значение не более 999.\\
\end{longtable}

\so{Важно:}
По сравнению с предыдущими версиями ОС ROSA Enterprise Linux Server диапазон ID по умолчанию для системных и обычных пользователей был изменён. Ранее для системных пользователей использовалось значение UID 1-499, для обычных — значения больше этого. Теперь диапазон по умолчанию для системных пользователей равен 1-999. Это изменение может привести к проблемам при миграции уже существующих пользователей, значения UID и GID которых находятся в диапазоне между 500 и 999. Диапазоны UID и GID по умолчанию можно изменить в файле /etc/login.defs.

По умолчанию команда useradd создаёт заблокированную учётную запись пользователя. Чтобы разблокировать учётную запись, выполните следующую команду для присвоения пароля (от пользователя root)

\begin{verbatim}
passwd имя_пользователя
\end{verbatim} 

\subsubsection{Добавление новой группы}
Чтобы добавить новую группу в систему, введите следующую команду в консоли, с правами пользователя root:
\begin{verbatim}
groupadd [параметры] имя_группы\end{verbatim} 

Параметры этой команды описаны ниже в таблице.

\begin{longtable}{  m{5cm}  m{12cm}  }  
 \textbf{Параметр} & \textbf{Описание}\\
-f, --force & В сочетании с параметром «-g gid», если этот gid уже существует, то groupadd выберет для группы другой уникальный gid\\
-g gid & Идентификатор группы, должен иметь уникальное значение, более 999.\\
-K, --key ключ=значение & перезаписывает значения по умолчанию для файла /etc/login.defs\\
-o, --non-unique & Разрешает создание групп с дублирующимися GID.\\
-p, --password пароль & Использовать для группы этот зашифрованный пароль\\
-r & Создать системную группу со значением GID менее 1000.\\
\end{longtable}

\subsubsection{Добавление существующего пользователя в существующую группу}
Для добавления уже существующего пользователя в существующую группу используется утилита \textbf{usermod}
Различные параметры usermod по-разному влияют на первичную группу пользователя и дополнительные группы пользователя.

Для изменения первичной группы пользователя, выполните следующую команду от имени пользователя root:
\begin{verbatim}
# usermod -g group_name user_name\end{verbatim} 

Для изменения дополнительных групп пользователя выполните следующую команду от имени пользователя root:
\begin{verbatim}
# usermod -G group_name1,group_name2,... user_name\end{verbatim} 

Обратите внимание, что в этом случае все ранее существовавшие параметры дополнительных групп пользователя будут заменены на другую группу или несколько других групп.

Чтобы добавить одну или несколько групп к дополнительным группам пользователя, выполните следующую команду от имени пользователя root:
\begin{verbatim}
# usermod -aG group_name1,group_name2,... user_name
\end{verbatim} 
\begin{verbatim}
# usermod --append -G group_name1,group_name2,... user_name
\end{verbatim} 

Обратите внимание, что в этом случае другие группы добавляются к дополнительным группам пользователя.

\subsubsection{Создание каталогов групп}
Для каждого крупного проекта системные администраторы обычно создают группу и присваивают этим группам пользователей для предоставления им доступа к файлам этого проекта. В рамках этой традиционной схемы управление файлами является трудной задачей; если кто-нибудь создаёт файл, он связывается с первичной группой, к которой они принадлежат. Если один и тот же человек работает в нескольких проектах, то становится трудно привязать правильные файлы к соответствующей группе. Тем не менее, в рамках схемы UPG, группы автоматически присваиваются файлам, созданным в каталоге, для которого настроен бит \textbf{setgid}. Бит setgid крайне упрощает управление групповыми проектами с общими каталогами, т.к. любые файлы, создаваемые пользователем в каталоге, принадлежат группе, которой принадлежит этот каталог.

Предположим, группе сотрудников нужно работать с файлами в каталоге /opt/myproject/. Некоторым сотрудникам разрешено изменять содержимое этого каталога, но не всем.

С правами пользователя root создайте каталог /opt/myproject/, введя следующую команду в консоль командного интерпретатора:
\begin{verbatim}
mkdir /opt/myproject
\end{verbatim} 

Добавим группу myproject в систему:
\begin{verbatim}
groupadd myproject
\end{verbatim} 
Свяжем содержимое каталога /opt/myproject/ с группой myproject:
\begin{verbatim}
 chown root:myproject /opt/myproject
\end{verbatim} 

Разрешим пользователям в группе создавать файлы в этом каталоге и установим бит setgid:
\begin{verbatim}
 chmod 2775 /opt/myproject
\end{verbatim} 

На этом этапе все члены группы myproject могут создавать и изменять файлы в каталоге /opt/myproject/, так что системному администратору нет необходимости изменять права доступа на файлы каждый раз, когда пользователи создают новые файлы. Чтобы проверить, что права на файлы были установлены правильно, выполните следующую команду:

\begin{verbatim}
 # ls -ld /opt/myproject
drwxrwsr-x. 3 root myproject 4096 Mar  3 18:31 /opt/myproject
\end{verbatim} 

Добавим пользователей в группу myproject:
\begin{verbatim}
 usermod -aG myproject username
\end{verbatim} 

\subsubsection{Установление прав доступа по умолчанию для новых файлов с помощью umask}
Когда процесс создаёт файл, то у этого файла есть определённые права доступа по умолчанию, например, -rw-rw-r--. Эти начальные права доступа частично определяются маской режима создания файлов, также называемой маской прав файлов или umask. У каждого процесса есть своя umask, например, umask для bash по умолчанию имеет значение 0022. Значение umask процесса можно изменять.

\paragraph{Управление значениями umask в командных интерпретаторах}
В популярных командных интерпретаторах, таких, как bash, ksh, zsh и tcsh, значение umask регулируется umask, встроенной в командный интерпретатор. Процесс, запущенный в командном интерпретаторе, наследует его umask.

Как узнать текущую маску
Чтобы посмотреть текущее значение umask в восьмеричном формате:
\begin{verbatim}
$ umask
0022
\end{verbatim} 

Чтобы посмотреть текущее значение umask в символьном формате:
\begin{verbatim}
$ umask -S
u=rwx,g=rx,o=rx
\end{verbatim} 

\paragraph{Установка маски в командном интерпретаторе с помощью umask}

Чтобы настроить значение umask для текущего сеанса командного интерпретатора, выполните:
\begin{verbatim}
 $ umask восьмеричная_маска
\end{verbatim} 

Замените параметр «восьмеричная\_маска» четырьмя цифрами от 0 до 7. При указании трёх или менее цифр, права доступа устанавливаются так, как если бы в начале были указаны нули. Например,  umask 7 интерпретируется как  0007.
⁠
Установка значения umask в восьмеричном формате

Чтобы запретить владельцу и группе запись и выполнение вновь создаваемых файлов, а также любые права доступа для остальных:
\begin{verbatim}
$ umask 0337
\end{verbatim} 
Или просто:
\begin{verbatim}
$ umask 337
\end{verbatim} 
Чтобы установить значение umask для текущего сеанса командного интерпретатора в символьном формате:
\begin{verbatim}
$ umask -S символьная_маска
\end{verbatim} 
⁠
Установка значения umask в символьном формате

Чтобы установить значение umask 0337 в символьном формате:
\begin{verbatim}
$ umask -S u=r,g=r,o=
\end{verbatim} 

\paragraph{Работа со значением umask в командном интерпретаторе по умолчанию}
Значение umask командного интерпретатора обычно записывается в его конфигурационном файле. Для bash это /etc/bashrc. Чтобы просмотреть значение umask по умолчанию для bash:
\begin{verbatim}
$ grep -i -B 1 umask /etc/bashrc
\end{verbatim} 

Здесь мы можем просмотреть, назначено ли значение umask, либо с помощью  команды umask либо с помощью переменной UMASK. В примере ниже umask настроена на значение 022 с помощью команды umask:
\begin{verbatim}
 $ grep -i -B 1 umask /etc/bashrc
    # By default, we want umask to get set. This sets it for non-login shell.
--
    if [ $UID -gt 199 ] && [ "`id -gn`" = "`id -un`" ]; then
       umask 002
    else
       umask 022
\end{verbatim} 

Чтобы сменить значение umask по умолчанию для bash, смените вызов команды umask или присвоение переменной UMASK  в файле /etc/bashrc. Пример ниже показывает, как сменить umask по умолчанию на значение 0227:
\begin{verbatim}
     if [ $UID -gt 199 ] && [ "`id -gn`" = "`id -un`" ]; then
       umask 002
    else
       umask 227
\end{verbatim} 


\paragraph{Управление значением umask в командном интерпретаторе по умолчанию для конкретного пользователя}
По умолчанию, значение umask в bask для нового пользователя определяется в /etc/bashrc.

Чтобы сменить значение umask для bash для конкретного пользователя, добавьте вызов для команды umask в файле \$HOME/.bashrc для этого пользователя. Чтобы, например, сменить umask для пользователя john на 0227:

\begin{verbatim}
 john@server ~]$ echo 'umask 227' >> /home/john/.bashrc
\end{verbatim} 


\paragraph{Изменение прав доступа по умолчанию для создаваемых домашних каталогов пользователей}
Чтобы изменить права доступа, с которыми создаются домашние каталоги пользователей, измените значение переменной UMASK в файле /etc/login.defs
\begin{verbatim}
# The permission mask is initialized to this value. If not specified,
# the permission mask will be initialized to 022.
UMASK 077
\end{verbatim} 

Дополнительную информацию о различных утилитах для управления пользователями и группами см. на следующих страницах руководств:

\begin{longtable}{  m{4cm}  m{10cm}  }
useradd(8) & команда useradd: как создавать новых пользователей\\
userdel(8) & команда userdel: как удалять новых пользователей\\
usermod(8) & команда usermod: как изменять параметры пользователей\\
groupadd(8) & команда groupadd: как создавать новые группы\\
groupdel(8) & команда groupdel: как удалять группы\\
groupmod(8) & команда groupmod: как изменять членство в группах\\
gpasswd(1) & команда gpasswd: как работать с файлом /etc/group\\
grpck(8) & команда grpck: как проверить целостность файла /etc/group\\
pwck(8) & команда pwck:  как проверить целостность файлов /etc/passwd и /etc/shadow\\
pwconv(8) & команды pwconv, pwunconv, grpconv и grpunconv: как преобразовывать теневую информацию для пользователей и групп\\
id(1) & команда id: как просмотреть идентификатороы пользователей и групп\\
umask(2) & команда umask: как работать с маской режима создания файлов\\
\end{longtable}

Информацию о соответствующих файлах конфигурации см. на следующих страницах руководств:
\begin{longtable}{  m{4cm}  m{10cm}  }
group(5) & как использовать файл /etc/group для настройки системных групп\\
passwd(5) & как использовать файл /etc/passwd для настройки информации о пользователях\\
shadow(5) & как использовать файл /etc/shadow для настройки паролей и информации о сроках действия учётных записей в системе\\
\end{longtable}

\subsection{Защита паролей}
В целях безопасности, во время установки ROSA Enterprise Server система настраивается на использование алгоритма безопасного хеширования 512 (SHA512) и теневых паролей. Крайне рекомендуем не изменять этих параметры.

Если во время установки не выбрать параметр теневых паролей, то все пароли будут храниться в однонаправленном хеше в файле /etc/passwd, открытом для чтения для всех, что делает систему уязвимой для внешних атак, направленных на взлом пароля. Если недоброжелатель сможет получить доступ к машине под учётной записью обычного пользователя, он сможет скопировать файл /etc/passwd на свою машину и запустить любое количество программ на взлом пароля. Если в файле будет не надёжный (слабый) пароль, то его обнаружение недоброжелателем — это только вопрос времени.

Теневые пароли исключают такой тип атак, т.к. хеши паролей хранятся в файле /etc/shadow, доступ на чтение которого есть только у пользователя root.

Это вынуждает недоброжелателя на попытку удалённого взлома пароля через авторизацию в сетевом сервисе на машине, таком, как SSH или FTP. Такой тип атак с полным перебором (брутфорс) выполняется гораздо медленнее и оставляет очевидный след в виде сотен неудачных попыток авторизации, записанных в системный журнал. Конечно, если взломщик начнёт атаку на систему со слабым паролем в полночь, то к рассвету он может уже получить доступ и изменить файлы журнала для скрытия следов.

Кроме формата и условий хранения паролей, также существует проблема содержимого. Единственное, что пользователь может сделать, чтобы защитить свою учётную запись от попыток взлома пароля — это создание надёжного пароля.

\subsubsection{Принудительное создание надёжных паролей}
В организациях с большим количеством пользователей, у системных администраторов есть два возможных пути для принуждения пользователей к созданию надёжных паролей. Они могут создать пароль для пользователя самостоятельно, или же дать пользователю самому создать пароль с проверкой на его соответствие требованиям безопасности.

Создание паролей для пользователей гарантирует надёжность паролей, но становится тяжёлой обязанностью по мере роста организации. Также это провоцирует пользователей записывать свои пароли, что повышает риск.  В силу этих причин, большинство системных администраторов предпочитают, чтобы пользователи сами создавали свои пароли, но подвергают эти пароли строгим проверкам. В некоторых случаях администраторы могут заставлять пользователей менять пароли с помощью установки срока действия пароля.

При необходимости сменить пароль, пользователи могут использовать консольную утилиту passwd, поддерживающую протокол PAM (Pluggable Authentication Modules) и способную проверить пароль на необходимую длину и другие факторы устойчивости к взлому. Эту проверку выполняет модуль PAM pam\_pwquality.so.

\so{Внимание}
В ROSA Enterprise Linux Server модуль pam\_pwquality заменил pam\_cracklib, который использовался ранее по умолчанию для проверок паролей на безопасность. 

Для проверок паролей на соответствие требованиям безопасности модуль pam\_pwquality использует набор правил. Процедура проверки состоит из двух шагов: сначала проверяется проверка на наличие слова в словаре. Если нет, то далее выполняется некоторое число дополнительных проверок. Модуль pam\_pwquality наряду с другими модулями PAM, используется в качестве компонента паролей в файле /etc/pam.d/passw, а набор правил указывается в конфигурационном файле /etc/security/pwquality.conf. Полный список этих проверок см. на странице руководства pwquality.conf(8).


\subsubsection{Настройка проверки паролей на безопасность в файле pwquality.conf}
Чтобы активировать использование pam\_quality, добавьте следующую строку в файл /etc/pam.d/passwd:
\begin{verbatim}
password    required    pam_pwquality.so retry=3
\end{verbatim} 

Параметры проверки указываются по одному на строку. Чтобы, например, пароль был не менее 8 символов в длину, и включал в себя все четыре класса символов, добавьте следующие строки в файл /etc/security/pwquality.conf :
\begin{verbatim}
minlen = 8 
minclass = 4
\end{verbatim} 

Чтобы настроить проверку на последовательность символов и последовательный повтор одних и тех же символов, добавьте следующие строки в файл /etc/security/pwquality.conf:
\begin{verbatim}
maxsequence = 3
maxrepeat = 3
\end{verbatim} 
В этом примере введённый пароль не может содержать более 3 символов в монотонной последовательности, таких, как «абвгд», и более 3 идентичных последовательных символов, таких, как 1111.

\so{Внимание}
Поскольку пользователь root является тем, кто принуждает к использованию правил соответствия паролей требованиям безопасности, то пользователь root может создавать любой пароль как для своей, так и для пользовательской учётной записи, игнорируя предупреждения безопасности.


\subsubsection{Настройка сроков действия паролей}
Ограничение сроков действия паролей — это ещё один способ, используемый системными администраторами для защиты от слабых паролей в подотчётной организации. Срок действия пароля означает, что по истечении указанного времени (обычно это 90 дней), пользователю будет показан запрос о создании нового пароля. В теории, если пользователь будет вынужден периодически менять пароль, то возможный взломанный пароль будет полезен недоброжелателю только в течении ограниченного промежутка времени. Минус принудительной смены паролей в том, что пользователи скорей всего будут свои пароли где-то записывать.

Для указания сроков принудительной смены паролей используйте команду \textbf{chage}.

\so{Важно}
В ROSA Enterprise Linux Server теневые пароли используются по умолчанию. 
Параметр -M команды chage указывает максимальное число дней, в течении которых пароль остаётся действительным. Чтобы, например, указать, что срок действия пароля пользователя закончится через 90 дней, используйте следующую команду:
\begin{verbatim}
 chage -M 90 имя_пользователя
\end{verbatim} 

Замените в вышеприведённой команде «имя\_пользователя» системным именем пользователя. Чтобы отключить срок действия пароля, после параметра -M укажите параметр -1.

С командой chage можно также работать в интерактивном режиме для изменения нескольких сроков действия паролей и параметров учётных записей. Чтобы войти в интерактивный режим, используйте следующую команду:
\begin{verbatim}
 chage <имя_пользователя>
\end{verbatim}

Ниже приводится пример интерактивной сессии использования этой команды:
\begin{verbatim}
# chage vasily
Changing the aging information for vasily
Enter the new value, or press ENTER for the default
Minimum Password Age [0]: 10
Maximum Password Age [99999]: 90
Last Password Change (YYYY-MM-DD) [2006-08-18]:
Password Expiration Warning [7]:
Password Inactive [-1]:
Account Expiration Date (YYYY-MM-DD) [1969-12-31]:
\end{verbatim} 

Можно настроить смену пароля сразу же после первой авторизации пользователя в системе, чтобы принудить пользователя сменить пароль немедленно:
Настройте начальный пароль. Чтобы присвоить пароль по умолчанию, введите следующую команду в консоли с правами root:
\begin{verbatim}
passwd пользователь
\end{verbatim} 

\so{Внимание}
Утилита passwd предоставляет возможность настроить нулевой пароль. Это удобно, но крайне ненадёжно, так любое постороннее лицо может войти в систему и получить доступ с использованием такого незащищённого пользователя. При любой возможности избегайте использования нулевых паролей. Если это невозможно, всегда сначала нужно убедиться, что пользователь уже готов войти в систему, перед тем, как разблокировать учётную запись с нулевым паролем.

Команда для немедленной принудительной смены пароля (с правами root):
\begin{verbatim}
 chage -d 0 пользователь
\end{verbatim} 

Эта команда настраивает значение последней смены пароля на начало отсчёта времени (1 января 1970 года). Это значение принуждает к немедленному прекращению сроку действия пароля вне зависимости от параметров политики срока действия паролей, если такая существует. После первой авторизации в системе пользователю выводится запрос на указание нового пароля.


\subsection{Блокировка учётных записей пользователей}
В ROSA Enterprise Linux Server  модуль PAM \textbf{pam\_faillock} даёт системным администраторам возможность заблокировать учётную запись пользователя после нескольких неудачных попыток авторизации. Ограничение числа попыток авторизации пользователей служит в основном средством защиты от возможных атак брутфорс, направленных на получение пароля учётной записи пользователя.

При наличии модуля pam\_faillock, неудачные попытки авторизации записываются в отдельный файл для каждого пользователя в каталоге /var/run/faillock.

\so{Внимание}
Порядок строк в неудачных попытках авторизации очень важен. Любая попытка сменить этот порядок может заблокировать учётные записи всех пользователей, включая пользователя root, если используется параметр even\_deny\_root.

Для настройки блокировки учётных записей выполните следующие действия:


\begin{itemize}
 \item Проверим, являются ли файлы system-auth и password-auth символьными ссылками, указывающими на system-auth-ac и password-auth-ac (это параметры по умолчанию):
\begin{verbatim}
 # ls -l /etc/pam.d/{password,system}-auth
\end{verbatim} 
Если вывод команды будет аналогичен следующему, то символьные ссылки на месте, и можно переходить к шагу 3:
\begin{verbatim}
lrwxrwxrwx. 1 root root 16 24. Feb 09.29 /etc/pam.d/password-auth -> password-auth-ac
lrwxrwxrwx. 1 root root 28 24. Feb 09.29 /etc/pam.d/system-auth -> system-auth-ac
\end{verbatim} 
Если файлы system-auth и password-auth не являются символьными ссылками, переходите к следующему шагу.
\item Переименуем конфигурационные файлы:
\begin{verbatim}
 # mv /etc/pam.d/system-auth /etc/pam.d/system-auth-ac
# mv /etc/pam.d/password-auth /etc/pam.d/password-auth-ac
\end{verbatim} 
\item Создадим файлы с конкретными параметрами:
\begin{verbatim}
 # vi /etc/pam.d/system-auth-local
\end{verbatim} 
Файл /etc/pam.d/system-auth-local должен содержать следующие строки:
\begin{verbatim}
auth        required       pam_faillock.so preauth silent audit deny=3 unlock_time=600
auth        include        system-auth-ac
auth        [default=die]  pam_faillock.so authfail silent audit deny=3 unlock_time=600

account     required       pam_faillock.so
account     include        system-auth-ac

password    include        system-auth-ac

session     include        system-auth-ac
\end{verbatim}
\begin{verbatim}
# vi /etc/pam.d/password-auth-local
\end{verbatim} 
Файл /etc/pam.d/password-auth-local должен содержать следующие строки:
\begin{verbatim}
auth        required       pam_faillock.so preauth silent audit deny=3 unlock_time=600
auth        include        password-auth-ac
auth        [default=die]  pam_faillock.so authfail silent audit deny=3 unlock_time=600

account     required       pam_faillock.so
account     include        password-auth-ac

password    include        password-auth-ac

session     include        password-auth-ac
\end{verbatim}
\item Создадим следующие символьные ссылки:
\begin{verbatim}
# ln -sf /etc/pam.d/system-auth-local /etc/pam.d/system-auth
# ln -sf /etc/pam.d/password-auth-local /etc/pam.d/password-auth
\end{verbatim} 
\end{itemize}


Подробности о возможных параметрах pam\_faillock см. на странице руководства pam\_faillock(8).


\subsection{Блокировка виртуальных консолей помощью vlock}
С помощью утилиты \textbf{vlock} пользователи могут заблокировать виртуальную консоль. Чтобы установить эту утилиту, выполните следующую команду от пользователя root:

\begin{verbatim}
# yum install vlock
\end{verbatim} 

После установки, любой консольный сеанс можно заблокировать с помощью команды vlock без дополнительных параметров. Текущий сеанс виртуальной консоли будет заблокирован без прерывания доступа других пользователей. Чтобы предотвратить доступ ко всем виртуальным консолям машины, выполните следующее:

\begin{verbatim}
 vlock -a
\end{verbatim} 

В этом случае vlock блокирует  текущую активную консоль, а параметр -a предотвращает переключение в другие виртуальные консоли. Подробности смотрите на странице руководства vlock(1).


\section{Менеджер пакетов Yum}
Yum — это менеджер пакетов в ROSA Enterprise Linux Server, который имеет возможность сделать запрос информации о доступных пакетах, загрузить пакеты из репозиториев, установить и удалить их из системы, а также обновить всю систему полностью до последней доступной версии. Во время обновления, установки или удаления пакетов, yum автоматически выполняет разрешение зависимостей, и таким образом автоматически может определить, скачать и установить все доступные пакеты зависимостей.

Для работы yum можно также подключать новые дополнительные репозитории (или «источники пакетов»), а также предоставляет множество модулей, расширяющих и углубляющих его возможности. Задачи, выполняемые yum, аналогичны задачам, которые выполняет пакетный менеджер RPM, многие из консольных команд этих пакетных менеджером идентичны. Yum предоставляет возможность простого и лёгкого управления пакетами на одной машине или в группе машин.

\so{Важно}
Yum предоставляет защищённое управление пакетами с помощью проверки подписи GPG (инструмента для безопасных коммуникаций GPG, Gnu Privacy Guard; также известен как GnuPG) на подписанных пакетах. Проверку подписей GPG можно включить для всех репозиториев  пакетов (источников пакетов) или для отдельных репозиториев. При включённой возможности проверки подписей, yum откажется устанавливать любые пакеты, у которых отсутствует подпись GPG с корректным ключом. Это означает, что пользователю гарантируется загрузка и установка пакетов RPM только из доверенных источников, и что эти пакеты не были изменены во время их передачи.



\so{Внимание}
Для того, чтобы yum смог установить, обновить или удалить пакеты в системе, необходимо обладать правами пользователя root. Все примеры в этом разделе предполагают, что эти права уже получены.



\subsection{Проверка и установка обновлений пакетов}
Yum предоставляет возможность проверить, есть ли обновления для пакетов, установленных в системе. Пользователь может указать список пакетов и обновить их сразу целиком или же обновить отдельный выбранный пакет.


\subsubsection{Проверка наличия обновлений}
Чтобы просмотреть, для каких из установленных в системе пакетов имеются обновления, выполните следующую команду:
\begin{verbatim}
 yum check-update
\end{verbatim} 
⁠
Пример вывода команды yum check-update:
\begin{verbatim}
# yum check-update
Loaded plugins: product-id, search-disabled-repos, subscription-manager
dracut.x86_64                         033-360.el7_2      rhel-7-server-rpms
dracut-config-rescue.x86_64           033-360.el7_2      rhel-7-server-rpms
kernel.x86_64                         3.10.0-327.el7     rhel-7-server-rpms
rpm.x86_64                            4.11.3-17.el7      rhel-7-server-rpms
rpm-libs.x86_64                       4.11.3-17.el7      rhel-7-server-rpms
rpm-python.x86_64                     4.11.3-17.el7      rhel-7-server-rpms
yum.noarch                            3.4.3-132.el7      rhel-7-server-rpms
\end{verbatim} 

В примере выше, для списка пакетов выше доступны обновления. Первый пакет в списке — это dracut. Каждая строка в примере состоит из нескольких столбцов, для dracut это:

\begin{longtable}{  m{3cm}  m{10cm}  }  
 dracut & имя пакета,\\
 x86\_64 & архитектура ЦПУ, для которой был собран пакет,\\
 033 & версия устанавливаемого обновления,\\
 360.el7 & номер релиза обновления,\\
 \_2 & версия сборки, добавляемая как часть обновления z-stream\\
 rhel-7-server-rpms & репозиторий, в котором находится обновление\\
\end{longtable}

\subsubsection{Обновление пакетов}
Пользователь может выбрать обновление одного пакета, нескольких пакетов или всех пакетов сразу. Если для зависимостей обновляемых пакетов также имеются обновления, то они также будут установлены.

\subsection{Обновление одного пакета}

Чтобы обновить один пакет, выполните следующую команду с правами пользователя root:
\begin{verbatim}
 yum update имя_пакета
\end{verbatim} 

\textbf{Пример: обновление пакета rpm}

Чтобы обновить пакет \textbf{rpm}, введите:
\begin{verbatim}
 # yum update rpm
Loaded plugins: langpacks, product-id, subscription-manager
Updating Red Hat repositories.
INFO:rhsm-app.repolib:repos updated: 0
Setting up Update Process
Resolving Dependencies
--> Running transaction check
---> Package rpm.x86_64 0:4.11.1-3.el7 will be updated
--> Processing Dependency: rpm = 4.11.1-3.el7 for package: rpm-libs-4.11.1-3.el7.x86_64
--> Processing Dependency: rpm = 4.11.1-3.el7 for package: rpm-python-4.11.1-3.el7.x86_64
--> Processing Dependency: rpm = 4.11.1-3.el7 for package: rpm-build-4.11.1-3.el7.x86_64
---> Package rpm.x86_64 0:4.11.2-2.el7 will be an update
--> Running transaction check
...
--> Finished Dependency Resolution

Dependencies Resolved
=============================================================================
 Package                   Arch        Version         Repository       Size
=============================================================================
Updating:
 rpm                       x86_64      4.11.2-2.el7    rhel            1.1 M
Updating for dependencies:
 rpm-build                 x86_64      4.11.2-2.el7    rhel            139 k
 rpm-build-libs            x86_64      4.11.2-2.el7    rhel             98 k
 rpm-libs                  x86_64      4.11.2-2.el7    rhel            261 k
 rpm-python                x86_64      4.11.2-2.el7    rhel             74 k

Transaction Summary
=============================================================================
Upgrade  1 Package (+4 Dependent packages)

Total size: 1.7 M
Is this ok [y/d/N]:
\end{verbatim} 


В примерном выводе команды есть несколько интересных моментов:\\
\textbf{Loaded plugins: langpacks, product-id, subscription-manager} — Yum всегда сообщает о том, какие модули yum установлены и включены.

\textbf{rpm.x86\_64} — возможна загрузка и установка нового пакета rpm, а также и его зависимостей. Для каждого из этих пакетов выполняется проверка транзакции.

Yum предоставляет информацию об обновлении и затем предлагает пользователю его подтвердить, по умолчанию yum выполняется в интерактивном режиме. Если пользователь уже знает, какие действия yum планирует выполнить, можно указать параметр \textbf{-y} для автоматического ответа на вопросы, задаваемые yum (в этом случае он будет выполняться не интерактивно). Тем не менее, всегда рекомендуется просмотреть, какие изменения yum планирует внести в систему, чтобы не оказаться безоружным при возникшей проблеме. Также можно выбрать возможность простой загрузки пакетов без их установки. Для этого в предложении загрузки введите \textbf{d}. Это запустит фоновую загрузку выбранного пакета.

Если транзакция окончилась неудачей, можно просмотреть историю транзакций yum с помощью команды \textbf{yum history} 


\so{Важно}
Yum всегда  устанавливает новое ядро, вне зависимости от того, была ли указана команда \textbf{yum update} или \textbf{yum install} . С другой стороны, при использовании rpm, важно применить команду \textbf{rpm -i kernel}, устанавливающую новое ядро, вместо команды \textbf{rpm -u kernel} , которая заменяет текущее ядро.

Точно также можно обновить и группу пакетов. Введите с правами пользователя root:
\begin{verbatim}
 yum group update имя_группы_пакетов
\end{verbatim} 

Замените \textit{имя\_группы\_пакетов} на имя группы пакетов, которую нужно обновить. 

\subsection{Обновление всех пакетов в системе и их зависимостей}
Чтобы обновить все пакеты и их зависимости, используйте команду \textbf{yum update} без аргументов:
\begin{verbatim}
 yum update
\end{verbatim}

\subsection{Обновления безопасности}
Если для пакетов доступны обновления безопасности, можно обновить только эти пакеты до их последних версий. Введите с правами root:
\begin{verbatim}
yum update --security
\end{verbatim} 

Также можно обновить пакеты только до версий, в которых содержатся последние обновления безопасности. Введите с правами root:
\begin{verbatim}
yum update-minimal --security
\end{verbatim} 

Предположим, что:
В системе установлен пакет kernel-3.10.0-1 ;
пакет kernel-3.10.0-2 был выпущен как обновление безопасности;
пакет kernel-3.10.0-3 был выпущен как пакет с исправлением ошибок.
Тогда команда \textit{yum update-minimal --security} обновит пакет до версии kernel-3.10.0-2, а \textit{yum update --security} обновит пакет до версии kernel-3.10.0-3.

\subsection{Обновление системы, не подключенной к интернет}
Для систем, отключённых от сети Internet, использование команды yum update в сочетании с установочным образом ROSA Enterprise Linux Server — это лёгкий и быстрый способ обновления до свежей минорной версии. Процесс такого обновления состоит из нескольких шагов:

\begin{itemize}
 \item Создайте целевой каталог для монтирования образа ISO. Этот каталог не создаётся автоматически во время монтирования, поэтому его нужно создать заранее. Введите с правами пользователя root:
\begin{verbatim}
mkdir mount_dir\end{verbatim} 
\item Замените \textit{mount\_dir} путём до каталога монтирования. Обычно пользователи создают каталог внутри каталога \textit{/media}. Смонтируйте установочный образ ROSA Enterprise Linux Server в предварительно созданный каталог. Введите с правами пользователя root:
\begin{verbatim}
mount -o loop iso_name mount_dir\end{verbatim} 
\item Замените \textit{iso\_name} путём до образа ISO, а \textit{mount\_dir} — путём до целевого каталога. В данном случае параметр \textbf{-o} нужен для монтирования файла как блочного устройства.
\item Скопируйте файл \textbf{media.repo} из смонтированного каталога в каталог /etc/yum.repos.d/ . Обратите внимание, что для корректной работы, конфигурационные файлы в этом каталоге должны иметь расширение \textbf{.repo}. 
\begin{verbatim}
cp mount_dir/media.repo /etc/yum.repos.d/new.repo\end{verbatim} 

Это действие создаёт конфигурационный файл для репозитория yum. Замените \textit{new.repo} именем файла, например, \textit{rosa.repo}. Отредактируйте этот файл так, чтобы он указывал на установочный образ ROSA Enterprise Linux Server. Добавьте следующую строку в файл \textbf{/etc/yum.repos.d/new.repo}:
\begin{verbatim}
baseurl=file:///mount_dir\end{verbatim} 
\item Замените mount\_dir with путём до точки монтирования. Обновим все репозитории yum, включая \textbf{/etc/yum.repos.d/new.repo} , созданный на предыдущем шаге. Введите с правами пользователя root :
\begin{verbatim}
yum update\end{verbatim} 

Это  действие обновит систему до версии, предлагаемой на смонтированном образе ISO.\\
После успешного обновления можно отмонтировать образ ISO. Введите с правами пользователя root: 
\begin{verbatim}
umount mount_dir\end{verbatim} 

Где \textit{mount\_dir} — это путь до каталога монтирования. Также можно удалить каталог монтирования, созданный во время первого шага. Введите с правами пользователя root: 
\begin{verbatim}
rmdir mount_dir\end{verbatim} 

Если предварительно созданный конфигурационный файл не будет использоваться для другой установки или обновления, его тоже можно удалить. Введите с правами пользователя root:
\begin{verbatim}
rm /etc/yum.repos.d/new.repo\end{verbatim} 
\end{itemize}

\subsection{Работа с пакетами}
YUM предоставляет возможность выполнить полный набор действий с пакетами программ, включая поиск пакетов, просмотр информации о них, установка и удаление.

\subsubsection{Поиск пакетов}
Пользователь может выполнять поиск по имени пакета RPM, описанию и сводке с помощью следующей команды:
\begin{verbatim}
yum search term …\end{verbatim} 
Замените \textit{term} именем нужного пакета.

\paragraph{Поиск пакетов по соответствию строке}
Чтобы получить список всех пакетов, соответствующих строке “vim”, “gvim” или “emacs”, введите:
\begin{verbatim}
 $ yum search vim gvim emacs
Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager
============================= N/S matched: vim ==============================
vim-X11.x86_64 : The VIM version of the vi editor for the X Window System
vim-common.x86_64 : The common files needed by any version of the VIM editor
[output truncated]

============================ N/S matched: emacs =============================
emacs.x86_64 : GNU Emacs text editor
emacs-auctex.noarch : Enhanced TeX modes for Emacs
[output truncated]

  Name and summary matches mostly, use "search all" for everything.
Warning: No matches found for: gvim
\end{verbatim} 

Команда \textbf{yum search} удобна для поиска пакетов, точное имя которых пользователь не знает, но для которых известен связанный с ними термин. Обратите внимание, что по умолчанию поиск yum возвращает соответствия и в имени пакета и в сводке, что ускоряет поиск. Для более подробного, но чуть более медленного поиска используйте команду \textbf{yum search all}.

\paragraph{Фильтрация результатов поиска}
Все команды поиска yum предоставляют пользователю возможность фильтрации результата с помощью добавления одного или более шаблона выражений в качестве аргумента. Шаблоны выражений -- это обычные строки символов, содержащие один или более символа подстановки «*» (который расширяется до соответствия любому поднабору знаков) и «?» (который расширяется до соответствия любому одиночному символу).

Не забывайте об экранировании шаблонов выражений во время указания их в качестве аргументов для команды yum, в противном случае командный интерпретатор Bash обработает эти выражения как расширения имени пути, и может передать yum все файлы в текущем каталоге, совпадающие с шаблоном. Чтобы корректно передать все шаблоны выражений yum, используйте один из следующих приёмов:

Экранируйте символы подстановки, поставив перед ними символ косой черты. Заключайте всё выражение-шаблон в одинарные или двойные кавычки.

Примеры в следующем разделе показывают использование обоих этих способов.

\textbf{Вывод списка пакетов}

Чтобы получить список всех установленных и доступных к установке пакетов, введите следующее:
\begin{verbatim}
yum list all\end{verbatim} 
Чтобы получить список установленных и доступных к установке пакетов, соответствующих указанному шаблону выражения:
\begin{verbatim}
yum list шаблон_выражения…\end{verbatim} 
⁠
\textbf{пример: вывод списка всех пакетов, имеющих отношение к ABRT}

Пакеты, содержащие различные добавления и модули ABRT, начинаются либо с “abrt-addon-” либо с “abrt-plugin-”. Чтобы получить список этих пакетов, введите в консоли следующую команду. Обратите внимание, что символы подстановки экранируются косой чертой:

\begin{verbatim}
$ yum list abrt-addon\* abrt-plugin\*
Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager
Installed Packages
abrt-addon-ccpp.x86_64                   2.1.11-35.el7             @rhel-7-server-rpms
abrt-addon-kerneloops.x86_64             2.1.11-35.el7             @rhel-7-server-rpms
abrt-addon-pstoreoops.x86_64             2.1.11-35.el7             @rhel-7-server-rpms
abrt-addon-python.x86_64                 2.1.11-35.el7             @rhel-7-server-rpms
abrt-addon-vmcore.x86_64                 2.1.11-35.el7             @rhel-7-server-rpms
abrt-addon-xorg.x86_64                   2.1.11-35.el7             @rhel-7-server-rpms
\end{verbatim} 



Чтобы получить список всех пакетов, установленных в системе, используйте ключевое слово \textbf{installed}. Крайний правый столбец в выводе показывает список репозиториев, из которых пакеты был получен.
\begin{verbatim}
yum list installed шаблон_выражения…\end{verbatim} 
⁠
\textbf{Пример: получение списка всех установленных версий пакета krb}

В примере ниже показывается, как получить список всех установленных пакетов, начинающихся с «krb» плюс ровно один символ и тире. Это удобно, если пользователь хочет получить список всех версий какого-то одного компонента, различающихся по номерам. Для корректной обработки запроса весь шаблон выражения заключён в кавычки.

\begin{verbatim}
$ yum list installed "krb?-*"
Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager
Installed Packages
krb5-libs.x86_64                  1.13.2-10.el7                   @rhel-7-server-rpms
\end{verbatim} 

Чтобы получить список всех доступных для установки пакетов во всех подключенных репозиториях, используйте команду в следующем виде:
\begin{verbatim}
yum list available шаблон_выражения…
\end{verbatim} 
⁠
\textbf{Пример: получение списка всех доступных модулей gstreamer}

Чтобы, например, получить список всех доступных пакетов, имена которых которых в начале содержат «gstreamer», а затем «plugin» (модуль), выполните следующую команду:
\begin{verbatim}
$ yum list available gstreamer\*plugin\*
Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager
Available Packages
gstreamer-plugins-bad-free.i686             0.10.23-20.el7         rhel-7-server-rpms
gstreamer-plugins-base.i686                 0.10.36-10.el7         rhel-7-server-rpms
gstreamer-plugins-good.i686                 0.10.31-11.el7         rhel-7-server-rpms
gstreamer1-plugins-bad-free.i686            1.4.5-3.el7            rhel-7-server-rpms
gstreamer1-plugins-base.i686                1.4.5-2.el7            rhel-7-server-rpms
gstreamer1-plugins-base-devel.i686          1.4.5-2.el7            rhel-7-server-rpms
gstreamer1-plugins-base-devel.x86_64        1.4.5-2.el7            rhel-7-server-rpms
gstreamer1-plugins-good.i686                1.4.5-2.el7            rhel-7-server-rpms                                                                                     \end{verbatim} 

\subsection{Получение списка репозиториев}
Чтобы получить список идентификаторов репозиториев, имя репозитория и число пакетов в каждом активном репозитории в системе, используйте следующую команду:

\begin{verbatim}
yum repolist
\end{verbatim} 

Чтобы получить дополнительную информацию об этих репозиториях, добавьте параметр \textbf{-v}. Для каждого репозитория в списке будет показана информация об имени файла, общем размере, дате последнего обновления и основном адресе URL. Как вариант, можно также использовать команду \textbf{repoinfo}, которая выдаст такой же результат.
\begin{verbatim}
yum repolist -v
yum repoinfo
\end{verbatim} 
Чтобы получить список как подключенных, так и не подключенных репозиториев, используйте следующую команду. В список добавляется столбец со статусом репозитория, для информации о том, какие из репозиториев активны, какие -- нет:

\begin{verbatim}
yum repolist all
\end{verbatim} 
⁠Передав в качестве первого аргумента «disabled», можно сузить вывод до неподключенных репозиториев. Для ещё более конкретной информации в качестве аргументов можно передать идентификатор или имя репозитория, а также связанный шаблон выражения. Обратите внимание, что в случае точного совпадения ID или имени репозитория и указанным аргументов, репозиторий будет показан даже если не соответствует фильтру подключен/неподключен.

\subsection{Получение информации о пакетах}
Чтобы узнать информацию об одном или более пакетах,  используйте следующую команду (шаблоны выражений здесь также можно применять):
\begin{verbatim}
yum info имя_пакета\end{verbatim} 
Замените «имя\_пакета» необходимым именем пакета.
⁠
\textbf{Пример: получение информации о пакете abrt}

Чтобы узнать сведения о пакете abrt, введите:

\begin{verbatim}
 $ yum info abrt
Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager
Installed Packages
Name        : abrt
Arch        : x86_64
Version     : 2.1.11
Release     : 35.el7
Size        : 2.3 M
Repo        : installed
From repo   : rhel-7-server-rpms
Summary     : Automatic bug detection and reporting tool
URL         : https://fedorahosted.org/abrt/
License     : GPLv2+
Description : abrt is a tool to help users to detect defects in applications and
            : to create a bug report with all information needed by maintainer to fix
            : it. It uses plugin system to extend its functionality.
\end{verbatim}

Команда \textbf{yum info имя\_пакета} аналогична команде \textbf{rpm -q --info имя\_пакета}, но в качестве дополнительной информации предоставляет имя репозитория, из которого был установлен пакет RPM (см. в выводе строчку «From repo»)

\subsection{Работа с yumdb}
Чтобы получить альтернативную и полезную информацию о пакете, пользователь также может сделать запрос в базе данных yum с помощью такой команды:

\begin{verbatim}
 yumdb info имя_пакета
\end{verbatim} 

Эта команда предоставляет дополнительную информацию о пакете, включая контрольную сумму пакета (а также используемый алгоритм, например SHA-256), команду, с помощью которой был установлен пакет (при её наличии), а также причину, по которой пакет установлен в системе (где \textbf{user} означает, что пакет был установлен пользователем, а \textbf{dep} — пакет установлен в качестве зависимости к другому пакету).
⁠
\textbf{Запрос в yumdb информации о пакете yum}

Чтобы получить дополнительную информацию о пакете yum, введите:
\begin{verbatim}
 $ yumdb info yum
Loaded plugins: langpacks, product-id
yum-3.4.3-132.el7.noarch
     changed_by = 1000
     checksum_data = a9d0510e2ff0d04d04476c693c0313a11379053928efd29561f9a837b3d9eb02
     checksum_type = sha256
     command_line = upgrade
     from_repo = rhel-7-server-rpms
     from_repo_revision = 1449144806
     from_repo_timestamp = 1449144805
     installed_by = 4294967295
     origin_url = https://cdn.redhat.com/content/dist/rhel/server/7/7Server/x86_64/os/Packages/yum-3.4.3-132.el7.noarch.rpm
     reason = user
     releasever = 7Server
     var_uuid = 147a7d49-b60a-429f-8d8f-3edb6ce6f4a1
\end{verbatim} 

Подробности о команде \textbf{yumdb} см. на странице руководства yumdb(8).

\subsection{Установка пакетов}
Чтобы установить один пакет и все его неустановленные зависимости, введите следующую команду с правами пользователя root:
\begin{verbatim}
yum install имя_пакета
\end{verbatim} 
Также можно установить одновременно несколько пакетов, добавив их имена в качестве аргументов. Для этого введите с правами пользователя root: 
\begin{verbatim}
 yum install имя_пакета имя_пакета…
\end{verbatim} 
При установке пакетов в системе multilib, такой, как AMD64 или Intel 64, можно указать архитектуру пакета (если она доступна в подключенном репозитории), добавив к имени пакета .arch
\begin{verbatim}
 yum install имя_пакета.arch
\end{verbatim} 
⁠
\textbf{Установка пакетов в системе multilib}

Чтобы установить пакет \textbf{sqlite} для архитектуры i686, введите:
\begin{verbatim}
 # yum install sqlite.i686
\end{verbatim} 
Для быстрой установки нескольких пакетов с похожими именами можно использовать шаблоны выражений. Выполните с правами пользователя root: 
\begin{verbatim}
 yum install шаблон_выражения…
\end{verbatim} 
⁠
\textbf{Пример: установка всех модулей audacious}

Шаблоны выражений удобны, если нужно установить несколько пактов с похожими именами. Чтобы установить все модули \textbf{audacious}, используйте команду в таком виде:

\begin{verbatim}
 # yum install audacious-plugins-\*
\end{verbatim} 

В дополнение к именам пакетов и шаблонам выражений, команде yum install также можно передавать имена файлов. Если известно имя выполняемого файла пакета, но не само имя пакета, то команде yum install можно передать имя пути. Введите с правами пользователя root: 
\begin{verbatim}
 yum install /usr/sbin/named
\end{verbatim} 

Yum выполнит поиск по списку пакетов, найдёт пакет, который предоставляет файл /usr/sbin/named, если такой есть, и выведет запрос подтверждения установки пакета.

Как можно видеть в вышеприведённых примерах, команде  yum install не требуются чёткие аргументы. Она может обрабатывать различные форматы имён пакетов и шаблонов выражений, что облегчает пользователям установку. С другой стороны, на корректную обработку команды yum требуется время, особенно если было указано большое число пакетов. Для оптимизации поиска пакетов можно использовать следующие команды, явным образом указывающие, как именно необходимо обрабатывать аргументы:
\begin{verbatim}
yum install-n имя
yum install-na имя.архитектура
yum install-nevra имя-epoch:версия-релиз.архитектура
\end{verbatim} 


При использовании аргумента \textbf{install-n} команда yum воспринимает имя как точное имя пакета. Команда \textbf{install-na} указывает yum, что последующий аргумент содержит имя пакета и архитектуру, разделённые символом точки. С аргументом \textbf{install-nevra} команда yum ожидает аргумента в виде \textbf{имя-epoch:версия-релиз.архитектура}. Точно также, при поиске пакетов для удаления можно использовать \textbf{yum remove-n}, \textbf{yum remove-na} и \textbf{yum remove-nevra}.


\so{Внимание}
Если необходимо установить пакет с именованным бинарным файлов, но неизвестно, в какой каталог он устанавливается, bin/ или sbin/, используйте команду yum provides с шаблоном подстановки:
\begin{verbatim}
 # yum provides "*bin/named"
Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-
              : manager
32:bind-9.9.4-14.el7.x86_64 : The Berkeley Internet Name Domain (BIND) DNS
                            : (Domain Name System) server
Repo        : rhel-7-server-rpms
Matched from:
Filename    : /usr/sbin/named
\end{verbatim} 

\textbf{yum provides "*/имя\_файла"} — это удобный спрособ найти пакеты, содержащие имя\_файла

\subsection{Загрузка пакетов}
На определённом моменте установки пользователю выводится запрос о подтверждении установки со следующим сообщением:
\begin{verbatim}
 ...
Total size: 1.2 M
Is this ok [y/d/N]:    
...
\end{verbatim} 
При использовании с параметром \textbf{d}, команда yum только загружает пакеты без их установки. Эти пакеты можно установить позже, не используя подключение к интернет, с помощью команды \textbf{yum localinstall}, или же их можно сделать общими с помощью какого-либо другого устройства. Загруженные пакеты хранятся в одном из подкаталогов каталога cache, по умолчанию это ⁠/var/cache/yum/\$basearch/\$releasever/packages/. 

Загрузка выполняется в фоновом режиме, так что пользователь может одновременно использовать yum для параллельных задач.

\subsection{Удаление пакетов}
Yum предоставляет пользователю как средство установки пакетов, так и средство их удаления. Чтобы удалить конкретный пакет, а также пакеты, зависящие от этого пакета, выполните с правами пользователя root: 
\begin{verbatim}
 yum remove имя_пакета…
\end{verbatim} 
Также как и при установке нескольких пакетов, пользователь может удалить несколько пакетов, добавив несколько имён пакетов к команде.
⁠
\subsubsection{Удаление нескольких пакетов}
Чтобы удалить программу \textbf{totem}, введите в консоли:
\begin{verbatim}
# yum remove totem
\end{verbatim} 
Аналогично команде install, команда remove может принимать следующие аргументы:

\begin{itemize}
\item имена пакетов
\item шаблоны выражений
\item список файлов
\item поставщик пакетов
\end{itemize}


\so{Внимание}
Yum не может удалить пакет, не удалив также и пакеты, зависящие от него. Такие действия, которые может выполнить только пакетный менеджер RPM, не рекомендуются, и могут привести систему в нерабочее состояние, или же стать причиной некорректной работы или внезапных отказов в работе приложений.

\subsection{Работа с группами пакетов}
Группа пакетов — это набор пакетов, используемых для аналогичной цели, например, группа \textbf{System Tools} или \textbf{Sound and Video}. Установка групп пакетов получает набор зависимых пакетов, что значительно сокращает время установки. Команда \textit{yum groups} — это верхнеуровневая команда, включающая в себя все операции с группами пакетов в yum.

\subsubsection{Получение списка групп пакетов}
Параметр \textbf{summary} используется для просмотра количества установленных групп, доступных групп, доступных групп окружения, а также как установленные так и доступные к установке группы языков.:
\begin{verbatim}
yum groups summary
\end{verbatim} 
⁠
Примерный ввод команды yum groups summary

\begin{verbatim}
$ yum groups summary 
Loaded plugins: langpacks, product-id, subscription-manager
Available Environment Groups: 12
Installed Groups: 10
Available Groups: 12
\end{verbatim} 

Чтоб получить список всех групп пакетов из репозиториев yum, добавьте параметр \textbf{list}. Вывод можно отфильтровать по именам групп.
\begin{verbatim}
 yum group list glob_expression…
\end{verbatim} 


Этой команде можно передать несколько возможных аргументов, включая аргумент \textbf{hidden}, для получение списка групп, помеченных как невидимые для пользователя, а также \textbf{ids} —- для получения списка идентификаторов групп. Для получения списка обязательных и возможных пакетов, содержащихся в конкретной группе, используйте следующую команду:

\begin{verbatim}
 yum group info glob_expression…
\end{verbatim} 
⁠
Просмотр информации о группе пакетов LibreOffice: 
\begin{verbatim}
 $ yum group info LibreOffice
Loaded plugins: langpacks, product-id, subscription-manager

Group: LibreOffice
 Group-Id: libreoffice
 Description: LibreOffice Productivity Suite
 Mandatory Packages:
  =libreoffice-calc
   libreoffice-draw
  -libreoffice-emailmerge
   libreoffice-graphicfilter
  =libreoffice-impress
  =libreoffice-math
  =libreoffice-writer
  +libreoffice-xsltfilter
 Optional Packages:
   libreoffice-base
   libreoffice-pyuno
\end{verbatim} 


Как можно видеть в примере выше, пакет, включенные в группу пакетов, могут иметь различные статусы и помечены следующими символами:
\begin{itemize}
 \item " - " — пакет не установлен, и не будет установлен в составе группы пакетов
\item " + " — пакет не установлен, но будет установлен при следующем запуске команды \textbf{yum upgrade} или \textbf{yum group upgrade}.
\item " = " — пакет установлен и был установлен в составе группы пакетов
\item no symbol — пакет установлен, но он был установлен независимо от группы пакетов. Это означает, что команда \textbf{yum group remove} не удалит этот пакет
\end{itemize}

Эти различия случаются только, если значение параметра group\_command установлено на «objects», что является значением по умолчанию. Если пользователь не хочет, чтобы yum отслеживал, как именно пакет был установлен, в составе группы или индивидуально, что сделает статус пакетов "no symbol" эквивалентным статусу пакетов "=" .

Изменить вышеописанные статусы пактов можно с помощью команды \textbf{yum group mark}. Например, «yum group mark <пакеты>» помечает любые указанные установленные пакеты как пакеты в составе указанной группы. Чтобы избежать установки новых пакетов при обновлении группы, используйте команду \textbf{yum group mark blacklist}. Более подробно о возможностях \textbf{yum group mark} см. на странице руководства yum(8).

\so{Внимание}
Группу окружения можно идентифицировать с помощью префикса \@\^ , а группу пакетов можно пометить символом \@.  при использовании команд \textbf{yum group list}, \textbf{info}, \textbf{install} или \textbf{remove}, укажите «\@имя\_группы» чтобы конкретизировать имя группы, «\@\^имя\_группы» — чтобы конкретизировать группу окружения или же «имя\_группы» — чтобы включить оба варианта.

\subsubsection{Установка группы пакетов}
У каждой группы пакетов есть имя и идентификатор группы (groupid). Чтобы получить имена всех групп пакетов, а также их идентификаторов, показываемых в скобках, введите:
\begin{verbatim}
 yum group list ids
\end{verbatim}  
⁠
\paragraph{Нахождение имени и идентификатора группы пакетов}
Чтобы узнать имя или идентификатор группы, например, группы, имеющей отношение к графическому окружению KDE, введите:
\begin{verbatim}
 $ yum group list ids kde\*
Available environment groups:
   KDE Plasma Workspaces (kde-desktop-environment)
Done
\end{verbatim} 

Некоторые группы скрываются с помощью значений в параметрах настроенных репозиториев. На сервере, например, используйте командный параметр hidden для показа также и списка скрытых групп:
\begin{verbatim}
 $ yum group list hidden ids kde\*
Loaded plugins: product-id, subscription-manager
Available Groups:
   KDE (kde-desktop)
Done
\end{verbatim} 



Для установки группы пакетов можно передать полное имя группы команде \textbf{group install}, без аргумента \textbf{groupid}. Введите с правами пользователя root: 
\begin{verbatim}
 yum group install "group name"
\end{verbatim} 

Также можно выполнить установку, указав только \textbf{groupid}. Выполните с правами пользователя root: 
\begin{verbatim}
yum group install groupid
\end{verbatim} 

Команде install можно передать \textbf{groupid} или имя группы в кавычках, если перед ними поставить символ «@», который сообщает команде yum, что мы хотим выполнить установку группы пакетов. Введите с правами пользователя root: 
\begin{verbatim}
yum install @group\end{verbatim} 
Замените \textbf{group} на \textit{groupid} или на имя группы в кавычках. Так же логика применяется и к группам окружения:
\begin{verbatim}
yum install @^group
\end{verbatim} 
⁠
\textbf{Четыре эквивалентных способа установки группы KDE Desktop}

Как указывалось выше, для установки группы пакетов можно использовать четыре  разных способа с эквивалентным результатом. Установка группы KDE Desktop, например, будет выглядеть так:
\begin{verbatim}
# yum group install "KDE Desktop"
# yum group install kde-desktop
# yum install @"KDE Desktop"
# yum install @kde-desktop
\end{verbatim} 
⁠

\subsubsection{Удаление группы пакетов}
Для удаления группы пакетов используется синтаксис, аналогичный синтаксису установки, когда используется либо имя группы либо её идентификатор. Введите с правами пользователя root: 
\begin{verbatim}
yum group remove имя_группы
yum group remove groupid
\end{verbatim} 



Также команде remove можно передать \textbf{groupid} или имя группы в кавычках, если перед ними указать символ «@», что сообщает команде yum, что мы хотим выполнить удаление группы. Введите с правами пользователя root: 
\begin{verbatim}
yum remove @group
\end{verbatim} 

Замените group на groupid или имя группы в кавычках. Точно также можно заменить группу окружения:


\begin{verbatim}
yum remove @^group
\end{verbatim} 

\textbf{Четыре эквивалентных способа удаления группы KDE Desktop}

Как и при установке, для удаления группы пакетов существует четыре способа. Для группы KDE Desktop команды выглядят следующим образом:
\begin{verbatim}
# yum group remove "KDE Desktop"
# yum group remove kde-desktop
# yum remove @"KDE Desktop"
# yum remove @kde-desktop
\end{verbatim} 


\subsection{Работа с историей транзакций yum}
Команда \textbf{yum history} даёт возможность пользователю просмотреть информацию о выполненных командах yum, о датах и времени их выполнения, о числе затронутых пакетов, были ли эти транзакции успешными или они были прерваны, и была ли изменена база данных RPM в промежуток между трансакциями. Кроме того, с помощью этой команды можно повторить ил отменить некоторые транзакции. Все данные истории хранится в базе данных истории в каталоге /var/lib/yum/history/.

\subsubsection{Получение списка транзакций}
Чтобы получить список двадцати последних транзакций, запустите с правами пользователя root либо команду \textbf{yum history} без дополнительных аргументов, либо введите в консоли:
\begin{verbatim}
yum history list
\end{verbatim} 

Чтобы увидеть все транзакции, добавьте ключевое слово all:
\begin{verbatim}
yum history list all
\end{verbatim} 
Чтобы увидеть транзакции, выполненные в определённый промежуток времени, используйте команду в следующем виде:
\begin{verbatim}
yum history list start_id..end_id
\end{verbatim} 

Также можно просмотреть транзакции для конкретного пакета или пакетов. Для этого к команде добавляется имя пакета или шаблон выражения:
\begin{verbatim}
 yum history list шаблон_выражения…
\end{verbatim} 
⁠
\textbf{Вывод списка пяти последних транзакций}
В выводе команды \textbf{yum history list} недавние транзакции показываются в верхней части списка. Чтобы увидеть информацию о пяти самых старых транзакциях в базе данных истории, введите:
\begin{verbatim}
 # yum history list 1..5
\end{verbatim} 
\begin{verbatim}
 Loaded plugins: langpacks, product-id, subscription-manager
ID     | Login user               | Date and time    | Action(s)      | Altered
-------------------------------------------------------------------------------
     5 | User <user>              | 2013-07-29 15:33 | Install        |    1
     4 | User <user>              | 2013-07-21 15:10 | Install        |    1
     3 | User <user>              | 2013-07-16 15:27 | I, U           |   73
     2 | System <unset>           | 2013-07-16 15:19 | Update         |    1
     1 | System <unset>           | 2013-07-16 14:38 | Install        | 1106
history list
\end{verbatim} 


Все формы команды \textbf{yum history list} предоставляют вывод в виде таблицы, где каждая строка состоит из следующих столбцов:
\begin{itemize}
 \item ID — целое значение, обозначающее конкретную транзакцию
\item Login user — Имя пользователя, в сеансе работы которого была произведена транзакция. Эта информация как обычно предоставляется в виде «полное имя <имя\_пользователя>». для транзакций, произведённых не пользователями (например, автоматическое обновление системы) вместо этого используется System <unset>.
\item Date and time — дата и время начала транзакции
\item Action(s) — Список действий, которые были выполнены во время транзакции, согласно таблице «Возможные значения поля Action(s)» ниже.
\item Altered — Число пакетов, затронутых транзакцией, далее может указываться дополнительная информация, согласно таблице «Возможные значения поля Altered» ниже.
\end{itemize}

Возможные значения поля \textbf{Action(s)}
\begin{longtable}{  m{3cm}  m{3cm}    m{10cm}}  
 Действие & Сокращение & Описание\\\hline
Downgrade & D & минимум один пакет был понижен до более старой версии\\
Erase & E & минимум один пакет был удалён\\
Install & I & минимум один новый пакет был установлен\\
Obsoleting & O & минимум один пакет был помечен как устарелый\\
Reinstall & R & минимум один пакет был переустановлен\\
Update & U & как минимум один пакет был обновлён но свежей версии\\
\end{longtable}


Возможные значения поля \textbf{Altered}
\begin{longtable}{  m{4cm}  m{15cm}  }  
Символ & Описание\\\hline
< & Перед началом транзакции база данных rpmdb была изменена за пределами yum\\
> & После окончания транзакции база данных rpmdb была изменена за пределами yum\\
* & Транзакцию не удалось завершить\\
\# & Транзакция была завершена успешно, но yum вернул ненулевое значение на выходе\\
E & Транзакция была завершена успешно, но была выведена ошибка или предупреждение\\
P & Транзакция была завершена успешно, но в базе данных rpmdb уже существовала ошибка\\
s & Транзакция была завершена успешно, но был использован аргумент \textbf{--skip-broken}, и некоторые пакеты были пропущены\\
\end{longtable}

Чтобы синхронизировать содержимое базы данных rpmdb или yumdb любого уставленного на данный момент пакета с текущей используемой базой данных rpmdb или yumdb, введите следующее:
\begin{verbatim}
yum history sync
\end{verbatim} 
Чтобы просмотреть некоторую общую статистику о текущей используемой базе данных истории транзакций, используйте следующую команду:
\begin{verbatim}
yum history stats
\end{verbatim} 

\textbf{Примерный вывод статистики истории yum}

\begin{verbatim}
 # yum history stats
Loaded plugins: langpacks, product-id, subscription-manager 
File        : //var/lib/yum/history/history-2012-08-15.sqlite
Size        : 2,766,848
Transactions: 41
Begin time  : Wed Aug 15 16:18:25 2012
End time    : Wed Feb 27 14:52:30 2013
Counts      :
  NEVRAC :  2,204
  NEVRA  :  2,204
  NA     :  1,759
  NEVR   :  2,204
  rpm DB :  2,204
  yum DB :  2,204
history stats
\end{verbatim} 



yum также даёт возможность просмотреть сводку всех прошлых транзакций. Для этого введите с правами пользователя root: 
\begin{verbatim}
yum history summary\end{verbatim} 

Чтобы просмотреть все транзакции за указанный период, введите:
\begin{verbatim}
yum history summary start_id..end_id\end{verbatim} 

По аналогии с командой \textbf{yum history list}, также можно просмотреть историю транзакции одного конкретного пакета или пакетов, указав имя пакета или шаблон выражения:

\begin{verbatim}
yum history summary glob_expression…\end{verbatim} 
⁠
\textbf{Пример: сводка пяти последних транзакций}

\begin{verbatim}
# yum history summary 1..5
Loaded plugins: langpacks, product-id, subscription-manager
Login user                 | Time                | Action(s)        | Altered 
-------------------------------------------------------------------------------
Jaromir ... <jhradilek>    | Last day            | Install          |        1
Jaromir ... <jhradilek>    | Last week           | Install          |        1
Jaromir ... <jhradilek>    | Last 2 weeks        | I, U             |       73
System <unset>             | Last 2 weeks        | I, U             |     1107
history summary
\end{verbatim} 

Все формы команды \textbf{yum history summary} создают упрощенный табличный вывод, аналогичный выводу команды \textbf{yum history list}. Как показывалось выше, обе команды, \textbf{yum history list} и \textbf{yum history summary}, направлены на транзакции, и хотя они и дают возможность просмотреть транзакции для одного или нескольких указанных пакетов, в их выводе отсутствуют важные детали, такие, как версии пакетов. Чтобы получить список транзакций с точки зрения пакета, выполните с правами пользователя root:
\begin{verbatim}
yum history package-list glob_expression…
\end{verbatim} 
⁠
\textbf{Пример: отслеживание истории одного пакета}

Чтобы, например, отследить историю subscription-manager и связанных с ним пакетов, введите следующее в командной строке:
\begin{verbatim}
# yum history package-list subscription-manager\*
Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager
ID     | Action(s)      | Package
-------------------------------------------------------------------------------
     2 | Updated        | subscription-manager-1.13.22-1.el7.x86_64          EE
     2 | Update         |                      1.15.9-15.el7.x86_64          EE
     2 | Obsoleted      | subscription-manager-firstboot-1.13.22-1.el7.x86_64 EE
     2 | Updated        | subscription-manager-gui-1.13.22-1.el7.x86_64      EE
     2 | Update         |                          1.15.9-15.el7.x86_64      EE
     2 | Obsoleting     | subscription-manager-initial-setup-addon-1.15.9-15.el7.x86_64 EE
     1 | Install        | subscription-manager-1.13.22-1.el7.x86_64
     1 | Install        | subscription-manager-firstboot-1.13.22-1.el7.x86_64
     1 | Install        | subscription-manager-gui-1.13.22-1.el7.x86_64
history package-list
\end{verbatim} 


В этом примере во время начальной установки системы было установлено три пакета:\textbf{subscription-manager}, \textbf{subscription-manager-firstboot} и \textbf{subscription-manager-gui}. Во время третьей транзакции все эти пакетв были обнвлены с версии 1.10.11 до версии 1.10.17.


\subsection{Проверка транзакций}
Чтобы просмотреть сводку одной транзакции под учётной записью root, используйте команду \textbf{yum history summary} в следующем виде:
\begin{verbatim}
 yum history summary id
\end{verbatim} 
Здесь id означает идентификатор транзакции.

Чтобы проверить какую-то конкретную транзакцию или транзакции с большими подробностями, выполните с правами пользователя root: 
\begin{verbatim}
 yum history info id…
\end{verbatim} 
Аргумент \textbf{id} — опционален, и при его отсутствии yum автоматически использует самую последнюю транзакцию. Обратите внимание, что при указании более одной транзакции, также можно использовать диапазон:
\begin{verbatim}
yum history info start_id..end_id
\end{verbatim} 
⁠
\textbf{Пример вывода команды yum history info}


Ниже показан примерный вывод для двух транзакций, во время каждой из которых был установлен один новый пакет:
\begin{verbatim}
# yum history info 4..5
Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager
Transaction ID : 4..5
Begin time     : Mon Dec  7 16:51:07 2015
Begin rpmdb    : 1252:d2b62b7b5768e855723954852fd7e55f641fbad9
End time       :            17:18:49 2015 (27 minutes)
End rpmdb      : 1253:cf8449dc4c53fc0cbc0a4c48e496a6c50f3d43c5
User           : Maxim Svistunov <msvistun>
Return-Code    : Success
Command Line   : install tigervnc-server.x86_64
Command Line   : reinstall tigervnc-server
Transaction performed with:
    Installed     rpm-4.11.3-17.el7.x86_64                  @rhel-7-server-rpms
    Installed     subscription-manager-1.15.9-15.el7.x86_64 @rhel-7-server-rpms
    Installed     yum-3.4.3-132.el7.noarch                  @rhel-7-server-rpms
Packages Altered:
    Reinstall tigervnc-server-1.3.1-3.el7.x86_64 @rhel-7-server-rpms
history info
\end{verbatim} 


Также пользователь может просматривать дополнительную информацию, такую, как какие значения параметров конфигурации использовались во время транзакции, или из какого репозитория и почему были установлены конкретные пакеты. Чтобы определить, какой тип дополнительной информации доступен для конкретной транзакции, введите в консоль с правами пользователя root: 

\begin{verbatim}
yum history addon-info id\end{verbatim} 
По аналогии с командой \textbf{yum history info}, при отсутствии id, yum автоматически использует самую последнюю транзакцию. Ещё одним способом обратиться к самой последней транзакции является использование ключевого слова \textit{last}:
\begin{verbatim}
yum history addon-info last
\end{verbatim} 
⁠
\textbf{Пример вывода программы yum history addon-info}

Для четвёртой транзакции в истории команда \textbf{yum history addon-info} предоставляет следующий вывод:
\begin{verbatim}
 # yum history addon-info 4
Loaded plugins: langpacks, product-id, subscription-manager
Transaction ID: 4
Available additional history information:
  config-main
  config-repos
  saved_tx

history addon-info
\end{verbatim} 


В выводе команды yum history addon-info доступно три типа информации:

\begin{itemize}
\item config-main — глобальные параметры yum , которые использовались во время этой транзакции.
\item config-repos — параметры для  отдельных репозиториев yum
\item saved\_tx — данные, которые может использовать команда yum load-transaction |для воспроизведения транзакции на другой машине
\end{itemize}

Чтобы просмотреть выбранный тип дополнительной информации, введите с правами пользователя root: 
\begin{verbatim}
yum history addon-info id information
\end{verbatim} 

\subsection{Откат и повторение транзакций}
Кроме проверки истории транзакций, команда yum history предоставляет средства откатить или повторить выбранную транзакцию. Чтобы откатить транзакцию, ведите с правами пользователя root: 
\begin{verbatim}
yum history undo id
\end{verbatim} 

Чтобы повторить конкретную транзакцию, введите следующую команду с правами пользователя root: 
\begin{verbatim}
yum history redo id
\end{verbatim} 


Обратите внимание, что обе команды, как \textbf{yum history undo}, так и \textbf{yum history redo}, отменяют или повторяют только те шаги, которые были выполнены во время транзакции. Если во время транзакции был установлен новый пакет, то команда \textbf{yum history undo} его удалит, а если транзакция удалила пакет, то команда вновь его установит. Эта команда также будет пытаться вернуть предыдущую версию обновлённых пакетов, если эти более старые пакеты всё ещё доступны.

При управлении несколькими идентичными системами, yum также даёт возможность выполнить транзакцию на одной из них, сохранить подробности транзакции в файле, и после проверки повторить ту же самую транзакцию.  Также и на оставшихся системах. Чтобы сохранить детали транзакции в файле, введите следующую команду в консоли с правами пользователя root: 

\begin{verbatim}
yum -q history addon-info id saved_tx > file_name
\end{verbatim} 

Сразу после копирования файла на целевую систему, транзакцию можно повторить, выполнив следующую команду с правами пользователя root: 
\begin{verbatim}
yum load-transaction имя_файла\end{verbatim} 

Команду load-transaction можно настроить так, чтобы она игнорировала недостающие пакты или версию rpmdb. Подробности об этих параметрах см. на странице руководства yum.conf(5).

\subsection{Создание новой истории транзакций}
yum хранит историю транзакций в одном файле базы данных SQLite. Чтобы начать новую историю транзакций, выполните следующую команду с правами пользователя root: 

\begin{verbatim}
yum history new\end{verbatim} 

Это действие создаст новую, пустую  базу данных в каталоге /var/lib/yum/history/. Старая история транзакций будет сохранена, но доступ к ней будет отсутствовать, пока более новый файл базы данных будет присутствовать в каталоге.


\subsection{Настройка параметров yum и репозиториев yum}
Информация о параметрах yum и связанных с ним утилит располагается в файле /etc/yum.conf. В этом файле содержится один обязательный [main] раздел, в котором настраиваются глобальные параметры yum, а также могут содержаться один или более разделов [repository], в которых настраиваются параметры, имеющие отношение к репозиториям. Тем не менее, настраивать индивидуальные репозитории рекомендуется в новых или уже существующих файлах .repo в каталоге /etc/yum.repos.d/. Параметры, определённые в индивидуальных разделах [repository] файла /etc/yum.conf имеют приоритет над параметрами, присутствующими в разделе [main].


В данном разделе рассказывается о том, как:
\begin{itemize}
 \item Установить глобальные параметры yum с помощью редактирования раздела [main] файла конфигурации /etc/yum.conf;
\item Установить параметры индивидуальных репозиториев с помощью редактирования раздела [repository] в файле /etc/yum.conf и файлов .repo в каталоге /etc/yum.repos.d/;
\item Использовать  переменные yum в файле /etc/yum.conf и  файлах в каталоге /etc/yum.repos.d/, так, чтобы значения динамической версии обрабатывались корректно;
\item Добавлять, подключать и отключать репозитории yum в командной стороке; а также
\item Как настроить свой собственный пользовательский репозиторий yum.
\end{itemize}

\subsubsection{Параметры раздела [main]}
В конфигурационном файле /etc/yum.conf содержится только один раздел [main], и в то время как одни пары «ключ-значение» в этом разделе влияют на то, как действует yum, другие влияют на то, как yum обрабатывает репозитории. Под заголовком [main] в файле /etc/yum.conf можно добавить много дополнительных параметров.

Пример файла конфигурации /etc/yum.conf:
\begin{verbatim}
 [main]
cachedir=/var/cache/yum/$basearch/$releasever
keepcache=0
debuglevel=2
logfile=/var/log/yum.log
exactarch=1
obsoletes=1
gpgcheck=1
plugins=1
installonly_limit=3

[comments abridged]

# PUT YOUR REPOS HERE OR IN separate files named file.repo
# in /etc/yum.repos.d
\end{verbatim} 


Наиболее используемые параметры в разделе [main]:

\textbf{assumeyes=значение}\\
Параметр \textbf{assumeyes} определяет, будет ли yum выводить запрос о подтверждении критически важных действий. Замените «значение» одним из следующих:
\begin{itemize}
\item \textbf{0 (значение по умолчанию)} — yum выводит запрос о подтверждении выполняемых им критически важных действий
\item \textbf{1} — не выводить запрос о подтверждении критически важных действий. При установленном \textbf{assumeyes=1} yum ведёт себя аналогично консольным параметрам \textbf{-y} и \textbf{--assumeyes}.
\end{itemize}

\textbf{cachedir=каталог}\\
Используйте этот параметр для указания каталога, в котором yum хранит свой кеш и файлы базы данных. Замените «каталог» абсолютным путём до каталога. По умолчанию, каталогом кеша yum является /var/cache/yum/\$basearch/\$releasever/.

\textbf{debuglevel=значение}\\
Этот параметр определяет степень детализации отладочного вывода yum. Здесь «значение» — это целое число в диапазоне от 1 до 10. Более высокое значение для debuglevel означает более высокий уровень детализации. Значение \textbf{debuglevel=2} выставляется по умолчанию, а \textbf{debuglevel=0} отключает отладочный вывод.

\textbf{exactarch=значение}\\
Этот параметр заставляет yum принимать во внимание точное значение архитектуры при обновлении уже установленных пакетов. Замените «значение» на одно из следующих:
\begin{itemize}
\item \textbf{0} — при обновлении пакетов не принимать во внимание точное значение архитектуры\\
\item \textbf{1 (по умолчанию)} — учитывать точное значение архитектуры при обновлении пакетов. С этим параметром yum не станет устанавливать 32-битный пакет для обновления уже установленного 64-битного пакета
\end{itemize}

\textbf{exclude=имя\_пакета [ещё\_имена\_пакетов]}\\
Параметр \textbf{exclude} даёт возможность исключать пакеты по ключевому слову во время установки или обновления системы. Указать множество пакетов для исключения можно с помощью заключения в кавычки списка пакетов, разделённых пробелами. Также можно использовать шаблоны выражений с символами подстановки (например, * и ?).

\textbf{gpgcheck=значение}\\
Параметр gpgcheck используется для указания, должен ли yum выполнять проверку подписи GPG в пакетах. Замените «значение» на одно из следующих:
\begin{itemize}
\item 0 —Отключить проверку подписи для пакетов во всех репозиториях, включая локальную установку пакетов.
\item 1 (по умолчанию) —Включить проверку подписи GPG для всех пакетов во всех репозиториях, включая локальную установку пакетов. При включённом gpgcheck проверяются все подписи пакетов.
\end{itemize}

Если этот параметр указан в разделе [main] файла /etc/yum.conf, то он установит обязательность проверки GPG для всех репозиториев. Тем не менее, вместо этого можно установить gpgcheck=значение для индивидуальных репозиториев; то есть таким образом можно включить проверку GPG для одного репозиториях, а для другого -- отключить её. Установка \textit{gpgcheck=значение} для отдельного репозитория в соответствующем файле .repo имеет приоритет над значениями по умолчанию, если они присутствуют в файле /etc/yum.conf.

\textbf{group\_command=значение}\\
Используйте параметр group\_command для определения того, как команды \textbf{yum group install}, \textbf{yum group upgrade} и \textbf{yum group remove} обрабатывают группу пакетов. Замените «значение» на одно из следующих:

\begin{itemize}
 \item simple — Установка всех пакетов, входящих в группу. Обновление только ранее установленных пакетов, но не устанавливать п пакеты, добавленные в группу за это время.
\item compat — Аналогично simple, но кроме того yum upgrade также поставит пакеты, добавленные в группу с момента предыдущего обновления.
\item objects — (по умолчанию.) С этим параметром yum отслеживает ранее установленные группы и делает различия между пакетами, устанавливаемые в составе группы и пакетами, установленными отдельно. См. пример «Просмотр информации о группе пакетов LibreOffice»
\end{itemize}

\textbf{group\_package\_types=тип\_пакета [ещё\_типы\_пакетов]}\\
Здесь можно указать, какие типы пакетов (по выбору, по умолчанию или обязательные) устанавливается при вызове команды \textbf{yum group install}. Типы по умолчанию и обязательные выбираются по умолчанию. 

\textbf{history\_record=значение}\\
Этот параметр указывает yum записывать историю транзакций. Замените «значение» на одно из следующих:
\begin{itemize}
 \item \textbf{0} — yum не должен записывать историю транзакций
\item \textbf{1 (по умолчанию)} — yum должен записывать историю транзакций. Эта операция требует некоторого места на диске и некоторого дополнительного времени во время проведения транзакций, но представляет большой объём информации о проведённых операциях, которую можно просмотреть с помощью команды \textit{yum history}. Значение \textbf{history\_record=1} является значением по умолчанию. Подробности о команде yum history см. в разделе «работа с историей транзакций».
\end{itemize}

\so{Внимание}
Для обнаружения изменений, внесённых в базу данных rpmdb вне предела действия yum, используются записи истории транзакций. В этом случае yum показывает предупреждение и выполняет автоматический поиск возможных проблем, возникших из-за изменений в rpmdb. При отключенном параметре \textit{history\_record} yum не имеет возможности определить такие изменения и автоматическая проверка не выполняется.

\textbf{installonlypkgs=список пакетов, разделённых пробелами}\\
Здесь можно указать список пакетов, разделённых пробелами, которые yum может установить, но никогда не будет обновлять. Список пакетов, к которые по умолчанию можно только установить, см. на странице руководства yum.conf(5).

Если в файл /etc/yum.conf добавлена директива \textbf{installonlypkgs}, необходимо убедиться, что здесь указаны все пакеты, предназначенные только для установки, включая любые из  пакетов, перечисленных в разделе \textit{installonlypkgs} руководства yum.conf(5). Пакеты ядер, в частности, всегда должны быть указаны в installonlypkgs (по умолчанию они указаны), а значение параметра \textbf{installonly\_limit} всегда должно быть больше 2, чтобы запасное ядро всегда было доступно в случае сбоев в загрузке ядра по умолчанию.


\textbf{⁠installonly\_limit=значение}\\
Этот параметр указывает, сколько именно пакетов, перечисленных в директиве installonlypkgs, можно установить одновременно. Замените «значение» целым числом, представляющим максимальное число версий, которое может быть установлено одновременно для каждого отдельного пакета, указанного в installonlypkgs. Значение по умолчанию для директивы installonlypkgs включает в себя несколько разных пакетов ядер, поэтому при изменении значения installonly\_limit учитывайте, что оно также влияет на число установленных версий любого отдельного пакета ядра. Значение по умолчанию, указанное в /etc/yum.conf — installonly\_limit=3, и крайне не рекомендуется уменьшать это значение, особенно ниже 2.


\textbf{keepcache=значение}\\
Параметр keepcache определяет, должен ли yum хранить кеш заголовков и пакетов после успешной установки. Здесь значение может быть одним из:
\begin{itemize}
 \item 0 (по умолчанию) — не оставлять кеш заголовков и пакетов после успешной установки
\item 1 — оставлять кеш после успешной установки.
\end{itemize}

\textbf{logfile=имя\_файла}\\
Чтобы указать место для сбора сообщений журнала, замените \textit{имя\_файла} абсолютным путём до файла, в который yum должен записывать сообщения своего журнала. По умолчанию это /var/log/yum.log.

\textbf{max\_connenctions=число}\\
Здесь «число» означает максимальное число одновременных подключений, по умолчанию — \textbf{5}.

\textbf{multilib\_policy=значение}\\
Параметр multilib\_policy настраивает параметры установки, если для пакет поддерживает несколько версий архитектуры. Здесь «значение» может означать:

\begin{itemize}
 \item \textbf{best} — Установить лучший вариант архитектуры для данной системы. Если, например, устанвоить multilib\_policy=best на системе AMD64, то yum будет устанавливать 64-битные версии всех пакетов.
\item \textbf{all} — Всегда устанавливать все доступные варианты архитектур для каждого пакета. Если, например, в системе AMD64 указать \textbf{all} для параметра \textbf{multilib\_policy}, то yum установит как версию i686, так и AMD64, в случае, если они обе доступны.
\end{itemize}

\textbf{obsoletes=значение}\\
Параметр obsoletes включает логику обработки устаревших компонентов во время обновления. Если в файле spec одного пакета указано, что он делает другой пакет устаревшим, то этот другой пакет будет заменён первым, при установке первого пакета. Obsoletes объявляются, например, при переименовании пакета. Замените «значение» одним из следующих:

\begin{itemize}
\item 0 — Отключить логику обработки устаревших компонентов во время выполнения обновления.
\item 1 (по умолчанию) — Включает логику обработки устаревших компонентов во время выполнения обновления.
\end{itemize}

\textbf{plugins=значение}\\
Это глобальный переключатель для включения или отключения модулей yum, «значение» может быть одним из:
\begin{itemize}
 \item 0 — отключить все модули yum глобально
 \item 
 \end{itemize}
 
\so{Важно}
Глобальное отключение модулей не рекомендуется, так как некоторые из модулей yum предоставляют важные службы yum. Эта возможность предоставляется в виде вспомогательной функции, и обычно рекомендуется к применению только при диагностировании потенциальных проблем с yum.


\textbf{reposdir=каталог}\\
Здесь «каталог» — это абсолютный путь до каталога, содержащего файлы .repo. Все файлы .repo содержат информацию о репозиториях (аналогично разделам [repository] файла /etc/yum.conf). Всю информацию о репозиториях для создания главного списка репозиториев, использующихся при транзакциях, yum собирает из файлов .repo и раздела [repository] файла /etc/yum.conf. Если параметр reposdir не настроен, yum использует каталог по умолчанию /etc/yum.repos.d/.


\textbf{retries=значение}\\
Этот параметр указывает число попыток получения файла перед тем, как yum вернёт ошибку. Значение — целый 0 или выше. Установка значения 0 заставит yum повторять попытки бесконечно. Значение по умолчанию — 10.

Полный список доступных параметров [main] см. в разделе [main] OPTIONS ман-странички yum.conf(5).


\subsubsection{Установка параметров [repository]}
Раздел [repository], где repository -- это уникальный идентификатор репозитория, например, my\_personal\_repo (пробелы не допускаются), даёт возможность настроить персональные репозитории. Для избежания конфликтов, пользовательские репозитории не должны содержать в названиях имена, используемые в названиях репозиториев ROSA. Ниже даётся минимальный пример раздела 
[repository]:

\begin{verbatim}
[repository]
name=repository_name
baseurl=repository_url
\end{verbatim} 



Каждый раздел [repository] должен содержать следующие директивы:

\textbf{name=имя\_репозитория}

Здесь имя\_репозитория — это строка в удобочитаемом виде, описывающая репозиторий.

\textbf{baseurl=url\_репозитория}\\
Замените \textit{url\_репозитория} адресом URL до каталога, в котором хранится каталог repodata репозитория.
Если репозиторий доступен по HTTP, используйте: 
\begin{verbatim}
http://path/to/repo
\end{verbatim} 
Если репозиторий доступен по FTP, используйте:
\begin{verbatim}
 ftp://path/to/repo
\end{verbatim} 

Если это локальный репозиторий, используйте:
\begin{verbatim}
 file:///path/to/local/repo
\end{verbatim} 

Если для какого-то сетевого репозитория требуется базовая аутентификация HTTP, можно указать имя пользователя и пароль перед адресом URL в виде «имя\_пользователя:пароль@ссылка». Если, например, репозиторий по адресу http://www.example.com/repo/ требует имя пользователя «user», и пароль «password», то baseurl можно указать в виде:  http://user:password@www.example.com/repo/.

Обычно этот URL является ссылкой HTTP, например:
\begin{verbatim}
baseurl=http://path/to/repo/releases/$releasever/server/$basearch/os/
\end{verbatim} 
Обратите внимание, что в URL yum всегда разворачивает переменные \$releasever, \$arch и \$basearch 

Ещё полезные директивы [repository]:

\textbf{enabled=значение}

Это простой способ указать yum игнорировать или использовать конкретный репозиторий, значение может быть одним из:

\begin{itemize}
 \item 0 — Не включать этот репозиторий в источники пакетов при выполнении обновлений и установок. Это простой способ быстро подключить или отключить репозитории, что бывает удобно, когда требуется одинарный пакет из такого репозитория, который не нужен при обновлениях или других установках пакетов.
\item 1 — включить этот репозиторий в источники пакетов.
\end{itemize}

Включить или отключить репозитории также можно, передав yum параметр \textbf{--enablerepo=repo\_name} или \textbf{--disablerepo=repo\_name}, а также в окне <Добавить/Удалить программы> PackageKit.

\textbf{async=значение}\\
Управляет параллельной загрузкой пакетов из репозиториев. Здесь «значение» может быть одним из:

\begin{itemize}
 \item auto (по умолчанию) — При возможности, параллельная загрузка используется, то есть yum автоматически отключает эту возможность для репозиториев, созданных модулями, для избежания сбоев.
\item on — для репозитория включена параллельная загрузка.
\item off — параллельная загрузка для репозитория отключена.
\end{itemize}


Для раздела [repository] существует ещё множество параметров, некоторые из низ аналогичны по форме и действию некоторым параметрам для [main]. Полный их список см. в разделе [repository] OPTIONS страницы руководства yum.conf(5).


\subsubsection{Просмотр текущей конфигурации yum}
Чтобы просмотреть текущее значение глобальных параметров yum (то есть параметров, указанных в разделе [main] файла /etc/yum.conf) выполните команду \textbf{yum-config-manager} без  параметров:
\begin{verbatim}
 yum-config-manager
\end{verbatim} 

Чтобы просмотреть список различных разделов с параметрами, используйте команду в следующем виде:

\begin{verbatim}
yum-config-manager раздел…
\end{verbatim} 

Также можно использовать шаблон выражения для показа параметров во всех совпадающих разделах:
\begin{verbatim}
yum-config-manager шаблон_выражения…
\end{verbatim} 
⁠
Просмотр параметров раздела main
Чтобы получить список параметров и их соответствующих значений для раздела main, введите в консоли следующее:
\begin{verbatim}
$ yum-config-manager main \*
Loaded plugins: langpacks, product-id, subscription-manager
================================== main ===================================
[main]
alwaysprompt = True
assumeyes = False
bandwith = 0
bugtracker_url = https://bugzilla.redhat.com/enter_bug.cgi?product=Red%20Hat%20Enterprise%20Linux%206&component=yum
cache = 0
[output truncated]
\end{verbatim}


\subsection{Добавление, подключение и отключение репозитория yum}


\subsubsection{Добавление репозитория yum}

Для определения нового репозитория, можно добавить раздел [repository] либо в файл /etc/yum.conf либо в файл .repo в каталоге /etc/yum.repos.d/. Yum читает все файлы с расширением .repo в этом каталоге, и рекомендуется настраивать репозитории здесь, а не в /etc/yum.conf.

Репозитории yum обычно предоставляют свой собственный файл  .repo. Чтобы добавить такой репозиторий в свою систему и подключить его, выполните следующую команду с правами пользователя root: 
\begin{verbatim}
yum-config-manager --add-repo url_репозитория
\end{verbatim} 

…где \textit{url\_репозитория} — это ссылка на файл .repo.


\subsubsection{Добавление example.repo}
Чтобы добавить репозиторий, расположенный по адресу http://www.example.com/example.repo, введите в консоли следующее:
\begin{verbatim}
# yum-config-manager --add-repo http://www.example.com/example.repo
Loaded plugins: langpacks, product-id, subscription-manager
adding repo from: http://www.example.com/example.repo
grabbing file http://www.example.com/example.repo to /etc/yum.repos.d/example.repo
example.repo                                             |  413 B     00:00
repo saved to /etc/yum.repos.d/example.repo
\end{verbatim} 



\subsubsection{Включение репозитория yum}
Чтобы включить конкретный репозиторий или репозитории, введите в консоли с правами пользователя root: 
\begin{verbatim}
yum-config-manager --enable репозиторий…
\end{verbatim} 

…где репозиторий — это уникальный идентификатор репозитория (используйте команду \textbf{yum repolist all} для получения списка доступных идентификаторов репозиториев). Также для включения всех совпадающих репозиториев можно использовать шаблон выражения:
\begin{verbatim}
yum-config-manager --enable шаблон_выражения…
\end{verbatim} 
⁠
Включение репозиториев, указанных в пользовательских разделах файла /etc/yum.conf

Чтобы включить репозитории из разделов [example], [example-debuginfo] и [example-source], введите:
\begin{verbatim}
# yum-config-manager --enable example\*
Loaded plugins: langpacks, product-id, subscription-manager
============================== repo: example ==============================
[example]
bandwidth = 0
base_persistdir = /var/lib/yum/repos/x86_64/7Server
baseurl = http://www.example.com/repo/7Server/x86_64/
cache = 0
cachedir = /var/cache/yum/x86_64/7Server/example
[output truncated]
\end{verbatim} 
⁠

\subsubsection{Включение всех репозиториев}
Чтобы включить все репозитории, как указанные в файле /etc/yum.conf, так и указанные в файле /etc/yum.repos.d/, введите:
\begin{verbatim}
# yum-config-manager --enable \*
Loaded plugins: langpacks, product-id, subscription-manager
============================== repo: example ==============================
[example]
bandwidth = 0
base_persistdir = /var/lib/yum/repos/x86_64/7Server
baseurl = http://www.example.com/repo/7Server/x86_64/
cache = 0
cachedir = /var/cache/yum/x86_64/7Server/example
[вывод обрезан]
\end{verbatim} 

При успешном результате команда \textbf{yum-config-manager --enable} покажет текущую конфигурацию репозиториев.


\subsubsection{Отключение репозитория yum}
Чтобы отключить репозиторий yum, введите с правами пользователя root: 
\begin{verbatim}
yum-config-manager --disable репозиторий…
\end{verbatim} 
…где «репозиторий» — уникальный идентификатор репозитория (используйте команду yum repolist all для получения списка доступных идентификаторов репозиториев). Как и для команды yum-config-manager --enable, для отключения всех совпадающих репозиториев можно использовать шаблон выражения:
\begin{verbatim}
yum-config-manager --disable шаблон_выражения…
\end{verbatim} 

⁠
\subsubsection{Отключение всех репозиториев}
Чтобы отключить все репозитории, как указанные в файле /etc/yum.conf, так и указанные в файле /etc/yum.repos.d/, введите:
\begin{verbatim}
 # yum-config-manager --disable \*
Loaded plugins: langpacks, product-id, subscription-manager
============================== repo: example ==============================
[example]
bandwidth = 0
base_persistdir = /var/lib/yum/repos/x86_64/7Server
baseurl = http://www.example.com/repo/7Server/x86_64/
cache = 0
cachedir = /var/cache/yum/x86_64/7Server/example
[вывод обрезан]
\end{verbatim} 

При успешном результате команда \textbf{yum-config-manager --enable} покажет текущую конфигурацию репозиториев. 


\subsubsection{Создание репозитория yum}
Чтобы создать репозиторий yum, выполните следующие шаги:
\begin{itemize}
 \item Установите пакет createrepo. Для этого введите в консоли с правами пользователя root: 
\begin{verbatim}
yum install createrepo
\end{verbatim} 
\item Скопируйте все пакеты, которые должны быть в репозитории, в один каталог, например /mnt/local\_repo/.
\item Перейдите в этот каталог и выполните следующую команду:
\begin{verbatim}
createrepo --database /mnt/local_repo
\end{verbatim} 
\end{itemize}


Это действие создаст необходимые метаданные для созданного репозитория yum, а также базу данных sqlite для ускорения выполнения операций yum.

Локальные источники информации о yum:

\begin{longtable}{  m{4cm}  m{15cm}  }  
yum(8) & Ман-страничка для консольной утилиты yum предоставляет полный список поддерживаемых параметров и команд\\
yumdb(8) & Ман-страничка для консольной утилиты yumdb описывает использование этой утилиты для составления запросов в базу данных yum, и, при необходимости, изменение базы данных yum\\
yum.conf(5) & Ман-страничка yum.conf описывает доступные параметры yum\\
yum-utils(1) & Ман-страничка yum-utils даёт список и короткое описание дополнительных утилит для работы с параметрами yum, управления репозиториями и работе с базой данных yum.\\
\end{longtable}

\section{Краткий обзор ⁠systemd}
\textbf{systemd} — менеджер системы и служб для Linux, совместимый со скриптами инициализации SysV и LSB. systemd обеспечивает возможности агрессивной параллелизации, использует сокеты и активацию D-Bus для запускаемых служб, предлагает запуск демонов по необходимости, отслеживает процессы при помощи контрольных групп Linux, поддерживает мгновенные снимки и восстановление состояния системы, монтирование и точки монтирования, а также внедряет основанную на зависимостях логику контроля процессов сложных транзакций.


\subsection{Основы использования systemctl}
Главная команда для отслеживания и контроля состояния systemd — команда \textbf{systemctl}. Некоторые из вариантов ее использования связаны с изучением состояния системы и управлением системой и службами. Обратитесь к странице руководства systemctl(1) для получения более детальной информации.

\so{Совет:}
Использовать все приведенные ниже команды systemctl можно с ключом \textbf{-H пользователь@хост} для того, чтобы контролировать systemd на удаленной машине. В этом случае для соединения с удаленным процессом systemd будет использоваться SSH


\subsubsection{Анализ состояния системы}
\paragraph{Список запущенных юнитов:}

\begin{verbatim}
$ systemctl
\end{verbatim} 

или:

\begin{verbatim}
$ systemctl list-units
\end{verbatim} 

Список неудач, - список юнитов, попытка запуска которых не удалась:

\begin{verbatim}
$ systemctl --failed
\end{verbatim} 

Доступные файлы юнитов можно посмотреть в директориях /usr/lib/systemd/system/ и /etc/systemd/system/ (второй каталог имеет приоритет). Просмотреть список установленных файлов юнитов можно с помощью команды:

\begin{verbatim}
$ systemctl list-unit-files
\end{verbatim} 

\paragraph{Использование юнитов}
Юнитами могут быть, например, службы (.service), точки монтирования (.mount), устройства (.device) или сокеты (.socket).

При использовании systemctl обычно всегда необходимо указывать полное имя файла юнита, включая суффикс, например, sshd.socket. Однако, есть несколько сокращений для указания юнита в следующих командах systemctl:

\begin{itemize}
 \item Ели не был указан суффикс, systemctl предполагает, что это .service. Например, netctl и netctl.service будут трактоваться одинаково
\item Точки монтирования будут автоматически преобразованы в соответствующий юнит .mount. Например, указание /home равнозначно home.mount
\item Так же, как и точки монтирования, имена устройств автоматически преобразуются в соответствующий юнит .device, поэтому указание /dev/sda2 полностью соответствует юниту dev-sda2.device
\end{itemize}

Для получения дополнительной информации смотрите страницу справочного руководства systemd.unit(5).

\so{Примечание:} В некоторых именах юнитов содержится знак @ (например, \textbf{имя@строка.service}). Это означает, что они являются экземплярами юнита-шаблона, в имени которого нет части строки (например, \textbf{имя@.service}). Часть строки называется \textit{идентификатором экземпляра} и является аргументом, передаваемым юниту-шаблону при вызове команды systemctl: в файле юнита он заменит указание (specifier) \%i.

Для большей точности работы systemd будет сперва искать юнит по полному имени файла \textbf{имя@строка.суффикс}, и лишь затем пытаться использовать экземпляр юнита-шаблона \textbf{имя@.суффикс}, даже несмотря на то, что подобные "конфликты" довольно редки, так как большинство файлов юнитов, содержащих знак @, подразумевают использование шаблонов. Также помните, что если вызвать юнит-шаблон без идентификатора экземпляра, ничего не получится, поскольку в этом случае не будет возможности передать указание \%i

\so{Совет:}
Большинство указанных ниже команд также работают, если указать несколько юнитов. Для получения дополнительной информации смотрите страницу справочного руководства systemctl(1)

Начиная с версии systemd 220, переключатель \textbf{--now} может быть использован в сочетании с \textbf{enable}, \textbf{disable} и \textbf{mask} чтобы соответственно запустить или остановить все юниты сразу.


Незамедлительно запустить юнит:

\begin{verbatim}
# systemctl start юнит
\end{verbatim} 
Незамедлительно остановить юнит:

\begin{verbatim}
# systemctl stop юнит
\end{verbatim} 
Перезапустить юнит:

\begin{verbatim}
 # systemctl restart юнит
\end{verbatim} 

Запросить у юнита перезагрузку его настроек:

\begin{verbatim}
 # systemctl reload юнит
\end{verbatim} 

Показать статус юнита, а также запущен ли он, или нет:

\begin{verbatim}
 $ systemctl status юнит
\end{verbatim} 
Проверить, включен ли юнит в автозапуск при загрузке системы:

\begin{verbatim}
 $ systemctl is-enabled юнит
\end{verbatim} 

Включить юнит в автозапуск при загрузке системы:

\begin{verbatim}
 # systemctl enable юнит
\end{verbatim} 
Убрать юнит из автозапуска при загрузке системы:

\begin{verbatim}
 # systemctl disable юнит
\end{verbatim} 

Маскировать юнит, чтобы сделать невозможным его запуск:

\begin{verbatim}
 # systemctl mask юнит
\end{verbatim}  

Снять маску юнита:

\begin{verbatim}
 # systemctl unmask юнит
\end{verbatim}

Показать страницу справочного руководства, связанного с юнитом (необходима поддержка этой функции в указанном файле юнита):

\begin{verbatim}
 $ systemctl help юнит
\end{verbatim} 

Перезагрузить systemd для поиска новых или измененных юнитов:

\begin{verbatim}
 # systemctl daemon-reload
\end{verbatim} 


\subsubsection{Управление питанием}
Для управления питанием от имени непривилегированного пользователя необходим polkit. Если вы находитесь в локальной пользовательской сессии systemd-logind, и нет других активных сессий, приведенные ниже команды сработают и без привилегий суперпользователя. В противном случае (например, вследствие того, что другой пользователь вошел в систему в tty), systemd автоматически запросит у вас пароль суперпользователя.

Завершить работу и перезагрузить систему:
\begin{verbatim}
 $ systemctl reboot
\end{verbatim} 

Завершить работу и выключить компьютер (с отключением питания):

\begin{verbatim}
 $ systemctl poweroff
\end{verbatim} 
Перевести систему в ждущий режим:

\begin{verbatim}
 $ systemctl suspend
\end{verbatim} 
Перевести систему в спящий режим:

\begin{verbatim}
 $ systemctl hibernate
\end{verbatim} 
Перевести систему в режим гибридного сна (или suspend-to-both):

\begin{verbatim}
 $ systemctl hybrid-sleep
\end{verbatim} 

\subsection{Написание файлов юнитов}
Синтаксис файлов юнитов systemd вдохновлен файлами .desktop XDG Desktop Entry Specification, а они, в свою очередь - файлами .ini Microsoft Windows. Файлы юнитов загружаются из двух мест. Вот они по приоритету от низшего к высшему:
\begin{itemize}
 \item /usr/lib/systemd/system/: юниты, предоставляемые пакетами при их установке
 \item /etc/systemd/system/: юниты, устанавливаемые системным администратором
 \end{itemize}
 
\so{Примечание:} При запуске systemd в пользовательском режиме используются совершенно другие пути загрузки.

В качестве примера, посмотрите установленные вашими пакетами юниты, а также секцию примеров из systemd.service(5).

\so{Совет:} Как и обычно, вы можете добавлять комментарии, предваряемые символом \#, но только на новых строках. Не используйте комментарии в конце строки, после параметров systemd, иначе юнит не будет запущен


\subsubsection{Обработка зависимостей}
В случае использования systemd зависимости могут быть указаны правильным построением файлов юнитов. Наиболее частый случай -- юниту A требуется, чтобы юнит B был запущен перед тем, как запустится сам юнит A. В этом случае добавьте строки \textbf{Requires=B} и \textbf{After=B} в секцию [Unit] файла службы A. Если подобная зависимость не является обязательной, взамен указанных выше добавьте, соответственно, строки \textbf{Wants=B} и \textbf{After=B}. Обратите внимание, что \textbf{Wants=} и \textbf{Requires=} не подразумевают \textbf{After=}, что означает, что если After= не определено, два юнита будут запущены параллельно друг другу.

Обычно зависимости указываются в файлах служб, а не в целевых юнитах. Например, network.target потребуется любой службе, которая связана с настройкой ваших сетевых интерфейсов, поэтому в любом случае определите загрузку вашего пользовательского юнита после запуска network.target.

\subsubsection{Типы служб}
Существует несколько различных типов запуска служб, которые надо иметь в виду при написании пользовательского файла службы. Тип определяется параметром \textbf{Type=} в секции [Service]:
\begin{itemize}
 \item \textbf{Type=simple} (по умолчанию): systemd предполагает, что служба будет запущена незамедлительно. Процесс при этом не должен разветвляться. Не используйте этот тип, если другие службы зависят от очередности при запуске данной службы. Исключение - активация сокета
\item \textbf{Type=forking}: systemd предполагает, что служба запускается однократно и процесс разветвляется с завершением родительского процесса. Используйте данный тип для запуска классических демонов за исключением тех случаев, когда, как вам известно, в таком поведении процесса нет необходимости. Следует также определить PIDFile=, чтобы systemd могла отслеживать основной процесс
\item \textbf{Type=oneshot}: полезен для скриптов, которые выполняют одно задание и завершаются. Вам может понадобиться также установить параметр RemainAfterExit=yes, чтобы systemd по-прежнему считала процесс активным, даже после его завершения
\item \textbf{Type=notify}: идентичен параметру Type=simple, но с той оговоркой, что демон пошлет systemd сигнал о своей готовности. Эталонная реализация данного уведомления представлена в libsystemd-daemon.so
\item \textbf{Type=dbus}: сервис считается находящимся в состоянии готовности, когда определенное BusName появляется в системной шине DBus
\item \textbf{Type=idle}: systemd задержит исполнение бинарного файла службы до тех пор, пока не будут распределены все задачи. Кроме того, поведение очень похоже на Type=simple.
\end{itemize}

Смотрите справочную страницу руководства systemd.service(5) для более детального пояснения значений Type.


\subsubsection{Редактирование файлов юнитов, предоставленных пакетами}
Есть два способа редактирования файлов юнита, предоставленного пакетом: заменить весь блок файла на новый или создать фрагмент кода, который применяется в верхней части существующего блока файла. В обоих методах, чтобы применить изменения, нужно перезагрузить юнит. Это может быть сделано либо путем редактирования блока с помощью systemctl edit (которая автоматически загружает модуль) либо при перезагрузке всех юнитов:
\begin{verbatim}
 # systemctl daemon-reload
\end{verbatim} 

\so{Совет:}
Вы можете использовать systemd-delta, чтобы увидеть, какие файлы юнитов были переопределены и что конкретно было изменено. Для обслуживания системы в целом важно регулярно проверять предоставляемые файлы юнитов на полученные обновления.

Используйте \textbf{systemctl cat юнит} чтобы посмотреть содержимое файла юнита и все Drop-in snippets кода.

Подсветку синтаксиса для файлов юнитов systemd в редакторе Vim можно включить, установив пакет vim-systemd из официальных репозиториев.

\subsubsection{Замена файлов юнита}
Чтобы заменить файл юнита /usr/lib/systemd/system/юнит, создайте файл /etc/systemd/system/юнит и перезапустите юнит для обновления символьных ссылок:

\begin{verbatim}
# systemctl reenable юнит
\end{verbatim} 
В качестве альтернативы, можно выполнить:

\begin{verbatim}
# systemctl edit --full юнит
\end{verbatim} 
Эта команда откроет /etc/systemd/system/юнит в вашем текстовом редакторе (копирует установленную версию, если она еще не существует) и автоматически загружает её, когда вы закончите редактирование.

\subsection{Цели}
systemd использует цели (англ. target), которые выполняют ту же задачу, что и уровни запуска (англ. runlevel), но действуют немного по-другому. Каждая цель поименована (т.е. имеет собственное имя, а не номер) и, как предполагается, предназначена для конкретных задач; возможно иметь в одно и то же время активными несколько таких целей. Некоторые цели реализованы так, что наследуют все службы других целей, добавляя к ним свои. В systemd имеются также цели, которые имитируют общие уровни запуска SystemVinit, поэтому вы можете переключаться между целевыми юнитами, используя привычную команду telinit RUNLEVEL.

\subsubsection{Получение информации о текущих целях}
При использовании systemd для этого предназначена следующая команда (заменяющая runlevel):

\begin{verbatim}
$ systemctl list-units --type=target
\end{verbatim} 

\subsubsection{Создание пользовательской цели}
Уровни запуска, по которым расписаны конкретные задачи - 0, 1, 3, 5 и 6 - имеют соответствие 1:1 с конкретными целями systemd. К сожалению, не существует хорошего способа сделать то же самое для определяемых пользователем уровней, таких как 2 и 4. Их использование предполагает, что вы создаете новый именованный целевой юнит systemd наподобие /etc/systemd/system/ваша цель, который берет за основу один из существующих уровней запуска (взгляните, например, на /usr/lib/systemd/system/graphical.target), создаете каталог /etc/systemd/system/ваша цель.wants, а после этого - символические ссылки на дополнительные службы из директории /usr/lib/systemd/system/, которые вы хотите включить при загрузке.

Таблица целей

\begin{longtable}{ | m{3cm} | m{3cm} | m{10cm} | }\hline  
\textbf{Уровнень запуска SysV} & \textbf{Цель systemd} & \textbf{Примечания}\\\hline
0 & runlevel0.target, poweroff.target & Выключить систему\\\hline
1, s, single & runlevel1.target, rescue.target & Однопользовательский уровень запуска\\\hline
2, 4 & runlevel2.target, runlevel4.target, multi-user.target & Уровни запуска, определенные пользователем/специфичные для узла. По умолчанию соответствует уровню запуска 3\\\hline
3 & runlevel3.target, multi-user.target & Многопользовательский режим без графики. Пользователи, как правило, входят в систему при помощи множества консолей или через сеть\\\hline
5 & runlevel5.target, graphical.target & Многопользовательский режим с графикой. Обычно эквивалентен запуску всех служб на уровне 3 и графического менеджера входа в систему\\\hline
6 & runlevel6.target, reboot.target & Перезагрузка\\\hline
emergency & emergency.target & Аварийная оболочка\\\hline
\end{longtable}

\subsubsection{Изменение текущей цели}
В systemd цели доступны посредством целевых юнитов. Их можно изменить командой:

\begin{verbatim}
 # systemctl isolate graphical.target
\end{verbatim} 

Данная команда изменит только лишь текущую цель и не повлияет на следующую загрузку системы. Она соответствует командам Sysvinit вида telinit 3 и telinit 5.

\subsubsection{Изменение цели загрузки по умолчанию}
Стандартная цель — \textbf{default.target}, которая по умолчанию является псевдонимом \textbf{graphical.target} (примерно соответствующего прежнему уровню запуска 5). Для изменения цели загрузки по умолчанию добавьте один из следующих параметров ядра в загрузчик:

\begin{itemize}
 \item systemd.unit=multi-user.target (что примерно соответствует прежнему уровню запуска 3)
\item systemd.unit=rescue.target (что примерно соответствует прежнему уровню запуска 1)
\end{itemize}

Другой способ — оставить загрузчик без изменений, а изменить целевой юнит по умолчанию, т.е. \textbf{default.target}. Это делается с использованием systemctl:
\begin{verbatim}
 # systemctl set-default multi-user.target
\end{verbatim} 

Чтобы иметь возможность перезаписать ранее установленную default.target, используйте опцию force:
\begin{verbatim}
 # systemctl set-default -f multi-user.target
\end{verbatim} 

Эффект от применения данной команды выводится через systemctl. Символическая ссылка на новый целевой юнит по умолчанию создается в директории /etc/systemd/system/default.target.

\subsection{Временные файлы}
\textbf{systemd-tmpfiles} создает, удаляет и очищает непостоянные и временные файлы и каталоги. Он читает конфигурационные файлы из /etc/tmpfiles.d/ и /usr/lib/tmpfiles.d/, чтобы понять, что ему следует делать. Конфигурационные файлы в первом каталоге имеют приоритет над теми, что расположены во втором.

Конфигурационные файлы обычно предоставляются вместе с файлами служб и имеют названия вида /usr/lib/tmpfiles.d/программа.conf. Например, демон Samba предполагает, что существует каталог /run/samba с корректными правами доступа. Поэтому пакет samba поставляется в следующей конфигурации:

\begin{verbatim}
/usr/lib/tmpfiles.d/samba.conf
D /run/samba 0755 root root
\end{verbatim}

Конфигурационные файлы также могут использоваться для записи значений при старте системы. Например, если вы используете /etc/rc.local для отключения пробуждения от устройств USB при помощи echo USBE > /proc/acpi/wakeup, вместо этого вы можете использовать следующий tmpfile:
\begin{verbatim}
/etc/tmpfiles.d/disable-usb-wake.conf
w /proc/acpi/wakeup - - - - USBE
\end{verbatim} 

Для получения дополнительной информации смотрите страницы справочного руководства (man) systemd-tmpfiles(8) и tmpfiles.d(5).

\so{Примечание:} Этот способ может не сработать для установки опций в /sys, поскольку служба systemd-tmpfiles-setup может запускаться перед тем, как будут загружены соответствующие модули устройств. В этом случае при помощи команды modinfo модуль вы можете проверить, имеет ли модуль параметр для установки необходимой вам опции, и установить эту опцию в конфигурационном файле /etc/modprobe.d. В противном случае для установки верных атрибутов сразу, как только устройство появляется, вам придется написать правило udev

\subsection{Таймеры}
Таймер — это файл конфигурации юнита, имя которого заканчивается на .timer. Он расшифровывает информацию о таймере, контролируемом при помощи systemd, для активации в определенное время. 

\so{Примечание:} таймеры способны в значительной степени заменить функциональность cron.

\subsection{Журнал}
systemd имеет собственную систему ведения логов, названную журналом (journal). В связи с этим больше не требуется запускать демон syslog. Для чтения логов используйте команду:
\begin{verbatim}
# journalctl
\end{verbatim} 

\subsection{Фильтрация вывода}
journalctl позволяет фильтровать вывод по особым полям. Помните, что, если должно быть отражено большое количество сообщений или необходима фильтрация в большом промежутке времени, вывод этой команды может быть отложен на какое-то время.

\so{Совет:} поскольку журнал хранится в двоичном формате, содержимое его сообщений не меняется. Это означает, что их можно просматривать при помощи strings, например, в окружении, в котором не установлен systemd. Пример:
\begin{verbatim}
 $ strings /mnt/arch/var/log/journal/af4967d77fba44c6b093d0e9862f6ddd/system.journal | grep -i сообщение
\end{verbatim} 

Примеры:
\begin{itemize}
 \item Показать все сообщения с момента текущей загрузки системы:
\begin{verbatim}
# journalctl -b
\end{verbatim} 
Однако, пользователи часто интересуются сообщениями не для текущей, а для предыдущей загрузки (например, если произошел невосстановимый сбой системы). Это возможно, если задать параметр флагу -b: \textbf{journalctl -b -0} покажет сообщения с момента текущей загрузки, \textbf{journalctl -b -1} — предыдущей загрузки, \textbf{journalctl -b -2} — следующей за предыдущей, и т.д. Для просмотра полного описания смотрите страницу справочного руководства journalctl(1): имеется гораздо более мощная семантика
\item Показать все сообщения, начиная с какой-либо даты (и, если хотите, времени):
\begin{verbatim}
# journalctl --since="2012-10-30 18:17:16"
\end{verbatim} 
\item Показать все сообщения за последние 20 минут:
\begin{verbatim}
 # journalctl --since "20 min ago"
\end{verbatim} 
\item Показывать новые сообщения:
\begin{verbatim}
# journalctl -f
\end{verbatim} 
\item Показать все сообщения для конкретного исполняемого файла:
\begin{verbatim}
# journalctl /usr/lib/systemd/systemd
\end{verbatim} 
\item Показать все сообщения для конкретного процесса:
\begin{verbatim}
# journalctl _PID=1
\end{verbatim} 
\item Показать все сообщения для конкретного юнита:
\begin{verbatim}
# journalctl -u netcfg
\end{verbatim} 
\item Показать кольцевой буфер ядра:
\begin{verbatim}
# journalctl -k
\end{verbatim} 
\item Показать auth.log эквивалентно фильтрации syslog facility:
\begin{verbatim}
# journalctl -f -l SYSLOG_FACILITY=10
\end{verbatim} 
\end{itemize}

Для получения дополнительной информации смотрите страницы справочного руководства journalctl(1) и systemd.journal-fields(7) 

\so{Совет:} по умолчанию journalctl отсекает части строк, которые не вписываются в экран по ширине, и, в некоторых случаях, возможно, будет лучше использовать специальную программу-обертку. Управление этой возможностью производится посредством переменной окружения SYSTEMD\_LESS, в которой содержатся опции, передаваемые в less (программа постраничного просмотра, используемая по умолчанию). По умолчанию ей присвоены опции FRSXMK (для получения дополнительной информации смотрите less(1) и journalctl(1)).

Если убрать опцию S, будет достигнут требуемый результат. Например, запустите journalctl, как показано здесь:

\begin{verbatim}
$ SYSTEMD_LESS=FRXMK journalctl
\end{verbatim} 
Если вы хотите, чтобы такое поведение использовалось по умолчанию, экспортируйте переменную из файла ~/.bashrc или ~/.zshrc

\subsection{Ограничение размера журнала}
Если журнал сохраняется при перезагрузке, его размер по умолчанию ограничен значением в 10\% от объема соответствующей файловой системы. Например, для директории /var/log/journal, расположенной на корневом разделе в 50 Гбайт, максимальный размер журналируемых данных составит 5 Гбайт.

Максимальный объем постоянного журнала можно контролировать при помощи значения SystemMaxUse в конфигурационном файле /etc/systemd/journald.conf, поэтому для ограничения его объема, например, в 50 Mбайт, раскомментируйте и отредактируйте соответствующую строку:
\begin{verbatim}
/etc/systemd/journald.conf
SystemMaxUse=50M
\end{verbatim} 

Для получения дополнительной информации обратитесь к странице справочного руководства journald.conf(5).

\subsection{Очистка файлов журнала вручную}
Файлы журнала находятся в /var/log/journal, так что rm будет работать. Или используйте journalctl,

Примеры:
\begin{itemize}
 \item Удалить архивы файлов журнала, так чтобы дисковое пространство, занимаемое ими, стало меньше 100Мб
\begin{verbatim}
# journalctl --vacuum-size=100M
\end{verbatim} 
\item Очистить все файлы журнала, содержащие информацию, полученную более 2-х недель назад:
\begin{verbatim}
# journalctl --vacuum-time=2weeks
\end{verbatim} 
\end{itemize}

Для получения дополнительной информации, обратитесь к journalctl(1).

\subsection{Journald в связке с классическим демоном syslog}
Совместимость с классической реализацией syslog, несовместимого с journald, можно обеспечить, заставив systemd направлять все сообщения через сокет /run/systemd/journal/syslog. Чтобы дать возможность демону syslog работать вместе с журналом systemd, следует привязать данный демон к указанному сокету вместо /dev/log (официальное сообщение). Пакетом syslog-ng из репозиториев автоматически предоставляется необходимая конфигурация.

Начиная с версии systemd 216, по умолчанию journald.conf для передачи данных в сокет был изменён на \textbf{ForwardToSyslog=no}, чтобы избежать нагрузки на систему, потому что rsyslog или syslog-ng (начиная с версии 3.6) тянут сообщения из журнала самостоятельно.

Если используется rsyslog, нет необходимости менять эту настройку, поскольку rsyslog забирает сообщения из журнала самостоятельно.

\subsubsection{Перенаправить журнал на /dev/tty12}
Создайте drop-in каталог /etc/systemd/journald.conf.d и создайте файл fw-tty12.conf с содержимым:

\begin{verbatim}
 /etc/systemd/journald.conf.d/fw-tty12.conf
[Journal]
ForwardToConsole=yes
TTYPath=/dev/tty12
MaxLevelConsole=info
\end{verbatim} 
Затем перезапустите systemd-journald.

\subsubsection{Команда просмотра другого журнала}
Если появилась необходимость проверить логи другой системы, которая неисправна, загрузитесь с работоспособной системы, чтобы восстановить неисправную систему. Примонтируйте диск неисправной системы, например в /mnt и укажите путь журнала через \textbf{-D/--directory}, например так:

\begin{verbatim}
$ journalctl -D /mnt/var/log/journal -xe
\end{verbatim} 

\subsection{Оптимизация}
\subsubsection{Анализ процесса загрузки}
\paragraph{Использование systemd-analyze}
Systemd предоставляет инструмент под названием systemd-analyze, позволяющий проанализировать процесс загрузки вашей системы, чтобы можно было увидеть, какие файлы юнитов тормозят загрузку. Соответственно, вы можете оптимизировать вашу систему. Для использования данного инструмента потребуется установить пакеты python2-cairo и python2-gobject.

Чтобы увидеть, сколько времени было потрачено на подготовку пространства ядра и пространства пользователя во время загрузки, выполните команду:

\begin{verbatim}
$ systemd-analyze
\end{verbatim} 

\so{Совет:}
Если вы дополните хуком timestamp массив HOOKS в конфигурационном файле /etc/mkinitcpio.conf и пересоберете ваш образ initramfs командой mkinitcpio -p linux, systemd-analyze сколько времени затрачивается на initramfs.

Если вы загружаетесь при помощи UEFI и используете загрузчик, в котором реализован Boot Loader Interface от systemd , systemd-analyze дополнительно сможет показать, сколько времени затрачено на прошивку EFI сам загрузчик.

Чтобы увидеть список запускаемых файлов юнитов, отсортированный по потраченному каждым из них на загрузку времени, выполните команду:

\begin{verbatim}
$ systemd-analyze blame
\end{verbatim} 
Также можно создать файл SVG, показывающий процесс загрузки в графическом виде, наподобие Bootchart:

\begin{verbatim}
$ systemd-analyze plot > plot.svg
\end{verbatim} 

\paragraph{Использование systemd-bootchart}
Bootchart объединен с systemd с 17 октября 2012 года и его можно использовать для загрузки также, как и оригинальный bootchart. Добавьте следующие команду к строке инициализации ядра:

\begin{verbatim}
initcall_debug printk.time=y init=/usr/lib/systemd/systemd-bootchart
\end{verbatim} 

\subsection{Решение проблем}
\subsubsection{Изучение ошибок systemd}
В качестве примера мы изучим ошибки службы systemd-modules-load:

\begin{enumerate}
 \item Давайте найдем службы systemd, которые не смогли запуститься:
\begin{verbatim}
$ systemctl --failed
systemd-modules-load.service   loaded failed failed  Load Kernel Modules                                                                        \end{verbatim} 
\item Мы обнаружили проблему в службе systemd-modules-load и хотим узнать больше:
\begin{verbatim}
$ systemctl status systemd-modules-load
systemd-modules-load.service - Load Kernel Modules
   Loaded: loaded (/usr/lib/systemd/system/systemd-modules-load.service; static)
   Active: failed (Result: exit-code) since So 2013-08-25 11:48:13 CEST; 32s ago
     Docs: man:systemd-modules-load.service(8).
           man:modules-load.d(5)
  Process: 15630 ExecStart=/usr/lib/systemd/systemd-modules-load (code=exited, status=1/FAILURE)
\end{verbatim} 
Если вы не увидите в списке Process ID, просто перезапустите службу при помощи команды systemctl restart systemd-modules-load
\item Теперь у нас есть id процесса (PID) для более детального изучения ошибки. Введите следующую команду с правильным Process ID (в данном примере это 15630):
\begin{verbatim}
 $ journalctl _PID=15630
-- Logs begin at Sa 2013-05-25 10:31:12 CEST, end at So 2013-08-25 11:51:17 CEST. --
Aug 25 11:48:13 mypc systemd-modules-load[15630]: Failed to find module 'blacklist usblp'
Aug 25 11:48:13 mypc systemd-modules-load[15630]: Failed to find module 'install usblp /bin/false'
\end{verbatim}
\item Мы видим, что некоторые конфигурационные файлы модулей ядра имеют неверные настройки. В этом случае мы взглянем на эти настройки в каталоге /etc/modules-load.d/:
\begin{verbatim}
 $ ls -Al /etc/modules-load.d/
...
-rw-r--r--   1 root root    79  1. Dez 2012  blacklist.conf
-rw-r--r--   1 root root     1  2. Mär 14:30 encrypt.conf
-rw-r--r--   1 root root     3  5. Dez 2012  printing.conf
-rw-r--r--   1 root root     6 14. Jul 11:01 realtek.conf
-rw-r--r--   1 root root    65  2. Jun 23:01 virtualbox.conf
...
\end{verbatim} 
\item Сообщение об ошибке \textbf{Failed to find module 'blacklist usblp'} должно относиться к неправильной настройке в файле \textbf{blacklist.conf}. Давайте закомментируем настройку, вставив хэш-символ \# перед каждой опцией, найденной на шаге 3:
\begin{verbatim}
 /etc/modules-load.d/blacklist.conf
# blacklist usblp
# install usblp /bin/false
\end{verbatim} 
\item Теперь попробуйте запустить systemd-modules-load:
\begin{verbatim}
$ systemctl start systemd-modules-load
\end{verbatim} 
Если все прошло успешно, ничего не отобразится. Если же вы видите какие-либо ошибки, вернитесь к шагу 3 и используйте новый PID для устранения оставшихся ошибок.\\
Если все хорошо, вы можете удостовериться, что служба успешно запустилась, при помощи команды:
\begin{verbatim}
 $ systemctl status systemd-modules-load
systemd-modules-load.service - Load Kernel Modules
   Loaded: loaded (/usr/lib/systemd/system/systemd-modules-load.service; static)
   Active: active (exited) since So 2013-08-25 12:22:31 CEST; 34s ago
     Docs: man:systemd-modules-load.service(8)
           man:modules-load.d(5)
 Process: 19005 ExecStart=/usr/lib/systemd/systemd-modules-load (code=exited, status=0/SUCCESS)
Aug 25 12:22:31 mypc systemd[1]: Started Load Kernel Modules.
\end{verbatim} 
\end{enumerate}

\subsubsection{Диагностика проблем с загрузкой системы}
Загрузитесь с этими параметрами ядра:

\begin{verbatim}
 systemd.log_level=debug systemd.log_target=kmsg log_buf_len=1M
\end{verbatim} 

\subsubsection{Дополнительная информация по отладке}

Диагностика проблем в работе определенной службы
Если какая-либо служба systemd ведет себя не так, как ожидается, и вы хотите получить дополнительную информацию о том, что происходит, присвойте переменной окружения SYSTEMD\_LOG\_LEVEL значение debug. Например, чтобы запустить демон systemd-networkd в режиме отладки:

\begin{verbatim}
# systemctl stop systemd-networkd
# SYSTEMD_LOG_LEVEL=debug /lib/systemd/systemd-networkd
\end{verbatim} 

В качестве альтернативы можно временно отредактировать файл службы для получения подробного вывода. Например:

\begin{verbatim}
 /usr/lib/systemd/system/systemd-networkd.service
[Service]
...
Environment=SYSTEMD_LOG_LEVEL=debug
....
\end{verbatim} 
Если вы знаете, что в дальнейшем вам по-прежнему будет нужна эта отладочная информация, добавьте переменную обычным способом.

\subsubsection{Выключение/перезагрузка происходят ужасно долго}
Если процесс выключения занимает очень долгое время (или, по-видимому, зависает), то, вероятно, виновата служба, которая не завершает свою работу. systemd ожидает некоторое время, пока каждая служба завершит свою работу самостоятельно, и только потом пытается принудительно завершить (kill) ее. 

\subsubsection{По-видимому, процессы с кратким сроком жизни не оставляют записей в логах}
Если команда \textbf{journalctl -u foounit} не показывает вывода для службы с коротким сроком жизни, вместо нее обратитесь к PID. Например, если загрузка службы systemd-modules-load.service завершилась неудачно и команда systemctl status systemd-modules-load показывает, что она была запущена с PID 123, то вы сможете посмотреть вывод процесса в журнале под данным PID, то есть командой
\begin{verbatim}                                                                                                                                                                                                                                                                                                                                                                                                    journalctl -b _PID=123                                                                                                                                                                                                                                                                                                                                                                                                   \end{verbatim} 
Такие поля метаданных для журнала, как \_SYSTEMD\_UNIT и \_COMM, собираются асинхронно и зависят от директории /proc в случае с действующими процессами. Исправление этой ситуации требует внесения исправлений в ядро для обеспечения предоставления этих данных через сокет, наподобие SCM\_CREDENTIALS.

\subsubsection{Отключение журналирования аварийных дампов памяти приложений}
Добавьте в файл /etc/systemd/coredump.conf такую строку:

\begin{verbatim}
 Storage=none
\end{verbatim} 
и выполните:

\begin{verbatim}
 # systemctl daemon-reload
\end{verbatim}  
чтобы перезагрузить конфигурацию.


\subsubsection{Время загрузки системы увеличивается с течением времени}
После использования systemd-analyze некоторое количество пользователей заметило, что их время загрузки значительно увеличилось по сравнению с тем, к чему они привыкли. После использования systemd-analyze blame NetworkManager тратил необычно большое количество времени на запуск.

Проблема некоторых пользователей была связана с тем, что /var/log/journal становился слишком большим. При этом также может уменьшаться скорость работы других команд, например, systemctl status или journalctl. Для решения проблемы можно удалить все файлы из каталога журнала (в идеале - сделав где-нибудь резервные копии, хотя бы временно) и затем установить предел размера файла журнала, как описано в разделе <Ограничение размера журнала>.

\subsubsection{systemd-tmpfiles-setup.service fails to start at boot}
Начиная с версии Systemd 219, /usr/lib/tmpfiles.d/systemd.conf определяет атрибуты для каталогов ACL, в /var/log/journal и, следовательно, требует чтобы поддержка ACL была включена для файловой системы, где находится журнал.


\section{Защита соединений SSH}

Secure Shell (SSH) — это мощный сетевой протокол, используемый для подключения к другим системам по защищённому каналу. Передача данных по SSH шифруется и защищена от перехвата. 

\so{Важно}
В этом разделе рассказывается о наиболее стандартных способах защиты SSH, и предлагаемые здесь способы ни в коем случае не должны считаться исчерпывающими или окончательными. Описание всех значений параметров, доступных для изменения поведения демона sshd, можно просмотреть на странице руководства sshd\_config(5), а объяснения базовых принципов работы SSH — на странице руководства ssh(1).

\subsection{Криптографический вход в систему}
SSH поддерживает использование криптографических ключей для входа в систему. Этот способ гораздо более надежен, чем использование пароля. При сочетании этого способа с другими способами аутентификации, то это может считаться многофакторной аутентификацией. Об использовании способов многофакторной идентификации читайте в разделе «Методы многофакторной идентификации».

Чтобы получить возможность использования криптографических ключей для аутентификации, значение параметра \textbf{PubkeyAuthentication} файла /etc/ssh/sshd\_config должно быть установлено на «yes». Обратите внимание, что это является значением по умолчанию. Для отключения возможности использования паролей для входа в систему, установите «no» для параметра \textbf{PasswordAuthentication}.

Ключи SSH можно создать с помощью команды ssh-keygen. При вызове без дополнительных аргументов, команда создаёт набор ключей RSA длиной в 2048 бит. По умолчанию ключи хранятся в каталоге ~/.ssh/. Для изменения надёжности ключа используйте аргумент \textbf{-b}. Обычно, использования ключей в 2048 бит вполне достаточно.  

Теперь в каталоге ~/.ssh/ мы можем увидеть два ключа. Если при вызове команды ssh-keygen были приняты значения по умолчанию, то эти два ключа называются \textbf{id\_rsa} и \textbf{id\_rsa.pub}, и содержат закрытый и открытый ключи, соответственно. Закрытый ключ необходимо защитить от внешнего воздействия, сделав его нечитаемым для всех, кроме владельца файла. Открытый ключ, тем не менее, должен быть перенесён в ту систему, в которую предполагается вход. Для переноса ключа на сервер используйте команду ssh-copy-id:

\begin{verbatim}
 $ ssh-copy-id -i [user@]server
\end{verbatim} 

Эта команда также автоматически добавит открытый ключ в файл ~/.ssh/authorized\_keys на сервере. Демон sshd будет проверять этот файл при попытке входа на сервер.

Как и пароли, а также и другие механизмы аутентификации, ключи SSH необходимо регулярно менять. При это не забывайте удалять любые не используемые ключи из файла authorized\_keys.


\subsection{Способы многофакторной аутентификации}

Использование нескольких способов аутентификации, или многофакторная аутентификация, повышает уровень защиты от неавторизованного доступа, и поэтому должно рассматриваться при укреплении системы для защиты от взлома. Для получения доступа к системе, в которой используется многофакторная аутентификация, пользователи должны успешно пройти все указанные методы аутентификации.

Используемые способы аутентификации указываются в файле /etc/ssh/sshd\_config. Обратите внимание, что с помощью его параметров можно указать более одного списка требуемых методов аутентификации, и в таком случае пользователь должен успешно выполнить каждый метод минимум из одного списка. Элементы списка разделяются пробелами, а отдельные названия способов аутентификации отделяются запятыми. Например:

\begin{verbatim}
 AuthenticationMethods publickey,gssapi-with-mic publickey,keyboard-interactive
\end{verbatim} 


Демон sshd, настроенный с помощью вышеуказанной директивы AuthenticationMethods, предоставит доступ только в том случае, если пользователь  успешно пройдёт либо аутентификацию по открытому ключу в совокупности с gssapi с микрофоном⁠ либо в совокупности с интерактивной аутентификацией с помощью клавиатуры. Обратите внимание, что каждый из запрашиваемых методов аутентификации должен быть явным образом активирован с помощью соответствующей директивы конфигурации (например, PubkeyAuthentication) в файле /etc/ssh/sshd\_config. Общий список доступных методов аутентификации см. в разделе AUTHENTICATION страницы руководства ssh(1).
⁠


\subsection{Другие средства защиты SHH}

\subsubsection{Версия протокола}
Хотя реализация протокола SSH, поставляемая в ROSA Enterprise Linux Server, поддерживает как  первую, так и втору версию протокола для клиентов SSH, только втора версия должна быть использована везде, где только это возможно. Версия SSH-2 содержит многочисленные улучшения по сравнению со старой версией 1, и большинство продвинутых конфигураций возможны только при использовании SSH-2 .

 
\subsubsection{Типы ключей}
Хотя по умолчанию команда ssh-keygen создаёт пару ключей SSH-2 RSA, с помощью переданного параметра \textbf{-t} ей можно указать создать также и ключи DSA или ECDSA. Алгоритм ECDSA (Elliptic Curve Digital Signature Algorithm) предоставляет лучшую производительность при той же самой эквивалентной длине симметричного ключа. Также он создаёт более короткие ключи.

\subsubsection{Порт не по умолчанию}
По умолчанию, демон sshd слушает TCP порт 22. Смена порта сокращает возможное число уязвимостей системы для атак на базе автоматического скандирования сети, таким образом повышая защиту по принципу «безопасность через неясность» (security through obscurity). Указать порт можно с помощью директивы Port в конфигурационном файле /etc/ssh/sshd\_config. Также обратите внимание, что для возможности использования порта не по умолчанию, нужно изменять политику SELinux по умолчанию. Это можно сделать, изменив тип SELinux ssh\_port\_t, введя следующую команду с правами пользователя root: 

\begin{verbatim}
 # semanage -a -t ssh_port_t -p tcp номер_порта
\end{verbatim} 
Замените «номер\_порта» в вышеуказанной команде на новый номер, указанный с помощью директивы Port.

\subsubsection{Запрет входа в систему под учётной записью root}
Если частный случай использования не предусматривает возможности входа в систему под учётной записью root, укажите значение «no» для директивы PermitRootLogin в файле /etc/ssh/sshd\_config. Отключив возможность прямого входа в систему под учётной записью root, системный администратор может проверить, какие именно команды выполняются с полученными привилегиями root, и какие именно пользователи их выполняют, получив доступ в систему и затем получив права root.


\section{Использование PAM для ограничения доступа к службам с привилегиями root}
Модуль PAM \textbf{/lib/security/pam\_listfile.so} предоставляет очень гибкое средство ограничения доступа для различных учётных записей. Администратор может использовать этот модуль для указания списка пользователей, которым запрещен вход в систему. Для ограничения доступа root к системной службе, отредактируйте файл нужной службы в каталоге /etc/pam.d/ так, чтобы для аутентификации требовался модуль \textbf{pam\_listfile.so}.

В примере ниже можно увидеть, как используется этот модуль для сервера vsftpd FTP в конфигурационном файле PAM /etc/pam.d/vsftpd (символ косой черты в конце первой строки не обязателен, если директива умещается в одну строку):
\begin{verbatim}
auth   required   /lib/security/pam_listfile.so   item=user \
sense=deny file=/etc/vsftpd.ftpusers onerr=succeed
\end{verbatim} 


Эти параметры указывают PAM обратиться к файлу /etc/vsftpd.ftpusers и отказать в доступе к службе любому из указанных пользователей. Администратор может изменить название этого файла, а также может либо хранить отдельный список для каждой службы либо использовать один главный список для отказа в доступе ко многим службам.

При необходимости отказать в доступе к нескольким службам аналогичную строку можно добавить в конфигурационные файлы PAM, такие, как /etc/pam.d/pop и /etc/pam.d/imap для почтовых клиентов, или /etc/pam.d/ssh для клиентов SSH.


Подробные сведения о PAM см. в The Linux-PAM System Administrator's Guide, расположенном в каталоге /usr/share/doc/pam-<версия>/html/ 



\section{Установка значений ulimit}

Параметры файла /etc/security/limits.conf имеют следующий вид:

\begin{verbatim}
 # vi /etc/security/limits.conf
#<domain>        <type>  <item>  <value>

*               -       core             <value>
*               -       data             <value>
*               -       priority         <value>
*               -       fsize            <value>
*               soft    sigpending       <value> eg:57344
*               hard    sigpending       <value> eg:57444
*               -       memlock          <value>
*               -       nofile           <value> eg:1024
*               -       msgqueue         <value> eg:819200
*               -       locks            <value>
*               soft    core             <value>
*               hard    nofile           <value>
@<group>        hard    nproc            <value>
<user>          soft    nproc            <value>
%<group>        hard    nproc            <value>
<user>          hard    nproc            <value>
@<group>        -       maxlogins        <value>
<user>          hard    cpu              <value>
<user>          soft    cpu              <value>
<user>          hard    locks            <value>
\end{verbatim} 


Где:
<domain> может быть:

\begin{itemize}
 \item Именем пользователя
\item Именем группы, с синтаксисом @group
\item Символом подстановки *, обозначающим значение по умолчанию
\item Символом подстановки \%, а также он может использоваться с синтаксисом \%group, для указания максимального ограничения входов в систему
\end{itemize}



<type> может иметь два значения:

\begin{itemize}
\item "soft" для принудительного применения мягких ограничений
\item "hard" для принудительного применения жёстких ограничений
\end{itemize}



<item> может иметь одно из следующих значений:

\begin{itemize}
 \item core - ограничивает размер файлов дампа памяти (KБ)
\item data - максимальный размер данных (KB)
\item fsize - максимальный размер файла (KB)
\item memlock - максимальный размер адресного пространства, закреплённого в памяти (KB)
\item nofile - максимально число открытых файлов
\item rss - максимальный размер страниц памяти (KB)
\item stack - максимальный размер стека (KB)
\item cpu - максимальное время ЦПУ (MIN)
\item nproc - максимально число процессов
\item as - предел адресного пространства (KB)
\item maxlogins - максимально число входов в систему для этого пользователя
\item maxsyslogins - максимальное число входов в эту систему
\item priority - приоритет, с которым выполняется процесс пользователя
\item locks - максимально число блокировок файлов на этого пользователя
\item sigpending - максимальное число ожидающих сигналов
\item msgqueue - максимальный объём памяти, используемый очередью сообщений POSIX (байтов)
\item nice - максимальный nice приоритет, которому разрешено увеличить значение: [-20, 19]
\item rtprio - максимальный приоритет реального времени
\end{itemize}


Для применения изменений выйдите из терминала и снова выполните вход.

Подробности см.: 
\begin{verbatim}
# man limits.conf
\end{verbatim} 


\section{Аудит}


Система аудита в Linux предоставляет собой способ отслеживания информации, имеющей отношение к безопасности системы. Основанная на предварительно настроенных правилах, программа Audit создаёт записи в журнале с целью зафиксировать такое количество информации о событиях, происходящих в системе, какое только возможно. Эта информация имеет ключевое значение для определения нарушителя политики безопасности в критически важных окружениях, и выполненных нарушителем действиях. Audit не предоставляет дополнительные средства безопасности системы, скорее её можно использовать для раскрытия нарушений политик безопасности, уже используемых в системе. Повторение замеченных с помощью Audit нарушений в дальнейшем могут быть предотвращены с использованием дополнительных мер безопасности таких, как SELinux.

В списке ниже представлены примеры информации, которую может записать Audit в файлы своего журнала:

\begin{itemize}
\item Дата, время, тип и результат события
\item Метки конфиденциальность субъектов и объектов
\item Связь события с идентификатором пользователя, вызвавшего событие
\item Все изменения фалов в Audit и попытки поучения доступа к файлам журнала Audit 
\item Все случаи использования механизма аутентификации, такие, как SSH, Kerberos и другие.
\item Изменения в любой доверенной базе данных, например, в файле  /etc/passwd.
\item Попытки импортировать или экспортировать информацию в или из системы.
\item Включение или исключение событий на основе идентификатора пользователя, меток субъектов и объектов, и других атрибутов.
\end{itemize}



 
\subsection{Варианты использования Audit}

\begin{itemize}
 \item \textbf{Отслеживание доступа к файлам}\\
Audit может отследить, был ли выполнен доступ к файлу или к каталогу, вносились ли изменения, запускался ли файл, были ли изменены атрибуты файлов. Это удобно, например, для обнаружения доступа к важным файлам. В случае повреждения таких файлов администратор обращается к информации, записанной Audit. 
\item \textbf{Наблюдение за системными вызовами}\\
Audit можно настроить на создание записи в журнале каждый раз, когда используется конкретный системный вызов. Эту возможность можно использовать, например, для отслеживания изменения в системном времени, выполняя наблюдения за \textbf{settimeofday}, \textbf{clock\_adjtime} и другими системными вызовами, имеющими отношение к времени.
\item \textbf{Запись команд, выполняемых пользователем}\\
Audit отслеживает запуск файлов на выполнение, поэтому администраторы имеют возможность настроить правила на запись каждого выполнения конкретной команды. Правило можно создать, например, для каждого выполняемого файла в каталоге /bin. По полученным записям в журнале далее можно выполнить поиск по идентификатору пользователя и создать журнал аудита, содержащий выполненные пользователем команды.
\item \textbf{Запись выполнения системных путей файлов}\\
Кроме наблюдения за доступом к файлам, который при вызове правила переводит путь в индексный дескриптор, Audit на сегодняшний день также может наблюдать за выполнением пути даже если он не существует при вызове правила, или если файл заменяется после вызова  правила. Это даёт возможность правилам продолжать работу после обновления выполняемого файла программы или даже ещё до того, как он был установлен.
\item \textbf{Запись событий безопасности}\\
Модуль аутентификации pam\_faillock может записывать неудачные попытки входа в систему. Audit также можно настроить на запись неудачных попыток входа в систему, и Audit предоставляет дополнительную информацию о пользователе, который сделал попытку входа.
\item \textbf{Поиск событий}\\
Audit предоставляет утилиту ausearch, которую можно использовать для фильтрации записей в журнале и получения полного журнала аудита на основе некоторого количества условий.
\item \textbf{Получение сводных отчётов}\\
Утилиту \textbf{aureport}, помимо других возможностей, можно использовать для создания ежедневных отчётов о записанных событиях. Системный администратор затем может проанализировать эти отчёты и далее глубже исследовать подозрительную активность.
\item \textbf{Наблюдение за сетевым доступом}\\
Утилиты iptables и ebtables можно настроить на запуск событий аудита, что даёт администратору возможность наблюдения за сетевым доступом.
\end{itemize}



\so{Внимание}
В зависимости от объёма информации, собираемого программой Audit,  она может оказывать влияние на производительность системы.
⁠
\subsection{Архитектура системы audit}
Программа Audit состоит из двух основных частей: приложения и утилиты в пространстве пользователя, и обработка системных вызовов со стороны ядра. Компонент ядра получает системные вызовы от приложений из пространства пользователя и пропускает их сквозь один из трёх фильтров: \textbf{user}, \textbf{task} или \textbf{exit}. Как только системный вызов проходит фильтр исключения, он посылается сквозь один из вышеуказанных фильтров, который, основываясь на параметрах правила Audit, посылает его демону аудита для дальнейшей обработки. Рисунок ниже иллюстрирует этот процесс. 

%\begin{pic}
 %перевести картинку
%\end{pic}



Демон Audit, расположенный в пространстве пользователя, собирает информацию ядра и создаёт записи в файле журнала. Другие утилиты Audit в пользовательском пространстве взаимодействуют с демоном Audit, с компонентом ядра Audit или с файлами журнала Audit:   

\begin{itemize}
\item \textbf{audisp} — демон-координатор программы Audit, который взаимодействует с демоном Audit и посылает события другим приложениям для дальнейшей обработки. Назначение этого демона — предоставление механизма интеграции, так чтобы аналитические программы реального времени могли взаимодействовать с событиями Audit.
\item \textbf{auditctl} — утилита контроля Audit, которая взаимодействует с компонентом ядра для управления правилами и для контроля некоторого числа установок и параметров процесса создания событий.
\end{itemize}



Остальные утилиты Audit получают содержимое журнала Audit в качество ввода и создают вывод на основе требований пользователя. Утилита \textbf{aureport}, например, создаёт отчёт обо всех записанных событиях.


\subsection{Установка пакетов audit}
Чтобы использовать систему Audit, в системе должны быть установлены соответствующие пакеты. Пакеты аудита (\textbf{audit} и \textbf{audit-libs}) в ROSA Enterprise Linux Server установлены по умолчанию. Но если вдруг они отсутствуют в системе, выполните следующую команду с правами пользователя root для установки Audit и её зависимостей:
\begin{verbatim}
# yum install audit
\end{verbatim} 

\subsection{Настройка параметров службы audit}
Демон Audit настраивается в файле /etc/audit/auditd.conf. Этот файл состоит из конфигурационные параметров, изменяющих поведение демона Audit.  Пустые строки и строки, начинающиеся с символа решётки (\#), игнорируются. Подробности см. на странице руководства audit.conf(5).


\subsubsection{Настройка auditd для среды, защищённой от несанкционированного доступа}
Значения по умолчанию auditd должны подходить для большинства окружений. Тем не менее, если окружение в конкретной системе должно отвечать требованиям строгих политик обеспечения безопасности, то мы рекомендуем следующие параметры для демона Audit, настраиваемые в файле /etc/audit/auditd.conf:

\begin{itemize}
 \item \textbf{log\_file}\\
Каталог, содержащий файлы журнала Audit (обычно это /var/log/audit/), должен располагаться на отдельной точке монтирования. Это предотвращает поглощение места в этом каталоге другими процессами и обеспечивает точное определение свободного места, которым располагает демон Audit. 
\item \textbf{max\_log\_file}\\
Указывает максимальный размер одного файла журнала Audit, значение должно быть настроено на полное использование доступного места на разделе, на котором располагаются файлы журнала Audit  
\item \textbf{max\_log\_file\_action}\\
Определяет, какое действие должно выполняться по достижении лимита, установленного в параметре max\_log\_file, здесь необходимо указать keep\_logs, для предотвращения перезаписи журнала Audit 
\item \textbf{space\_left}\\
Определяет объём доступного места на диске, для которого будет запускаться действие, указанное в параметре space\_left\_action. Здесь нужно указать число, которое даст администратору достаточно времени чтобы успеть отреагировать и освободить место на диске. Значение space\_left зависит от скорости, с которой создаются записи в журнале Audit.
\item \textbf{space\_left\_action}\\
Для space\_left\_action рекомендуется указать значение \textbf{email} или \textbf{exec} с соответствующим методом оповещения.
\item \textbf{admin\_space\_left}\\
Указывает абсолютный минимум свободного места на диске, при достижении которого будет запущено действие, указанное для параметра admin\_space\_left\_action. Здесь должно указываться значение, при котором останется достаточно места для журналирования действий, выполняемых администратором.
\item \textbf{admin\_space\_left\_action}\\
Здесь нужно указать \textbf{single}, для перевода системы в однопользовательский режим и предоставления возможности администратору освободить свободное место на диске.
\item \textbf{disk\_full\_action}\\
 Указывает действие, которое должно запускаться при отсутствии свободного места на разделе, на котором размещены файлы журналов Audit; здесь нужно указать  halt или single. Это обеспечивает выключение системы или работу в однопользовательском режиме, если Audit больше не может выполнять журналирование событий.
\item \textbf{disk\_error\_action}
Указывает действие, запускающееся в том случае, если на разделе, на котором размещаются файлы журналов Audit, найдены ошибки. Здесь нужно указать \textbf{syslog}, \textbf{single} или \textbf{halt}, в зависимости от локальных параметров политик безопасности относительно обработки сбоев оборудования.
\item \textbf{flush}\\
Здесь нужно указать \textbf{incremental\_async}. Это значение работает в сочетании с параметром \textbf{freq}, который определяет, какое число записей можно послать на диск, перед принудительным запуском синхронизации с жестким диском. Значение для параметра freq должно составлять 100. Эти параметры обеспечивают синхронизацию данных событий Audit с файлами журнала на диске, одновременно сохраняя хорошую производительность для пиков активности.
\end{itemize}

Остальные параметры должны настраиваться в соответствии с локальными политиками безопасности.

\subsection{Запуск службы audit}
Настроив auditd, запускайте службы для начала сбора информации и сохранения её в файлах журнала. Для запуска auditd выполните следующую команду с правами пользователя root: 
\begin{verbatim}
# service auditd start
\end{verbatim} 

\so{Внимание}
Команда service является единственным средством корректного взаимодействия с демоном auditd. Команду service необходимо использовать для правильной записи значения auid. Команду systemctl можно использовать только для двух действий: enable и status.

Чтобы auditd стартовал при загрузке системы, выполните следующую команду с правами пользователя root: 
\begin{verbatim}
# systemctl enable auditd
\end{verbatim} 

Для auditd можно выполнить также ещё некоторое число действий с помощью команды \textbf{auditd action}, где «action» может быть чем-то из нижеследующего:

\begin{itemize}
 \item \textbf{stop}\\
Останавливает auditd.
\item \textbf{restart}\\
Перезапускает auditd.
\item \textbf{reload} или \textbf{force-reload}\\
Перезапускает параметры auditd, указанные в файле /etc/audit/auditd.conf
\item \textbf{rotate}\\
Выполняет архивацию файлов журнала в каталоге /var/log/audit/ 
\item \textbf{resume}\\
Возобновляет журналирование событий Audit после его остановки, например, при отсутствии достаточного свободного места на разделе диска, где расположены файлы журнала Audit 
\item \textbf{condrestart} или \textbf{try-restart}\\
Перезапускает auditd только если он уже работает.
\item \textbf{status}
Показывает статус выполнения auditd.
\end{itemize}


\subsection{Определение правил audit}
Система аудита работает на основе набора правил, которые определяют, что именно должно попадать в файлы журнала. Можно выделить следующие типы правил Audit: 

\begin{itemize}
 \item \textbf{Правила управления}\\
Разрешают изменять поведения системы аудит и некоторые из её параметров
\item \textbf{Правила файловой системы}\\
Также известные как «файловые дозоры» ("file watches"), они делают возможным наблюдение за доступом к конкретному файлу или каталогу.
\item \textbf{Правила системных вызовов}\\
Дают возможность журналирования системных вызовов, которые выполняет любая указанная программа
\end{itemize}



Правила аудита можно настроить:
\begin{itemize}
 \item в командной строке с помощью утилиты \textbf{auditctl}. Обратите внимание, что после перезагрузки эти правила не сохраняются. Подробности см. в разделе «определение правил Audit с использованием auditctl»;
\item в файле /etc/audit/audit.rules. Подробности см. в разделе «Определение постоянных правил и средств управления Audit в файле /etc/audit/audit.rules».
\end{itemize}


С помощью команды auditctl можно контролировать базовые действия системы Audit и определять правила, согласно которым Audit выбирает, какие события нужно заносить в журнал.


\so{Внимание}
Все команды, взаимодействующие со службой Audit и с файлами журнала Audit, требуют привилегий root. Убедитесь, что запускаете эти команды с правами пользователя root. Кроме того, для настройки служб Audit необходим активный параметр ядра  CAP\_AUDIT\_CONTROL, а для журналирования сообщений пользователя — CAP\_AUDIT\_WRITE.


\subsubsection{Определение правил контроля (управления)}
Ниже приводятся некоторые правила контроля, позволяющие изменять поведение системы Audit: 


\begin{itemize}
 \item \textbf{-b}\\
Устанавливает максимальное число существующих буферов Audit в ядре, например:
\begin{verbatim}
# auditctl -b 8192
\end{verbatim} 
\item \textbf{-f}\\
Указывает, какое событие должно выполняться при обнаружении критической ошибки, например:
\begin{verbatim}
 # auditctl -f 2
\end{verbatim} 
Указанная выше конфигурация в случае критической ошибки запускает kernel panic.
\item \textbf{-e}\\
Включает и выключает систему Audit или блокирует её параметры, например:
\begin{verbatim}
# auditctl -e 2
\end{verbatim} 
Указанная выше команда блокирует параметры Audit 
\item \textbf{-r}\\
Устанавливает количество создаваемых сообщений в секунду, например:
\begin{verbatim}
# auditctl -r 0
\end{verbatim} 
Указанная выше конфигурация убирает количественные ограничения для создаваемых сообщений.
\item \textbf{-s}\\
Сообщает статус системы Audit, например: 
\begin{verbatim}
# auditctl -s
AUDIT_STATUS: enabled=1 flag=2 pid=0 rate_limit=0 backlog_limit=8192 lost=259 backlog=0
\end{verbatim} 
\item \textbf{-l}\\
Выводит список всех текущих загруженных правил Audit, например: 
\begin{verbatim}
 # auditctl -l
-w /etc/passwd -p wa -k passwd_changes
-w /etc/selinux -p wa -k selinux_changes
-w /sbin/insmod -p x -k module_insertion
⋮
\end{verbatim} 
\item \textbf{-D}\\
Удаляет все загруженные на данный момент правила Audit, например: 
\begin{verbatim}
# auditctl -D
No rules
\end{verbatim} 
\end{itemize}



\subsubsection{Определение правил файловой системы}
Чтобы определить правило файловой системы, используйте следующий синтаксис:
\begin{verbatim}
 auditctl -w путь_к_файлу -p права_доступа -k имя_ключа
\end{verbatim} 
где:
\begin{itemize}
 \item путь\_к\_файлу — это наблюдаемый файл или каталог
 \item права — это журналируемые права:
 \begin{itemize}
\item r — доступ на чтение для файла или каталога
\item w — доступ на запись для файла или каталога
\item x — доступ на выполнение для файла или каталога
\item a — изменение в атрибуте файла или каталога
\item имя\_ключа — это дополнительная строка, помогающая определить, на основе какого правила или набора правил была создана конкретная запись в журнале
\end{itemize}
\end{itemize}


\paragraph{Пример: правило для файловой системы}
Чтобы определить правило, на основе которого журналируются все доступы на запись и каждое изменение атрибута файла /etc/passwd, выполните следующую команду:
\begin{verbatim}
# auditctl -w /etc/passwd -p wa -k passwd_changes
\end{verbatim} 
Обратите внимание, что строка, следующая за параметром \textbf{-k}, является произвольной.

Чтобы определить правило, на основе которого журналируются все доступы на запись и все изменения атрибутов для всех файлов в каталоге /etc/selinux/, выполните следующую команду:
\begin{verbatim}
# auditctl -w /etc/selinux/ -p wa -k selinux_changes
\end{verbatim} 

Чтобы определить правило, на основе которого журналируется выполнение команды /sbin/insmod, вводящей модули в ядро Linux, выполните следующую команду: 
\begin{verbatim}
# auditctl -w /sbin/insmod -p x -k module_insertion
\end{verbatim} 


\subsubsection{Определение правил для системных вызовов}
Чтобы определить правило для системного вызова, используйте следующий синтаксис:
\begin{verbatim}
 auditctl -a действие,фильтр -S системный_вызов -F поле=значение -k имя_ключа
\end{verbatim} 

где:
\begin{itemize}
 \item \textbf{«действие»} и \textbf{«фильтр»} указывают, когда будет журналироваться некоторое событие.
 \begin{itemize}
  \item \textbf{«действие»} может быть либо \textbf{«always»} либо \textbf{«never»}
\item \textbf{«фильтр»} указывает, какой фильтр ядра, соответствующий правилу, применяется к действию. Фильтром, соответствующим правилу, может быть:
task, exit, user и exclude. Подробности об этих фильтрах см. в разделе «Архитектура системы аудита».
 \end{itemize}
\item \textbf{системный\_вызов} указывает на имя системного вызова. Список всех системных вызовов можно найти в файле /usr/include/asm/unistd\_64.h. Несколько системных вызовов можно сгруппировать в одном правиле, каждое из них указывается после его собственного параметра \textbf{-S}.
\item \textbf{поле=значение} указывает дополнительные параметры, далее изменяющие правило на соответствие событиям с совпадающей архитектурой, идентификатором группы, идентификатором процесса и с другими параметрами. Полный список доступных типов полей и их значений см. на странице руководства auditctl(8).
\item \textbf{имя\_ключа} — это необязательная строка, помогающая определить, на основе какого правила или набора правил была создана конкретная запись в журнале
\end{itemize}


⁠\paragraph{ПРИМЕР: правило системного вызова}

Чтобы определить правило, создающее запись в журнале каждый раз, когда программы использует системные вызовы \textbf{adjtimex} или \textbf{settimeofday} в 64-битной системе, выполните следующую команду:
\begin{verbatim}
 # auditctl -a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time_change
\end{verbatim} 

Чтобы определить правило, создающее запись в журнале каждый раз, когда системный пользователь со значением ID, равным или более 1000, удаляет или переименовывает файл, выполните следующую команду:
\begin{verbatim}
 # auditctl -a always,exit -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
\end{verbatim} 
Обратите внимание, что параметр \textbf{-F auid!=4294967295} используется для исключения пользователей без UID.

Также возможно определить правило файловой системы с использованием синтаксиса правила системного вызова. Следующая команда создаёт правило для системных вызовов, аналогичное правилу файловой системы \textbf{-w /etc/shadow -p wa}:

\begin{verbatim}
 # auditctl -a always,exit -F path=/etc/shadow -F perm=wa
\end{verbatim} 


\subsubsection{Определение правил для выполняемых файлов}

Чтобы определить правило для используемых файлов, используйте следующий синтаксис:
\begin{verbatim}
 auditctl  -a действие,фильтр [ -F архитектура=ЦП -S системный_вызов] -F exe=путь_до_исполняемого_файла -k имя_ключа
\end{verbatim} 

где:

\begin{itemize}
 \item «действие» и «фильтр» указывают, когда будет журналироваться некоторое событие.
 \begin{itemize}
  \item \textbf{«действие»} может быть либо \textbf{«always»} либо \textbf{«never»}
\item \textbf{«фильтр»} указывает, какой фильтр ядра, соответствующий правилу, применяется к действию. Фильтром, соответствующим правилу, может быть:  task, exit, user и exclude. Подробности об этих фильтрах см. в разделе Архитектура системы аудита.
 \end{itemize}
\item системный\_вызов указывает на имя системного вызова. Список всех системных вызовов можно найти в файле /usr/include/asm/unistd\_64.h. Несколько системных вызовов можно сгруппировать в одном правиле, каждое из них указывается после его собственного параметра \textbf{-S}.
\item \textbf{путь\_до\_исполняемого\_файла} — это абсолютный путь до наблюдаемого выполняемого файла
\item \textbf{имя\_ключа} - это необязательная строка, помогающая определить, на основе какого правила или набора правил была создана конкретная запись в журнале
\end{itemize}


\paragraph{Пример: правило для выполняемого файла}
⁠
Чтобы определить правило, на основе которого будут журналироваться все выполнения программы /bin/id, выполните следующую команду:
\begin{verbatim}
 # auditctl -F exe=/bin/id -S execve -k execution_bin_id
\end{verbatim} 



\subsubsection{Настройка постоянных правил и правил управления Audit в файле /etc/audit/audit.rules}
Чтобы определить правила Audit, сохраняющиеся после перезагрузки системы, их нужно напрямую включить в файл /etc/audit/audit.rules или же использовать программу augenrules, которая читает правила, расположенные в каталоге /etc/audit/rules.d/. Для указания правил в файле /etc/audit/audit.rules используется тот же самый синтаксис консольной команды auditctl. Пустые строки и строки, начинающиеся с символа решётки (\#), игнорируются.

 С помощью команды \textbf{auditctl} и параметра \textbf{-R} также можно читать правила из указанного файла, например:

\begin{verbatim}
 # auditctl -R /usr/share/doc/audit/rules/30-stig.rules
\end{verbatim}    


\subsubsection{Определение правил управления}

В файле может содержаться только одно правило, изменяющее поведение системы Audit:   
\begin{itemize}
 \item -b
 \item -D 
 \item -e
 \item -f
 \item -r
 \item --loginuid-immutable и 
 \item --backlog\_wait\_time
\end{itemize}

 
⁠
\paragraph{Пример: правила управления в файле audit.rules}

\begin{itemize}
 \item Удалить все ранее настроенные правила\\
\textbf{-D}
\item Указать размер буфера\\
\textbf{-b 8192}
\item  Сделать параметры неизменяемыми до следующей перезагрузки\\
\textbf{-e 2}
\item  При сбое запускать kernel panic\\
\textbf{-f 2}
\item Создавать максимум 1000 сообщений аудита в секунду\\
\textbf{-r 100}
\item  Сделать login UID неизменяемым сразу после его установки (может повредить хранилищам)\\
\textbf{--loginuid-immutable 1}
\end{itemize}



\subsubsection{Определение правил для файловой системы и системных вызовов}

Правила для файловой системы и системных вызовов устанавливаются с использованием синтаксиса auditctl. Примеры из раздела «Определение правил Audit с помощью auditctl» можно представить с помощью следующего файла правил:
⁠

\paragraph{Пример: правила для файловой системы и системных вызовов в файле audit.rules}


\begin{verbatim}
-w /etc/passwd -p wa -k passwd_changes
-w /etc/selinux/ -p wa -k selinux_changes
-w /sbin/insmod -p x -k module_insertion

-a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time_change
-a always,exit -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
\end{verbatim} 



\subsubsection{Файлы предварительно настроенных правил}

Пакет audit устанавливает набор предварительно настроенных правил, соответствующих различным стандартам сертификации, в каталоге /usr/share/doc/audit/rules/.
Чтобы использовать эти файлы, создайте резервную копию исходного файла /etc/audit/audit.rules и сохраните копию нужного файла предварительно настроенных правил под именем /etc/audit/audit.rules:

\begin{verbatim}
# cp /etc/audit/audit.rules /etc/audit/audit.rules_backup
# cp /usr/share/doc/audit/rules/30-stig.rules /etc/audit/audit.rules
\end{verbatim} 


\so{Внимание}
Правила Audit подчиняются схеме нумерации, согласно которой они и нумеруются. Чтобы узнать подробности о схеме нумерации, см. файл /usr/share/doc/audit/rules/README-rules.



\paragraph{Использование сценария augenrules для определения постоянных правил}

Сценарий augenrules читает правила, расположенные в каталоге /etc/audit/rules.d/ и объединяет их в файле audit.rules. Этот сценарий обрабатывает все файлы, оканчивающиеся на .rules, в особом порядке, на основе их естественного порядка сортировки. Файлы в этом каталоге организованы в группы со следующими значениями:

\begin{itemize}
\item 10 - Конфигурация для ядра и auditctl
\item 20 - Правила, которые могли соответствовать общим правилам, но нам нужны другие соответствия
\item 30 - Главные правила
\item 40 - Необязательные правила
\item 50 - Правила для сервера
\item 70 - Правила System local
\item 90 - Finalize (неизменяемые)
\end{itemize}



Эти правила не предназначены для одновременного использования. Это части политики, которую нужно продумать и затем скопировать отдельные файлы в файл /etc/audit/rules.d/. Чтобы, например, настроить конфигурацию STIG, скопируйте правила 10-base-config, 30-stig, 31-privileged и 99-finalize.

Собрав нужные правила в каталоге /etc/audit/rules.d/, загрузите их, выполнив скрипт \textbf{augenrules} с параметром \textbf{--load}:
\begin{verbatim}
# augenrules --load
augenrules --load No rules
enabled 1
failure 1
pid 634
rate_limit 0
backlog_limit 8192
lost 0
backlog 0
enabled 1
failure 1
pid 634
rate_limit 0
backlog_limit 8192
lost 0
backlog 1
\end{verbatim} 

Подробности о правилах Audit и скрипте augenrules см. на страницах руководств audit.rules(8) и augenrules(8). 


\subsection{Чтение файлов журнала audit}
По умолчанию, система Audit хранит записи журнала в файле /var/log/audit/audit.log; при включенной ротации файлов журнала, файлы audit.log хранятся в том же каталоге.

Следующее правило заносит в журнал каждую попытку чтения или изменения файла /etc/ssh/sshd\_config
\begin{verbatim}
-w /etc/ssh/sshd_config -p warx -k sshd_config
\end{verbatim} 

При работающем демоне auditd следующая команда создаст, например, новое событие в файле журнала Audit: 
\begin{verbatim}
$ cat /etc/ssh/sshd_config
\end{verbatim} 

В файле audit.log это событие выглядит следующим образом:

\begin{verbatim}
 type=SYSCALL msg=audit(1364481363.243:24287): arch=c000003e syscall=2 success=no exit=-13 a0=7fffd19c5592 a1=0 a2=7fffd19c4b50 a3=a items=1 ppid=2686 pid=3538 auid=1000 uid=1000 gid=1000 euid=1000 suid=1000 fsuid=1000 egid=1000 sgid=1000 fsgid=1000 tty=pts0 ses=1 comm="cat" exe="/bin/cat" subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key="sshd_config"
type=CWD msg=audit(1364481363.243:24287):  cwd="/home/shadowman"
type=PATH msg=audit(1364481363.243:24287): item=0 name="/etc/ssh/sshd_config" inode=409248 dev=fd:00 mode=0100600 ouid=0 ogid=0 rdev=00:00 obj=system_u:object_r:etc_t:s0
type=PROCTITLE msg=audit(1364481363.243:24287) : proctitle=636174002F6574632F7373682F737368645F636F6E666967
\end{verbatim} 

Вышеуказанное событие состоит из четырех записей с одинаковой меткой времени и серийным номером. Записи всегда начинаются с type= keyword. Каждая запись состоит из нескольких пар имя=значение, разделённых пробелом или запятой


\subsection{Выполнение поиска в файлах журнала audit}
Утилита ausearch предоставляет возможность поиска конкретных событий в файлах журнала Audit. По умолчанию, ausearch выполняет поиск в файле /var/log/audit/audit.log. С помощью команды \textbf{ausearch <параметры> -if имя\_файла} можно указать другой файл. Указание нескольких параметров в одной команде ausearch равнозначно использованию оператора AND между типами полей и оператора OR между несколькими вхождениями одного и того же типа поля.


\paragraph{Пример: использование ausearch для поиска по файлам журнала Audit}

Чтобы найти в файле /var/log/audit/audit.log неудачные попытки входа в систему, используйте следующую команду:
\begin{verbatim}
 # ausearch --message USER_LOGIN --success no --interpret
\end{verbatim} 

Чтобы найти все изменения в учётной записи, изменения группы и роли: 
\begin{verbatim}
 # ausearch -m ADD_USER -m DEL_USER -m ADD_GROUP -m USER_CHAUTHTOK -m DEL_GROUP -m CHGRP_ID -m ROLE_ASSIGN -m ROLE_REMOVE -i
\end{verbatim} 

Чтобы найти все действия входа в систему, выполненные конкретным пользователем с пользовательским ID (auid), используйте следующую команду:
\begin{verbatim}
# ausearch -ua 1000 -i
\end{verbatim} 

Чтобы найти все неудачные системные вызовы со вчерашнего дня по настоящее время:
\begin{verbatim}
 # ausearch --start yesterday --end now -m SYSCALL -sv no -i
\end{verbatim} 

Полный список всех возможностей ausearch смотрите в странице руководства ausearch(8). 


\subsection{Создание отчётов с помощью утилиты aureport}
Как можно было убедиться в разделе «Чтение файлов журнала audit», файлы журнала Audit записываются в машиночитаемом формате. Для создания на их основе отчётов и удобства чтения администратором существует утилита \textbf{aureport}.

Утилита aureport предназначена для создания сводки и отчётов, напечатанных столбцами, о событиях, записанных в файлах журнала Audit. По умолчанию, для создания отчёта утилита обращается к файлам в каталоге  /var/log/audit/. Чтобы указать другой файл, на основе которого нужно создать отчёт, укажите в качестве параметра команды «-if имя\_файла»
⁠

\paragraph{Пример: использование aureport для создания отчёта Audit }

Чтобы создать отчёт на основе событий, заносимых в журнал аудита в течение последних трёх дней, исключая текущий, используйте команду:
\begin{verbatim}
 # aureport --start 04/08/2013 00:00:00 --end 04/11/2013 00:00:00
\end{verbatim} 

Чтобы создать отчёт о всех событиях исполнения файлов, используйте команду:
\begin{verbatim}
# aureport -x
\end{verbatim} 

Чтобы создать сводку на базе отчёта о событиях исполняемых файлов, полученного выше:
\begin{verbatim}
 # aureport -x --summary
\end{verbatim} 

Чтобы создать сводный отчёт о сбойных событиях для всех пользователей, используйте команду:
\begin{verbatim}
# aureport -u --failed --summary -i
\end{verbatim} 

Чтобы создать сводный отчёт всех неудачных попытках входа для каждого системного пользователя, используйте следующую команду:
\begin{verbatim}
# aureport --login --summary -i
\end{verbatim} 

Чтобы создать отчёт на базе поиска ausearch всех событий доступа к файлам для пользователя с ID 1000, используйте следующую команду:
\begin{verbatim}
 # ausearch --start today --loginuid 1000 --raw | aureport -f --summary
\end{verbatim} 

Чтобы создать отчёт обо всех запрошенных файлах Audit и о временном промежутке, в который происходили журналируемые в них события, используйте следующую команду:
\begin{verbatim}
# aureport -t
\end{verbatim} 

Полный список всех возможностей aureport смотрите в странице руководства aureport(8) 

Документация и страницы руководств по системе Audit, которые можно найти в установленной ОС ROSA Enterprise Linux Server:  

Документацию пакета audit можно найти в каталоге /usr/share/doc/audit/. 

\textbf{⁠Страницы руководств:}
\begin{itemize}
 \item audispd.conf(5)
\item auditd.conf(5)
\item ausearch-expression(5)
\item audit.rules(7)
\item audispd(8)
\item auditctl(8)
\item auditd(8)
\item aulast(8)
\item aulastlog(8)
\item aureport(8)
\item ausearch(8)
\item ausyscall(8)
\item autrace(8)
\item auvirt(8)
\end{itemize}



\subsection{Аудит системы: практические примеры}

\so{Условие 1:} \textbf{Должна осуществляться идентификация и проверка подлинности субъектов доступа при входе в систему по паролю условно-постоянного действия длиной не менее 8 (восьми) буквенно-цифровых символов}

\textbf{Выполнение проверки:}

Задать правила паролей (минимум 8 буквенно-цифровых символов), для этого в файле /etc/pam.d/password-auth добавить в конец строки:
\begin{verbatim}
password    requisite     pam_cracklib.so try_first_pass retry=3 type=
\end{verbatim}  
параметры:
\begin{verbatim}
dcredit=-1 lcredit=-1 minlen=8\end{verbatim} 

Создать пользователя user с произвольным паролем. Для этого понадобится повысить права до учетной записи суперпользователя root.

Войти в ОС пользователем user, попытаться сменить пароль в текстовой консоли с помощью команды passwd на:
\begin{enumerate}
\item пароль менее чем из 8 символов,
\item пароль только из цифр,
\item пароль только из букв,
\item корректный пароль из не менее чем 8 буквенно-цифровых символов.
\end{enumerate}


Убедиться, что пользователь не может использовать пароль отличающийся от заданных политикой безопасности.

\begin{itemize}
 \item войти в ОС созданным пользователем, введя корректный пароль данного пользователя;
\item повысить права до  до учетной записи суперпользователя root и провести анализ файла журнала безопасности /var/log/secure на предмет наличия в нем данных идентификации данного пользователя.
\end{itemize}



Анализ  файла журнала можно провести, используя утилиты командной строки, такие как cat или tail, или графический редактор текстовых файлов Leafpad.
Мы должны увидеть запись вида:
\begin{verbatim}
 Jun 21 15:18:23 cobaltsx2 lxdm-binary: pam_unix(lxdm:session): session opened for user user by (uid=0)
\end{verbatim} 

\so{Условие 2:} \textbf{Должна осуществляться идентификация терминалов, ЭВМ, узлов сети ЭВМ по логическим именам}

Данные по идентификации узла, проводящего подключение к данной ОС можно посмотреть  в логах подключения:

Для настройки идентификации узлов сети по логическим именам, необходимо настроить службу ДНС и использовать статическую ip адресацию. В этом случае обращение к любому сетевому узлу будет по его логическому имени.

При этом, если есть факт попытки доступа по тому или иному протоколу, всегда есть возможность провести идентификацию обратившегося объекта командой 
\textbf{nslookup}.

Например, при подлючении по протоколу ssh в логе: /var/log/secure, командой
\begin{verbatim}
 tail -f /var/log/secure
\end{verbatim} 

Вывод лога будет таким:
\begin{verbatim}
 Jun 28 08:59:19 srv1 sshd[22396]: Accepted publickey for user from 192.168.10.1 port 59894 ssh2
\end{verbatim} 

Чтобы идентифицировать объект с ip адресом  192.168.10.1 нужно выполнить команду:
\begin{verbatim}
nslookup  192.168.10.1
\end{verbatim} 

Эта команда выдаст логическое имя узла сети в виде:
\begin{verbatim}
 1.10.168.192.in-addr.arpa       name = srv1.test.ru.
\end{verbatim} 

\so{Условие 3:} \textbf{Должна осуществляться регистрация входа (выхода) субъектов доступа в систему (из системы).}

В параметрах регистрации указываются:
\begin{enumerate}
\item Дата и время входа (выхода) субъекта доступа в систему (из системы);
\item Результат попытки входа: успешная или неуспешная - несанкционированная;
\item Идентификатор (код или фамилия) субъекта, предъявленный при попытке доступа
\end{enumerate}


Выполнение проверки:

\begin{itemize}
\item войти в ОС ранее  созданным пользователем user, введя корректный пароль данного пользователя;
\item выйти из системы;
\item провести попытку войти в ОС созданным пользователем, введя не корректный пароль для данного пользователя;
\item провести попытку войти в ОС не существующим в системе пользователем, введя произвольный пароль;
\item провести анализ файла журнала безопасности /var/log/secure на предмет наличия в нем параметров регистрации входа/выхода с нужными параметрами.\end{itemize}



Пример журнала регистрации:
\begin{verbatim}
 Jun 22 15:04:51 cobaltsx1 lxdm-binary: pam_unix(lxdm:session): session opened for user ozherelev by (uid=0)
\end{verbatim} 

\so{Условие 4:} \textbf{Должна осуществляться регистрация запуска (завершения) программ и процессов (заданий, задач), предназначенных для обработки защищаемых файлов.} В параметрах регистрации указываются:
\begin{enumerate}
\item Дата и время запуска; 
\item Имя (идентификатор) программы (процесса, задания); 
\item Идентификатор субъекта доступа, запросившего программу (процесс, задание); 
\item Результат запуска (успешный, неуспешный - несанкционированный)
\end{enumerate}



Данный пункт требований выполняется благодаря системе аудита \textbf{auditd}.

Это механизм, имеющий широкие возможности настройки.

Чтобы включить контроль запуска приложений, нужно  в конец файла /etc/audit/audit.rules добавить сточку  следующую строку
\begin{verbatim}
 -a exit,always -F arch=b64 -S execve -k EXE
\end{verbatim} 
 Далее перезапустим сервис аудита командой:
 
\begin{verbatim}
# service auditd restart
\end{verbatim} 
Теперь в файл аудита /var/log/audit/audit.log будут добавлять события запуска любого приложения. 

Можно провести операцию запуска сервиса Postgresql или любого другого.

Посмотреть события можно с помощью команды \textbf{ausearch}, также имеющую массу фильтров. Если  мы хотим посмотреть события, связанные с нашим защищаемым файлом, нужно воспользоваться командой:

\textbf{ausearch -k EXE}
Если нас, например, интересуют события за определенное время:
\begin{verbatim}
ausearch -k EXE --start 06/15/16 10:00 --end 06/15/16 12:00
\end{verbatim} 

Например запуск СУБД Postresql будет выглядеть так:
\begin{verbatim}
time->Tue Jun 21 16:05:12 2016
type=PATH msg=audit(1466514312.938:9311): item=1 name=(null) inode=263134 dev=fc:02 mode=0100755 ouid=0 ogid=0 rdev=00:00 nametype=NORMAL
type=PATH msg=audit(1466514312.938:9311): item=0 name="/usr/pgsql-9.5/bin/postmaster" inode=280558 dev=fc:02 mode=0100755 ouid=0 ogid=0 rdev=00:00 nametype=NORMAL
type=CWD msg=audit(1466514312.938:9311):  cwd="/var/lib/pgsql"
type=EXECVE msg=audit(1466514312.938:9311): argc=3 a0="/usr/pgsql-9.5/bin/postmaster" a1="-D" a2="/var/lib/pgsql/9.5/data"
type=SYSCALL msg=audit(1466514312.938:9311): arch=c000003e syscall=59 success=yes exit=0 a0=1007930 a1=1007890 a2=1016e50 a3=7fff575d8260 items=2 ppid=1 pid=3912 auid=500 uid=26 gid=26 euid=26 suid=26 fsuid=26 egid=26 sgid=26 fsgid=26 tty=(none) ses=1059 comm="postmaster" exe="/usr/pgsql-9.5/bin/postgres" key="EXE"
\end{verbatim} 

\so{Условие 5:} \textbf{Генерация данных аудита:}

ФБО должны быть способны генерировать запись аудита для следующих событий, потенциально подвергаемых аудиту:

\begin{itemize}
 \item Обработка отказов аутентификации:
 \begin{itemize}
  \item достижение ограничения для неуспешных попыток аутентификации и соответствующие предпринятые действия (например, отключение терминала), а также, при необходимости, последующие действия, направленные на восстановление нормального состояния (например, предоставление возможности заново работать с терминалом)
\item дата и время события, тип события, идентификатор субъекта и результат события (успешный или неуспешный)
 \end{itemize}
\end{itemize}

Отказы аутентификации записываются в файл /var/log/secure, где и могут быть проанализированы, например с помощью команд \textbf{tail} или \textbf{cat}.

Для настройки ограничения по неуспешным попыткам доступа необходимо в файл /etc/pam.d/system-auth и /etc/pam.d/password-auth добавить 2 строки:

В секцию auth:
\begin{verbatim}
 auth        required      pam_tally2.so  file=/var/log/tallylog deny=3 even_deny_root unlock_time=1200
\end{verbatim} 

где 
\begin{itemize}
\item deny=3 задает количество неуспешных попыток входа пользователя до его блокировки
\item unlock\_time — время, на которое блокируется пользователь
\end{itemize}


В секцию account:
\begin{verbatim}
 account     required      pam_tally2.so 
\end{verbatim} 

Посмотреть данные по неуспешным входам пользователей можно с помощью команды \textbf{pam\_tally2}

Проведение проверки:

Пользователь user при попытке входа в ОС вводит некорректный пароль 3 раза

После чего пытается войти в ОС введя корректный пароль, ОС при этом должна блокировать его вход. В файле журнала /var/log/secure при этом появляются записи вида:
\begin{verbatim}
Jun 22 12:46:52 srv1 lxdm-binary: pam_tally2(lxdm:auth): user user (500) tally 3, deny 3
\end{verbatim} 

\so{Условие 6:} \textbf{Генерация данных аудита:}

Управление атрибутами безопасности: 

- все изменения значений атрибутов безопасности.

дата и время события, тип события, идентификатор субъекта и результат события (успешный или неуспешный)

Атрибуты безопасности ОС задаются в различных конфигурационных файлах системы в каталоге /etc. Для аудита изменения значений атрибутов нужно установить аудит на данные файлы.

Предположим что мы хотим вести аудит изменения конкретного защищаемого файла /boot/grub/grub.conf (настойка опций загрузки ОС), для этого внесем следующую строку в конец файла /etc/audit/audit.rules:
\begin{verbatim}
-w /boot/grub/grub.conf -p rwa -k MON_GRUB
\end{verbatim} 

Далее перезапустим сервис аудита командой:
\begin{verbatim}
# service auditd restart
\end{verbatim} 

Теперь в файл аудита /var/log/audit/audit.log будут добавлять события чтения записи или изменения атрибутов данного файла. 

Проведем операции чтения и изменения данного файла.

Посмотреть события можно с помощью команды ausearch, также имеющую массу фильтров. Если  мы хотим посмотреть события связанные с нашим защищаемым файлом, нужно воспользоваться командой:
\begin{verbatim}
ausearch -k MON_GRUB
\end{verbatim} 

Вывод данной команды будет выглядеть следующим образом 
\begin{verbatim}
time->Wed Jun 22 12:52:00 2016
type=PATH msg=audit(1466589120.363:3381): item=0 name="/boot/grub/grub.conf" inode=658691 dev=fc:02 mode=0100600 ouid=0 ogid=0 rdev=00:00 nametype=NORMAL
type=CWD msg=audit(1466589120.363:3381):  cwd="/boot/grub"
type=SYSCALL msg=audit(1466589120.363:3381): arch=c000003e syscall=89 success=no exit=-22 a0=7fff38c01ff0 a1=7fff38c02ff0 a2=fff a3=7fff38c03ff0 items=1 ppid=4503 pid=4580 auid=500 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts0 ses=3 comm="mc" exe="/usr/bin/mc" key="MON_GRUB"
\end{verbatim} 

\so{Условие 7:} \textbf{Отказы аутентификации}

Обработка отказов аутентификации

ФБО должны обнаруживать, когда произойдет определенное уполномоченным администратором число неуспешных попыток аутентификации

Число неуспешных попыток аутентификации задается параметром «deny» в файле /etc/pam.d/system-auth в строке:
\begin{verbatim}
auth        required      pam_tally2.so  file=/var/log/tallylog deny=3 even_deny_root unlock_time=1200
\end{verbatim} 
где 
\begin{itemize}
\item \textbf{deny=3} задает количество неуспешных попыток входа пользователя до его блокировки
\item \textbf{unlock\_time} — время, на которое блокируется пользователь, причем если убрать параметр unlock\_time, по пользователь не сможет авторизоваться, пока администратор вручную не сбросит количество неуспешных попыток входа.
\end{itemize}


Обнаружить текущее количество неуспешных попыток входа можно командой:
\begin{verbatim}
pam_tally2
\end{verbatim} 


\section{Межсетевые экраны. firewalld}

Демон firewalld предоставляет динамически управляемый сетевой экран с поддержкой сетевых «зон» для присвоения уровня доверия сети и связанным с ней соединениям и интерфейсам. Firewalld поддерживает параметры IPv4 и Ipv6, мосты Ethernet и IP set а постоянные параметры конфигураций в нём отделены от текущей рабочей среды. Также имеется интерфейс для прямого добавления правил сетевого экрана для служб или приложений. Вся связь с сетевым экраном выполняется с помощью D-Bus.

\subsection{Введение в firewalld}

Для ускорения действий, изменяющих набор правил, демон firewalld по умолчанию использует команды restore из iptables, ip6tables и ebtables . Обычные команды используются, если в файле firewalld.conf для параметра IndividualCalls указано значение «yes» или же если используется запасное решение, когда правила нельзя применить с помощью команд restore. Применение обычных команд значительно замедляет работу.

Служба межсетевого экрана, предоставляемая firewalld, является скорее динамической, чем статической, поскольку изменения в конфигурации можно внести в любой момент, и они тут же начинают действовать. Необходимость сохранять или применять изменения отсутствует. Непреднамеренный разрыв существующих сетевых соединений невозможен, так как ни одна из составных частей сетевого экрана не нуждается в перезагрузке.

В составе программы поставляется консольный клиент firewall-cmd. С его помощью можно вносить постоянные и не-постоянные динамические изменения во время работы, что объясняется в man firewall-cmd(1). Постоянные изменения нужно применять так, как это объясняется в странице руководства firewalld(1). Обратите внимание, что команда firewall-cmd может выполняться как пользователем root, так и пользователем-администратором, другими словами, членом группы wheel. В последнем случае команда проходит авторизацию через механизм polkit.


Для внесения изменений в постоянное окружение, консольный клиент firewall-offline-cmd может использоваться только пользователем root. Клиент не общается напрямую с firewalld, но использует часть firewalld core и внутренние процессы ввода/вывода для изменения конфигурации. Не рекомендуется работать с этим инструментом при активном сетевом экране. Его можно использовать, но изменения, внесённые с помощью  firewall-offline-cmd не сразу применяются к firewalld. Изменения в постоянном окружении будут применены после того, как firewalld обнаружит изменения в файлах на файловой системе. Команду firewall-offline-cmd используют во время установки ОС для настройки межсетевого экрана, также её можно использовать на этапе сразу после установки для изменения параметров межсетевого экрана перед загрузкой только что установленной системы.


Приложение firewall-applet может быстро запустить окно параметров NetworkManager для используемых сетевых соединений. Внести изменения в присвоенную зону межсетевого экрана можно во вкладке Общее. Это приложение по умолчанию не устанавливается в ОС ROSA Enterprise Linux Server. Параметры  firewalld хранятся в нескольких файлах формата XML в каталогах /usr/lib/firewalld/ и /etc/firewalld, что предоставляет значительную гибкость в управлении, т.к. файлы можно редактировать, в них можно писать, можно сохранять их резервные копии, использовать их в качестве шаблонов для других установок и так далее. Конфигурация в каталоге /usr/lib/firewalld/ является конфигурацией по умолчанию, а конфигурация в каталоге /etc/firewalld/ является частной конфигурацией конкретной системы.

Все приложения обмениваются информацией с firewalld при помощи интерфейса D-Bus.


\subsection{Сравнение firewalld с system-config-firewall и iptables}

Основные отличия между firewalld и iptables (а также ip6tables):

\begin{itemize}
\item Параметры службы iptables располагаются в каталогах /etc/sysconfig/iptables и /etc/sysconfig/ip6tables, а firewalld хранит их в нескольких файлах формата XML в каталогах /usr/lib/firewalld/ и /etc/firewalld/. Обратите внимание, что по умолчанию в ОС ROSA Enterprise Linux Server файл /etc/sysconfig/iptables отсутствует, так как по умолчанию устанавливается firewalld.

\item В службе iptables каждое отдельное изменение означает сброс всех старых правил и прочтение всех новых правил из /etc/sysconfig/iptables, в то время как в firewalld повторное создание новых правил отсутствует. Применяются только отличия. Как следствие, параметры firewalld можно менять на ходу без разрыва существующих соединений.

\item Для общения с пакетным фильтром в ядре обе программы используют iptables tool.
\end{itemize}

\so{Внимание}

Firewalld не может импортировать  параметры межсетевого экрана из файлов /etc/sysconfig/ip*tables. Для импорта параметров lokkit или system-config-firewall используйте firewall-offline-cmd и файл /etc/sysconfig/system-config-firewall. Файлы пользовательских правил нельзя импортировать в firewalld. Импортируемые параметры применяются к зоне по умолчанию.



\subsection{Стек межсетевого экрана}

\subsubsection{Что такое сетевые зоны}
Firewalld используется для разделения сетей на различные зоны на базе уровня доверия пользователя к интерфейсам и трафику внутри сети. NetworkManager информирует firewalld о том, к какой зоне принадлежит интерфейс. Зону, присвоенную интерфейсу, можно изменить с помощью  NetworkManager или с помощью утилиты firewall-config. Если интерфейс контролируется программой NetworkManager, а пользователь изменит зону этого интерфейс с помощью firewall-cmd, firewall-offline-cmd или firewall-config, то этот запрос перенаправляется программе NetworkManager и демоном firewalld он не обрабатывается. 


Параметры зон в каталоге /etc/firewalld/ представляют собой диапазон предварительно установленных значений, которые можно быстро применить к сетевому интерфейсу. Эти параметры коротко описываются ниже.

\begin{itemize}
 \item  \textbf{drop}\\
Все входящие сетевые пакеты сбрасываются без ответа. Возможны только исходящие соединения
\item \textbf{block}\\
Все исходящие сетевые соединения отклоняются с сообщением icmp-host-prohibited для Ipv4 и icmp6-adm-prohibited для Ipv6. Разрешаются только сетевые соединения, инициированные внутри системы.
\item \textbf{public}\\
Для работы в зонах общего использования. Машинам в сети мы не доверяем, они причинят нам вред. Принимаются только конкретные входящие соединения. 
\item \textbf{external}\\
Для использования во внешних с включённым маскарадингом, особенно для роутеров. Машинам в сети мы не доверяем, они причинят нам вред. Принимаются только конкретные входящие соединения.
\item \textbf{dmz}\\
Для машин в собственной демилитаризованной зоне с общим доступом и  ограниченным доступом в нашу внутреннюю сеть. Принимаются только конкретные входящие соединения.
\item \textbf{work}\\
Для использования в рабочих зонах. Мы в основном доверяем машинам в сети, они не причинят нам вред. Принимаются только конкретные входящие соединения
\item \textbf{home}\\
Для использования  дома. Мы в основном доверяем машинам в сети, они не причинят нам вред. Принимаются только конкретные входящие соединения.
\item \textbf{internal}\\
Для использования  во внутренних сетях. Мы в основном доверяем машинам в сети, они не причинят нам вред. Принимаются только конкретные входящие соединения.
\item \textbf{trusted}\\
Все сетевые соединения принимаются. 
\end{itemize}

Одну из этих зон можно назначить зоной по умолчанию. При добавлении интерфейсных подключений в NetworkManager, они присваиваются зоне по умолчанию. При установке системы зоной по умолчанию в firewalld назначается зона public.

\subsubsection{Выбор сетевой зоны}
Зонам присвоены говорящие сами за себя названия, позволяющие пользователям быстро принять разумное решение. В соответствии с конкретными потребностями и оценками рисков, администратор должен изучить параметры по умолчанию и отключить ненужные службы.

Имена зон и значения параметров являются рекомендациями, которые можно изменить в соответствии с потребностями.  Встроенную зону нельзя удалить, но можно откатить параметры зоны к исходным значениям по умолчанию, загрузив их в составе постоянной конфигурации firewall-config или firewall-cmd.


\subsubsection{Что такое предварительно настроенные службы}

Служба может представлять из себя: 

\begin{enumerate}
 \item список локальных портов, протоколов, исходных портов и точек назначения
 \item список вспомогательных модулей межсетевого экрана, автоматически загружаемых при активации службы. 
\end{enumerate}


Использование предварительно настроенных служб облегчает пользователю включение и отключение доступа к службе. Использование предварительно настроенных служб или служб, настроенных пользователем, в отличие от открытия портов или диапазонов портов, облегчает выполнение административных задач. 

Параметры настройки служб и общая информация о файлах описывается на странице руководства firewalld.service(5). Cлужбы конкретизируются с помощью отдельных конфигурационных файлов  в формате XML, которые именуются согласно следующему формату: service-name.xml. В firewalld имена протоколов предпочитаются именам служб или приложений.


Чтобы просмотреть список доступных в системе служб, введите следующую команду:
\begin{verbatim}
 $ firewall-cmd --get-services
\end{verbatim} 

Чтобы просмотреть параметры службы, используйте следующую команду:
\begin{verbatim}
 $ firewall-cmd --info-service=service-name
\end{verbatim} 

Чтобы получить список только предварительно настроенных доступных служб, введите:
\begin{verbatim}
 $ ls /usr/lib/firewalld/services/
\end{verbatim} 


\so{Внимание}
Для просмотре списка файлов в /usr/lib/firewalld не требуются привилегии пользователя root. После добавления частных пользовательских файлов не забудьте соответственно изменить их атрибуты.

Файлы в каталоге /usr/lib/firewalld/services/ запрещено редактировать. Можно редактировать только файлы из каталога /etc/firewalld/services/. Чтобы получить список системных служб, или служб, созданных пользователем, введите команду с правами пользователя root: 
\begin{verbatim}
# ls /etc/firewalld/services/
\end{verbatim} 

Добавлять и удалять службы можно с помощью графической утилиты firewall-config, а также утишит firewall-cmd и firewall-offline-cmd. Кроме того, можно редактировать файлы XML в каталоге /etc/firewalld/services/. если пользователь не добавлял иди не изменял службу, то соответствующий XML файл будет отсутствовать в каталоге /etc/firewalld/services/. При необходимости  добавить или изменить службу, файлы из /usr/lib/firewalld/services/ можно использовать в качестве шаблонов.

Чтобы добавить новую службу в консоли, используйте firewall-cmd, или, в случае если межсетевой экран не активен, firewall-offline-cmd. Для добавления новой и пустой службы введите следующую команду:
\begin{verbatim}
$ firewall-cmd --permanent --new-service=service-name
\end{verbatim} 

Для добавления новой службы на базе локального файла, введите:
\begin{verbatim}
$ firewall-cmd --permanent --new-service-from-file=service-name.xml
\end{verbatim} 

Имя службы можно изменить с помощью дополнительного параметра \textbf{--name=<имя-службы>}.

Сразу после изменений параметров службы, обновлённая копия службы помещается в каталог /etc/firewalld/services/. чтобы скопировать службу вручную, введите с правами пользователя root: 
\begin{verbatim}
# cp /usr/lib/firewalld/services/service-name.xml /etc/firewalld/services/service-name.xml                                                                                          \end{verbatim} 

Firewalld в первую очередь загружает службы из каталога /usr/lib/firewalld/services. Если файлы размещаются в /etc/firewalld/services и отвечают требованиям, то указанные в них значения будут иметь приоритет над аналогичными файлами из /usr/lib/firewalld/services. Файлы из /usr/lib/firewalld/services будут использованы сразу, как только совпадающие файлы будут удалены из /etc/firewalld/services или если демону firewalld было указано загрузить значения этой службы по умолчанию. Эти правила применяются только к постоянному окружению.  Для реализации таких откатов параметров в работающем окружении также требуется перезагрузка.



\subsubsection{Что такое прямой интерфейс}
Прямой интерфейс firewalld позволяет напрямую передавать правила сервисам iptables, ip6tables и ebtables. В первую очередь он предназначен для использования приложениями. Неопытным администраторам, слабо знающим iptables, не рекомендуется использовать прямой интерфейс, так как это может привести к опасным прорехам в межсетевом экране. Во всё время использования составных частей отслеживаемого интерфейса ещё возможно запросить firewalld показать изменения, сделанные приложением, использующим этот режим. Не отслеживаемый сквозной (passthrough) режим предназначен только для служб, полностью контролирующих свой набор правил, таких, как libvirt и docker. Прямой интерфейс реализуется добавлением параметра --direct команде firewall-cmd.

Режим прямого интерфейса предназначен для добавления конкретных правил межсетевого экрана службами или приложениями в работающем режиме. Правила можно сделать постоянными, добавив параметр \textit{\textbf{--permanent}}, т.е. использовав команду firewall-cmd --permanent --direct или же внеся изменения в файл /etc/firewalld/direct.xml. Если правила не были сделаны постоянными, то их необходимо применять каждый раз, когда от firewalld  через D-Bus  приходит сообщение start, restart или reload. Прямые правила также можно использовать в цепочках конкретных зон.

\subsection{Установка firewalld}
В ROSA Enterprise Linux Server firewalld устанавливается по умолчанию. При необходимости в этом можно убедиться, ведя следующую команду с правами пользователя root: 
\begin{verbatim}
# yum install firewalld
\end{verbatim} 
При необходимости установки графического инструмента настройки firewall-config, введите с правами пользователя root:
\begin{verbatim}
# yum install firewall-config
\end{verbatim} 

Чтобы установить дополнительный firewall-applet, введите с правами пользователя root: 
\begin{verbatim}
# yum install firewall-applet
\end{verbatim} 


\subsection{⁠Остановка firewalld}
Чтобы остановить работу firewalld, введите с правами пользователя root:
\begin{verbatim}
# systemctl stop firewalld
\end{verbatim} 

Чтобы предотвратить автоматический запуск firewalld при загрузке системы, введите с правами пользователя root: 
\begin{verbatim}
# systemctl disable firewalld
\end{verbatim} 

Чтобы убедиться что firewalld не будет стартовать при доступе к интерфейсу D-Bus, а также если другим службам необходим firewalld, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# systemctl mask firewalld
\end{verbatim} 


\subsection{Запуск firewalld}
Для запуска firewalld введите следующую команду с правами пользователя root:
\begin{verbatim}
# systemctl unmask firewalld
# systemctl start firewalld
\end{verbatim} 

Для автоматического запуска firewalld при загрузке системы, введите следующую команду с правами пользователя root:
\begin{verbatim}
# systemctl enable firewalld
\end{verbatim} 


\subsubsection{Проверка статуса firewalld}
Чтобы проверить, запущен ли firewalld, введите следующую команду:
\begin{verbatim}
$ systemctl status firewalld
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled)
   Active: active (running) since Tue 2016-10-11 09:15:58 CEST; 2 days ago
     Docs: man:firewalld(1)
 Main PID: 721 (firewalld)
   CGroup: /system.slice/firewalld.service
           └─721 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid

Oct 11 09:15:57 localhost.localdomain systemd[1]: Starting firewalld - dynami...
Oct 11 09:15:58 localhost.localdomain systemd[1]: Started firewalld - dynamic...
Hint: Some lines were ellipsized, use -l to show in full.
\end{verbatim} 

Дополнительно, чтобы проверить связь firewall-cmd с демоном, введите: 
\begin{verbatim}
$ firewall-cmd --state
running
\end{verbatim} 


\subsection{Настройка firewalld}
Службу firewall, реализованную в виде демона firewalld, можно настроить с помощью графического инструмента firewall-config, с помощью консольных утилит firewall-cmd и firewall-offline-cmd, а также с помощью редактирования конфигурационных файлов в формате XML.



\subsubsection{Настройка Firewall с помощью консольной утилиты firewall-cmd}
Консольная утилита firewall-cmd является частью приложения firewalld, устанавливаемой по умолчанию. Проверить её наличие в системе можно с помощью проверки версии или запросив вывод с параметром help. Для проверки версии введите:
\begin{verbatim}
 $ firewall-cmd --version
\end{verbatim} 

Для вывода справки введите:
\begin{verbatim}
$ firewall-cmd --help
\end{verbatim}

Выше были перечислены только некоторые команды; полный список см. на странице руководства firewall-cmd(1)


\so{Внимание}
Чтобы сделать результаты команды долговременными или постоянными, добавляйте ко всем командам (кроме команд с параметром \textit{\textbf{--direct}}, которые по своей природе являются временными) параметр \textit{\textbf{--permanent}}. Обратите внимание, что это не только означает, что изменения будут постоянными, но что также изменения вступят в силу только после перезагрузки firewalld,  перезапуска службы или после перезагрузки всей системы. Изменения, внесённые с помощью команды \textbf{firewall-cmd} без параметра \textit{\textbf{--permanent}} вступают в силу немедленно, но действуют только до следующей перезагрузки firewall, системной перезагрузки или перезапуска службы firewalld. Перезагрузка firewalld сама по себе не прерывает соединений. Но не забывайте, что при этом сбрасываются все временные изменения.

Чтобы результаты команды применились немедленно и также стали постоянными, введите команду дважды: один раз с параметром \textit{\textbf{--permanent}} и один раз без него. Причиной этого является то, что перезагрузка firewalld занимает больше времени, чем повторное выполнение команды, из-за необходимости перезагрузки всех файлов конфигурации и повторного создания всей конфигурации межсетевого экрана. Во время перезагрузки политика для встроенных цепочек меняется на \textbf{DROP} из соображений безопасности, а в конце меняется на \textbf{ACCEPT}. Во время процесса перезагрузки возможны перерывы в обслуживании.



\subsection{Архитектура firewalld}

\so{Важно}
Все параметры изменения привязки зон к интерфейсам, находящимся под контролем NetworkManager, перенаправляется программе NetworkManager. Если запрос к NetworkManager будет успешен, то эти изменения не применяются к конфигурации firewalld.  Аналогичная ситуация происходит и при применении параметра \textit{\textbf{--permanent}}.

Для интерфейсов, не находящихся под контролем NetworkManager, изменение применяется к конфигурации firewalld. Если интерфейс используется файлом \textbf{ifcfg}, то параметр \textbf{ZONE=} этого файла адаптируется для обеспечения однородности конфигурации firewalld и файла \textbf{ifcfg}. Если интерфейс используется несколькими файлами ifcfg, тогда используется первый из них.

Для таких параметров конфигурации, как зона по умолчанию, при использовании консольных и графических утилит разница между работающим окружением и постоянным окружением отсутствует.


\subsubsection{Просмотр параметров межсетевого экрана в консольном режиме}

Чтобы получить текстовую информацию о состоянии firewalld, введите следующую команду:
\begin{verbatim}
$ firewall-cmd --state
\end{verbatim} 

Чтобы просмотреть список активных зон со списком присвоенных им в данный момент интерфейсов, введите следующую команду: 
\begin{verbatim}
 $ firewall-cmd --get-active-zones
public
  interfaces: em1
\end{verbatim} 

Чтобы узнать, какой зоне присвоен интерфейс, например, em1, введите следующую команду:
\begin{verbatim}
 $ firewall-cmd --get-zone-of-interface=em1
Public
\end{verbatim} 

Чтобы узнать все интерфейсы, присвоенные зоне, например, зоне public, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=public --list-interfaces
em1 wlan0
\end{verbatim} 
Эта информация получается от NetworkManager и показывает только интерфейсы, без соединений.


Чтобы узнать параметры зоны, например, зоны public, введите следующую команду с правами пользователя root: 
\begin{verbatim}
 # firewall-cmd --zone=public --list-all
public
  interfaces: 
  services: mdns dhcpv6-client ssh
  ports: 
  forward-ports: 
  icmp-blocks: source-quench
\end{verbatim} 

Чтобы узнать информацию по зоне, используйте параметр \textbf{--info-zone}. Чтобы получить подробный вывод с описаниями и короткими описаниями, дополнительно используйте параметр \textbf{-v}.
\begin{verbatim}
 # firewall-cmd --info-zone=public
public (active)
  target: default
  icmp-block-inversion: no
  interfaces: em1
  sources: 
  services: dhcpv6-client mdns ssh
  ports: 
  protocols: 
  masquerade: no
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules:
\end{verbatim} 

Чтобы просмотреть с список текущих загруженных служб, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --get-services
cluster-suite pop3s bacula-client smtp ipp radius bacula ftp mdns samba dhcpv6-client dns openvpn imaps samba-client http https ntp vnc-server telnet libvirt ssh ipsec ipp-client amanda-client tftp-client nfs tftp libvirt-tls
\end{verbatim} 

Здесь перечисляются названия предварительно настроенных служб, загруженных из /usr/lib/firewalld/services/, а также всех пользовательских служб, запруженных в настоящее время. Обратите внимание, что сами конфигурационные файлы называются service-name.xml.

Чтобы получить список служб, созданных пользователем, но ещё не загруженных, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --permanent --get-services
\end{verbatim} 

Здесь перечислены все службы, включая службы,  настроенные пользователем в /etc/firewalld/services/, даже если они ещё не загружены.

Чтобы просмотреть параметры службы ftp, введите следующую команду с правами пользователя root: 
\begin{verbatim}
 # firewall-cmd --info-service=ftp
ftp
  ports: 21/tcp
  protocols: 
  source-ports: 
  modules: nf_conntrack_ftp
  destination:
\end{verbatim} 

Чтобы просмотреть параметры в режиме постоянной конфигурации, используйте параметр \textit{\textbf{--permanent}}.


\subsubsection{Изменение параметров межсетевого экрана в консольном режиме}

\paragraph{Сброс всех пакетов (режим паники)}

Чтобы начать сброс всех входящих и исходящих пакетов, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --panic-on
\end{verbatim} 

Все входящие и исходящие пакеты будут сброшены. Активные соединения будут закрыты после периода неактивности; время на выполнение этой операции зависит от установленных значений истечения времени ожидания в конкретном сеансе.
 
Чтобы снова начать передачу входящих и исходящих пакетов, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --panic-off
\end{verbatim} 

После отключения режима паники, установленные соединения снова могут заработать, если режим паники продлился недолгое время. Чтобы узнать, включен или выключен режим паники, введите следующую команду: 
\begin{verbatim}
$ firewall-cmd --query-panic
\end{verbatim} 
При включенном режиме эта команда выведет «yes» со статусом выхода 0. В противном случае будет выведен «no» со статусом выхода 1.

\paragraph{Перезагрузка firewall в консольном режиме}

Чтобы перезагрузить межсетевой экран, не прерывая соединений пользователей (без потери информации о состоянии), введите следующую команду:  
\begin{verbatim}
$ firewall-cmd --reload
\end{verbatim} 


Процесс перезагрузки межсетевого экрана включает в себя перезагрузку всех конфигурационных файлов и создание заново всей конфигурации firewall. Во время перезагрузки политика для встроенных цепочек из соображений безопасности меняется на \textbf{DROP}, а в конце меняется на \textbf{ACCEPT}. Соответственно, во время перезагрузки возможны перерывы в обслуживании. Как вариант, с правами пользователя root пошлите сигнал \textbf{SIGHUP} для перезагрузки межсетевого экрана.

Для перезагрузки межсетевого экрана и прерывания соединений пользователей со сбросом информации о состоянии, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --complete-reload
\end{verbatim} 

Обычно эту команду используют только в случае серьёзных проблем в межсетевом экране. Используйте её, например, при наличии проблем с информацией о состоянии, когда соединение не удаётся установить при корректных правилах для межсетевого экрана.


\paragraph{Добавление интерфейса в зону в консольном режиме}

Для добавление интерфейса в зону (чтобы, например, добавить em1 в зону public), введите следующую команду с правами пользователя root: 

\begin{verbatim}
# firewall-cmd --zone=public --add-interface=em1
\end{verbatim} 
Чтобы сделать это изменение постоянным, повторно введите команду с параметром \textit{\textbf{--permanent}}.


\paragraph{Добавление интерфейса в зону с помощью редактирования файла конфигурации интерфейса}

Чтобы добавить интерфейс в зону с помощью внесения изменений в файл ifcfg-em1 (например, чтобы добавить em1 в зону work), добавьте следующую строку с правами пользователя root: 
\begin{verbatim}
ZONE=work
\end{verbatim} 
Обратите внимание, что если опустить значение параметра ZONE или использовать ZONE= или ZONE='', то будет использована зона по умолчанию.
NetworkManager автоматически выполнит повторное соединение и зона будет соответствующим образом настроена.


\paragraph{Установка параметров зоны по умолчанию с помощью редактирования конфигурационного файла}

С правами пользователя root откройте файл /etc/firewalld/firewalld.conf и внесите следующие изменения:
\begin{verbatim}
# default zone
# The default zone used if an empty zone string is used.
# Default: public
DefaultZone=home
\end{verbatim} 

Перезагрузите firewall, введя следующую команду с правами пользователя root:  
\begin{verbatim}
# firewall-cmd --reload
\end{verbatim} 
Это действие перезагрузит межсетевой экран без потери информации о состоянии (то есть сеансы TCP не будут прерваны), но во время перезагрузки возможен отказ в обслуживании.


\paragraph{Установка зоны по умолчанию в консольном режиме}

Чтобы установить зону по умолчанию (например, public) введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --set-default-zone=public
\end{verbatim} 
Это изменение вступит в силу мгновенно, в этом случае перезагружать межсетевой экран не нужно.


\paragraph{Открытие портов в консольном режиме}
Чтобы получить список всех открытых портов в зоне (например в dmz), введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=dmz --list-ports
\end{verbatim} 
Обратите внимание, что эта команда не покажет портов, открытых в результате команды --add-services.

Чтобы добавить порт в зону (например, разрешить трафик TCP для порта 8080 в зоне dmz), введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=dmz --add-port=8080/tcp
\end{verbatim} 
Чтобы сделать это изменение постоянным, повторно введите команду с параметром \textit{\textbf{--permanent}}.

Чтобы добавить диапазон портов в зону (например, разрешить порты с 5060 до 5061 в зоне public), введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=public --add-port=5060-5061/udp
\end{verbatim} 
Чтобы сделать это изменение постоянным, повторно введите команду с параметром \textit{\textbf{--permanent}}. 


\paragraph{Открытие протоколов в консольном режиме}
Чтобы получить список всех открытых портов в зоне (например, в зоне dmz), введите следующую команду  с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=dmz --list-protocols
\end{verbatim} 
Обратите внимание, что эта команда не покажет протоколов, открытых в результате команды firewall-cmd --add-services.

Для добавления протокола в зону (например, разрешить трафик ESP в зоне dmz) введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=dmz --add-protocol=esp
\end{verbatim} 
Чтобы сделать это изменение постоянным, повторно введите команду с параметром \textit{\textbf{--permanent}}. 


\paragraph{Открытие портов-источников в консольном режиме}
Чтобы получить список всех открытых портов-источников в зоне (например, в зоне dmz), введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=dmz --list-source-ports
\end{verbatim} 
Обратите внимание, что эта команда не покажет потов-источников, открытых в результате команды firewall-cmd --add-services.

Для добавления порта-источника в зону (например, разрешить трафик TCP из порта 8080 в зоне dmz), используйте следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=dmz --add-source-port=8080/tcp
\end{verbatim} 
Для добавления диапазона портов-источников в зону (например, разрешить порты с 5060 до 5061 для зоны public), введите следующую команду с правами пользователя root: 

\begin{verbatim}
# firewall-cmd --zone=public --add-source-port=5060-5061/udp
\end{verbatim} 
Чтобы сделать это изменение постоянным, повторно введите команду с параметром \textit{\textbf{--permanent}}.


\paragraph{Добавление службы в зону в консольном режиме}
Чтобы добавить службу в зону (например, разрешить SMTP для зоны work), введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=work --add-service=smtp
\end{verbatim} 
Чтобы сделать это изменение постоянным, повторно введите команду с параметром \textit{\textbf{--permanent}}.


\paragraph{Удаление службы из зоны в консольном режиме}
Для удаления службы из зоны (например, удалить SMTP из зоны work), введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=work --remove-service=smtp
\end{verbatim} 
Чтобы сделать это изменение постоянным, повторно введите команду с параметром \textit{\textbf{--permanent}}.

Это изменение не  разорвет уставленных соединений, но если это необходимо, используйте параметр --complete-reload. Учтите что это действие разорвёт все соединения, не только для удаляемой службы.



\paragraph{Добавление службы в зону с помощью редактирования файлов XML}
Чтобы просмотреть список файлов для зоны по умолчанию, введите следующую команду с правами пользователя root: 
\begin{verbatim}
 # ls /usr/lib/firewalld/zones/
block.xml  drop.xml      home.xml      public.xml   work.xml
dmz.xml    external.xml  internal.xml  trusted.xml
\end{verbatim} 

Эти файлы нельзя редактировать. Они используются по умолчанию в случае отсутствия эквивалентного файла в каталоге /etc/firewalld/zones/.

Для просмотра файлов зон, отличающихся от файлов по умолчанию, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# ls /etc/firewalld/zones/
external.xml  public.xml  public.xml.old
\end{verbatim} 

В примере выше файла зоны work не существует. Чтобы добавить файл зоны work, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# cp /usr/lib/firewalld/zones/work.xml /etc/firewalld/zones/
\end{verbatim} 

Теперь можно редактировать файл в каталоге /etc/firewalld/zones/. В случае его удаления firewalld вернётся к использованию файла по умолчанию в каталоге /usr/lib/firewalld/zones/.

Чтобы добавить службу в зону (например, разрешить SMTP для зоны work), добавьте следующую строку в файл /etc/firewalld/zones/work.xml с правами пользователя root: 

\begin{verbatim}
<service name="smtp"/>
\end{verbatim} 


\paragraph{Удаление службы из зоны  помощью редактирования файлов XML}
Для редактирования файлов зоны в формате XML необходим текстовый редактора, запущенный с правами пользователя root.  Для просмотра файлов для ранее настроенных зон, введите следующую команду с правами пользователя root:  
\begin{verbatim}
# ls /etc/firewalld/zones/
external.xml  public.xml  work.xml
\end{verbatim} 

Для удаления службы из зоны (например, для удаления SMTP из зоны work), используйте текстовый редактор с правами пользователя root и отредактируйте файл  /etc/firewalld/zones/work.xml, удалив следующую строку:
\begin{verbatim}
<service name="smtp"/>
\end{verbatim} 

Если в файл work.xml больше не было внесено изменений, его можно удалить, и firewalld будет использовать файл по умолчанию 
⁠⁠ /usr/lib/firewalld/zones/work.xml после следующей своей перезагрузки или перезагрузки все системы.

⁠

\subsection{Настройка маскарадинга IP адресов}
Чтобы проверить, включен ли маскарадинг IP адресов (например, для внешней зоны), введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=external --query-masquerade
\end{verbatim} 
В случае включенного маскарадинга, команда выдаст «yes» со статусом выхода 0. в противном случае, ответ будет «no» со статусом выхода 1. Если зона не будет указана, используется зона по умолчанию.

Чтобы включить маскарадинг, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=external --add-masquerade
\end{verbatim} 
Чтобы сделать это изменение постоянным, повторно введите команду с параметром \textit{\textbf{--permanent}}. 

Чтобы отключить маскарадинг, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=external --remove-masquerade
\end{verbatim} 
Чтобы сделать это изменение постоянным, повторно введите команду с параметром \textit{\textbf{--permanent}}. 


\subsubsection{Настройка проброса портов в консольном режиме}
Для перенаправления входящих сетевых пакетов с одного порта на другой порт или на адрес, сначала нужно включить пробрось портов в зоне (например, в зоне external). Введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=external --add-masquerade
\end{verbatim} 

Для перенаправления пакетов на локальный порт (порт в той же самой системе), введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --zone=external --add-forward-port=port=22:proto=tcp:toport=3753
\end{verbatim} 

В этом примере пакеты, предназначенные для порта 22, теперь направляются на порт 3753. Исходный порт назначения указывается параметром port, с помощью который можно указать как порт, так и диапазон портов. Также указывается и протокол. При указании протокола это должен быть либо tcp или udp. Новый локальной порт (порт или диапазон портов, на который перенаправляется трафик), указывается параметром toport. Чтобы сделать это изменение постоянным, повторно введите команду с параметром \textit{\textbf{--permanent}}. 

Чтобы перенаправить пакеты на другой адрес Ipv4 (обычно это внутренний адрес) без изменения порта назначения, введите следующую команду с правами пользователя root:  
\begin{verbatim}
# firewall-cmd --zone=external --add-forward-port=port=22:proto=tcp:toaddr=192.0.2.55
\end{verbatim} 

В этом примере, пакеты, предназначенные для порта 22, теперь перенаправляются на тот же порт по адресу, указанному параметром toaddr. Исходный порт назначения указывается параметром port. Этот параметр может указывать как порт, так и диапазон портов, также указывается протокол. При указании протокола это должен быть либо tcp or udp. Новый порт назначения (порт или диапазон портов, на который перенаправляется трафик), указывается параметром toport. Чтобы сделать это изменение постоянным, повторно введите команду с параметром \textit{\textbf{--permanent}}.

Для перенаправления пакетов на другой порт и на другой адрес Ipv4 (обычно это внутренний адрес), введите следующую команду с правами пользователя root:
\begin{verbatim}
 # firewall-cmd --zone=external \
      --add-forward-port=port=22:proto=tcp:toport=2055:toaddr=192.0.2.55
\end{verbatim}


В этом примере пакеты, предназначенные для порта 22, теперь перенаправляются на порт 2055 по адресу, указанному параметром toaddr. Исходный порт назначения указывается параметром port. Этот параметр может указывать как порт, так и диапазон портов, также указывается протокол. При указании протокола это должен быть либо tcp or udp. Новый порт назначения (порт или диапазон портов, на который перенаправляется трафик), указывается параметром toport. Чтобы сделать это изменение постоянным, повторно введите команду с параметром \textit{\textbf{--permanent}}.
⁠


\subsection{Настройка Firewall с помощью файлов XML}
Параметры настройки firewalld хранятся в файлах XML в каталоге /etc/firewalld/. Не изменяйте файлы в каталоге /usr/lib/firewalld/ (эти файлы определяют значения по умолчанию). Для просмотра и редактирования файлов XML необходимы привилегии пользователя root. Структура этих файлов объясняется на трёх страницах руководств:

\begin{longtable}{  m{5cm}  m{10cm}  }  
firewalld.icmptype(5) & описываются конфигурационные файлы в формате XML по фильтрации трафика ICMP\\ 
firewalld.service(5) & описываются конфигурационные файлы в формате XML по службе firewalld\\
firewalld.zone(5) & описываются конфигурационные файлы в формате XML по настройке зон firewalld\\
\end{longtable}


\subsection{Использование прямого интерфейса}

Параметр --direct утилиты firewall-cmd делает возможным добавление и удаление цепочек в рабочем режиме. Здесь мы предоставляем несколько примеров того, как это можно сделать. Подробности смотрите на странице руководства firewall-cmd(1).

Неопытным администраторам, слабо знающим iptables, не рекомендуется использовать прямой интерфейс, так как это может привести к опасным прорехам в межсетевом экране. Режим прямого интерфейса предназначен для добавления службам или приложениям конкретных правил firewall в рабочем режиме. Эти правила можно сделать постоянными, добавив параметр \textit{\textbf{--permanent}}, т.е. использовав команду firewall-cmd --permanent --direct или внеся изменения в файл /etc/firewalld/direct.xml. Подробности о файле /etc/firewalld/direct.xml см. на странице руководства firewalld.direct(5).





\subsubsection{Добавление правила с использованием прямого интерфейса}
Чтобы добавить правило в цепочку “IN\_public\_allow”, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --direct --add-rule ipv4 filter IN_public_allow \
        0 -m tcp -p tcp --dport 666 -j ACCEPT\end{verbatim} 
Чтобы сделать это значение постоянным, укажите параметр \textit{\textbf{--permanent}}. 

Удаление правила с использованием прямого интерфейса
Чтобы удалить правило из цепочки “IN\_public\_allow”, введите следующую команду с правами пользователя root: 
\begin{verbatim}
 # firewall-cmd --direct --remove-rule ipv4 filter IN_public_allow \
        0 -m tcp -p tcp --dport 666 -j ACCEPT
\end{verbatim} 
Чтобы сделать это значение постоянным, укажите параметр \textit{\textbf{--permanent}}.



\subsubsection{Просмотр правил с помощью прямого интерфейса}
Чтобы просмотреть правила в цепочке “IN\_public\_allow”, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --direct --get-rules ipv4 filter IN_public_allow
\end{verbatim} 
Обратите внимание, что эта команда (параметр --get-rules) показывает только те правила, которые ранее были добавлены с помощью параметра --add-rule. Она не показывает правила iptables, добавленные с помощью других средств.


\paragraph{Создание сложных правил Firewall с использованием синтаксиса "Rich Language"}
С помощью синтаксиса “rich language” можно создавать сложные правила межсетевого экрана способом, более простым для понимания, чем метод прямого интерфейса. Кроме того, эти параметры можно сделать постоянными. Язык использует ключевые слова и является абстрактным представлением правил iptables. С помощью этого языка можно настраивать зоны. Текущий способ настройки пока будет поддерживаться. 

Примеры смотрите на странице руководства firewalld.richlanguage(5).


\subsection{Блокировка межсетевого экрана}
При запуске с правами root, локальные приложения или службы могут изменить параметры межсетевого экрана (например, libvirt).Но администратор может заблокировать параметры firewall так, чтобы запретить всем приложениям запрашивать изменения в межсетевом экране, а также разрешить эти запросы только тем приложениям, которые добавлены в белый список блокировки. По умолчанию параметры блокировки отключены. При их включении администратор может быть уверен, что в параметры межсетевого экрана не будут внесены изменения со стороны локальных приложений или служб.


\subsubsection{Настройка блокировки firewall}
Запустите текстовый редактор с правами пользователя root и добавьте следующую строчку в файл /etc/firewalld/firewalld.conf:
\begin{verbatim}
Lockdown=yes
\end{verbatim} 

Перезагрузите межсетевой экран, введя следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --reload
\end{verbatim} 

Попробуйте включить службу imaps в зоне по умолчанию с помощью следующей команды от имени пользователя-администратора (пользователя, состоящего в группе wheel, обычно это первый пользователь, созданный в системе). Будет выведен запрос ввести пароль этого пользователя:
\begin{verbatim}
$ firewall-cmd --add-service=imaps
Error: ACCESS_DENIED: lockdown is enabled
\end{verbatim} 

Чтобы разрешить использование firewall-cmd, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --add-lockdown-whitelist-command='/usr/bin/python -Es /usr/bin/firewall-cmd*'
\end{verbatim} 
Чтобы сделать это значение постоянным, укажите параметр \textit{\textbf{--permanent}}. 
Перезагрузите межсетевой экран с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --reload
\end{verbatim} 

Попробуйте снова включить службу imaps в зоне по умолчанию, введите следующую команду с правами пользователя root. Будет выведен запрос ввести пароль пользователя:
\begin{verbatim}
$ firewall-cmd --add-service=imaps
\end{verbatim} 
В этот раз команда будет успешно выполнена.


\subsection{Использование службы IPTABLES}

Чтобы использовать службы iptables и ip6tables вместо firewalld, сначала отключите firewalld. Для этого введите следующие команды с правами пользователя root: 
\begin{verbatim}
# systemctl disable firewalld
# systemctl stop firewalld
\end{verbatim} 

Далее установите пакет iptables-services, введя следующую команду с правами пользователя root: 
\begin{verbatim}
# yum install iptables-services
\end{verbatim} 

Пакет \textbf{iptables-services} содержит службу iptables и службу ip6tables.

Затем, для запуска служб iptables и ip6tables, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# systemctl start iptables
# systemctl start ip6tables
\end{verbatim} 

Чтобы включить старт служб при каждом запуске системы, введите следующие команды:
\begin{verbatim}
# systemctl enable iptables
# systemctl enable ip6tables
\end{verbatim} 
⁠

Установленная локально документация по firewalld:
\begin{longtable}{  m{5cm}  m{10cm}  }  
firewalld(1) & командные параметры firewalld\\
firewalld.conf(5) & информация о конфигурации firewalld\\
firewalld-applet(1) & параметры утилиты firewall-applet\\
firewall-cmd(1) & командные параметры консольного клиента firewalld\\
firewall-config(1) & параметры инструмента firewall-config\\
firewall-offline-cmd(1) & командные параметры клиента offline\\
firewalld.icmptype(5) & описание конфигурационных файлов в формате XML для фильтрации ICMP\\
firewalld.ipset(5) & описание конфигурационных файлов в формате XML для firewalld IP sets\\
firewalld.service(5) & описание конфигурационных файлов в формате XML для службы firewalld\\
firewalld.zone(5) & описание конфигурационных файлов в формате XML для зон firewalld\\
firewalld.direct(5) & описание конфигурационного файла прямого интерфейса firewalld\\ 
firewalld.lockdown-whitelist(5) & описание конфигурационного файла белого списка блокировки firewall\\
firewall.richlanguage(5) & описание синтаксиса правил rich language\\ 
firewalld.zones(5) & общее описание зон и установки их параметров\\
firewalld.dbus(5) & описание интерфейса D-Bus для firewalld\\
\end{longtable}



\section{Сервер HTTP Apache версии 2.4}

Веб-сервер, поставляемый в составе ОС ROSA Enterprise Linux Server — это Apache HTTP Server версии 2.4. В данном разделе рассматриваются некоторые из добавленных возможностей, описываются важные отличия Apache HTTP Server 2.4 от версии 2.2 и предлагается руководство по обновлению устаревших конфигурационных файлов.

\subsection{Наиболее значительные изменения в версии 2.4}
\begin{itemize}
 \item \textbf{Управление службой httpd}\\ 
С отходом от традиционных сценариев SysV init, современные системные администраторы должны знать, как использовать команды \textbf{apachectl} и \textbf{systemctl} для контроля за службой, вместо команды \textit{service}. Рассмотрим примеры для службы httpd.
\begin{itemize}
 \item Команда:
\begin{verbatim}
service httpd graceful
\end{verbatim} 
заменяется на
\begin{verbatim}
apachectl graceful
\end{verbatim} 
\item \textbf{Отличия поведения файла юнита \textit{systemd} для httpd от \textit{init script}:}\\
При перезагрузке службы по умолчанию используется 
\begin{verbatim}
 graceful restart
\end{verbatim} 
При остановке службы используется 
\begin{verbatim}
 graceful stop
\end{verbatim} 
\item Команда:
\begin{verbatim}
 service httpd configtest
\end{verbatim} 
заменяется на
\begin{verbatim}
 apachectl configtest
\end{verbatim} 
\end{itemize}
\item \textbf{Отдельный каталог tmp}\\
Для повышения уровня защищённости системы, юнит systemd выполняет демон httpd с использованием специального каталога /tmp, отдельно от системного каталога /tmp.
\item \textbf{Схема конфигурации по пакетам}\\
Файлы конфигурации, с помощью которых загружаются модули, теперь располагаются в каталоге /etc/httpd/conf.modules.d/. Пакеты, предоставляющие дополнительные загружаемые модули для httpd, например, php, разместят файлы в этом каталоге. Для включения таких файлов в каталог /etc/httpd/conf.modules.d/ в файле /etc/httpd/conf/httpd.conf существует директива \textbf{Include}, следующая перед главным разделом. Это означает, что любые файлы конфигураций, располагающиеся в каталоге /conf.modules.d, обрабатываются до начала обработки основной информации файла httpd.conf. Директива \textbf{IncludeOptional} для файлов из каталога /etc/httpd/conf.d/ помещается в конце файла httpd.conf. Это означает, что файлы из каталога /etc/httpd/conf.d/ теперь обрабатываются после обработки основной информации из httpd.conf.
\item Некоторые конфигурационные файлы предоставляются пакетом httpd:
\begin{itemize}
\item /etc/httpd/conf.d/autoindex.conf — параметры индексации каталога mod\_autoindex 
\item /etc/httpd/conf.d/userdir.conf — параметры доступа в пользовательские каталоги, например http://example.com/~username/; такой доступ по умолчанию отключен из соображений безопасности
\item /etc/httpd/conf.d/welcome.conf — как и в предыдущих релизах, этот файл отвечает за страничку приветствия, показываемую по адресу http://localhost/ в отсутствие другой информации.
\end{itemize}
\item \textbf{Конфигурация по умолчанию}\\
Файл httpd.conf с минимальной конфигурацией теперь присутствует по умолчанию. Многие обычные параметры, такие, как \textbf{Timeout} или \textbf{KeepAlive}, больше не настраиваются явно в конфигурации по умолчанию; вместо них по умолчанию теперь используются встроенные параметры. Встроенные параметры по умолчанию описываются в руководстве. См. раздел «Устанавливаемая документация».
\item \textbf{Несовместимые изменения в синтаксисе}\\
При переносе существующей конфигурации с версии httpd 2.2 на httpd 2.4 обратите внимание, что в синтаксис параметров httpd было внесено некоторое количество обратно несовместимых изменений, требующих внимания администратора. Подробности смотрите в следующем документе организации Apache: http://httpd.apache.org/docs/2.4/upgrading.html
\item \textbf{Модель обработки}\\
В предыдущих релизах ROSA Enterprise Linux Server разные модели мультипроцессорной обработки (MPM) были доступны в виде различных бинарных файлов httpd: модель forked, “prefork”, была представлена как /usr/sbin/httpd, а модель “worker” на базе потоков — как /usr/sbin/httpd.worker.\\
В данном релизе ROSA Enterprise Linux Server теперь используете только один бинарный файл httpd, а три модели MPM доступны в виде загружаемых модулей: worker, prefork (по умолчанию) и event. Отредактируйте файл /etc/httpd/conf.modules.d/00-mpm.conf согласно требованиям конкретной системы, добавляя и убирая символ комментария \# так, чтобы загружался только один модуль MPM.
\item \textbf{Изменения в пакетах}\\
Модули аутентификации и авторизации LDAP теперь предоставляются в отдельном подпакете, \textbf{mod\_ldap}. Новый модуль \textbf{mod\_session} и связанные с ним вспомогательные модули составляют теперь новый подпакет, \textbf{mod\_session}. Новые модули \textbf{mod\_proxy\_html} и \textbf{mod\_xml2enc} составляют новый подпакет, \textbf{mod\_proxy\_html}. 
\item \textbf{Схема файловой системы в пакетах}\\
\begin{itemize}
\item \textbf{Пакетное содержимое httpd было перемещено из \textit{/var/www/} в \textit{/usr/share/httpd/}}:
Каталог /var/cache/mod\_proxy/ теперь отсутствует в пакетах; вместо этого, каталог  /var/cache/httpd/ находится в пакете вместе с подкаталогами proxy и ssl.
 \item /usr/share/httpd/icons/ — каталог с набором значков, используемых для указателей каталогов, ранее размещавшемся в /var/www/icons/, теперь располагается в /usr/share/httpd/icons/. В установке по умолчанию значки доступны по адресу http://localhost/icons/ ; расположение и доступность значков настраивается в файле etc/httpd/conf.d/autoindex.conf.
\item /usr/share/httpd/manual/ — Каталог /var/www/manual/ перемещён в /usr/share/httpd/manual/. В этом каталоге, устанавливаемом из пакета httpd-manual, находится HTML-версия руководства по httpd. При условии установленного пакета руководство доступно по адресу http://localhost/manual/ , расположение и доступность руководства настраивается в файле /etc/httpd/conf.d/manual.conf.
\item /usr/share/httpd/error/ — Каталог var/www/error/ был перемещён в /usr/share/httpd/error/. Пользовательские страницы ошибок HTTP на многих языках. Начальная конфигурация отсутствует, примерный фал конфигурации: /usr/share/doc/httpd-VERSION/httpd-multilang-errordoc.conf.
\end{itemize}
\item \textbf{Аутентификация, авторизация и контроль доступа}\\
Директивы параметров, используемых для управления аутентификацией, авторизацией и контролем доступа значительно изменились. Существующие конфигурации, использующие директивы Order, Deny и Allow, необходимо адаптировать для использования нового синтаксиса Require. Подробности смотрите в документе организации Apache: http://httpd.apache.org/docs/2.4/howto/auth.html
\item \textbf{suexec}\\
В целях повышения уровня безопасности системы, исполняемый файл \textbf{suexec} больше не устанавливается как if пользователем root. Вместо этого у него появился набор битов возможностей файловой системы [file system capability bits set] для более строго набора прав доступа. В дополнение к этому изменению, бинарный файл suexec больше не использует фал журнала \textit{/var/log/httpd/suexec.log}. Теперь сообщения журнала посылаются в \textbf{syslog}; по умолчанию они появляются в файле журнала \textit{/var/log/secure}.
\item \textbf{Интерфейс модулей}\\
Сторонние бинарные модули, собранные для httpd 2.2, несовместимы с httpd 2.4 из-за изменений в интерфейсе модулей httpd. Такие модули необходимо изменить согласно требованиям интерфейса модулей httpd 2.4 и затем собрать снова. Подробный список изменений API в версии 2.4 доступен здесь: http://httpd.apache.org/docs/2.4/developer/new\_api\_2\_4.html.
\item \textbf{Исполняемый файл apxs, используемый для сборки модулей из исходных текстов, перемещён из \textit{/usr/sbin/apxs} в \textit{/usr/bin/apxs}}.
\item \textbf{Удалённые модули}\\
Список удалённых модулей:
\begin{itemize}
 \item \textbf{mod\_auth\_mysql, mod\_auth\_pgsql}\\
httpd 2.4 предоставляет внутреннюю поддержку аутентификации для баз данных SQL в модуле \textbf{mod\_authn\_dbd module}
\item \textbf{mod\_perl}\\
для mod\_perl отсутствует официальная поддержка разработчиков версии httpd 2.4
\item \textbf{mod\_authz\_ldap}\\
httpd 2.4 предоставляет поддержку LDAP в подпакете \textbf{mod\_ldap}, использующем \textbf{mod\_authnz\_ldap}.
\end{itemize}
\end{itemize}


\subsection{Актуализация конфигурации}
Для обновления файлов конфигурации Apache HTTP Server версии 2.2 выполните следующие шаги:
\begin{itemize}
 \item Убедитесь, что все имена модулей корректны, поскольку он могли измениться. Исправьте директиву LoadModule для каждого переименованного модуля.
Перед попыткой загрузки сторонних модулей, пересоберите их. Обычно это относится к модулям аутентификации и авторизации.
\item Если используется модуль \textbf{mod\_userdir}, убедитесь в наличии директивы UserDir с указанием на название каталога (обычно это \textbf{public\_html}).
\item Если используется Apache HTTP Secure Server, прочтите раздел «Включение модуля mod\_ssl», там содержится важная информация о включении протокола Secure Sockets Layer (SSL).
\item Обратите внимание, что проверить конфигурацию на возможные ошибки можно с помощью команды:
\begin{verbatim}
# apachectl configtest
Syntax OK
\end{verbatim} 
\end{itemize}



Дополнительную информацию об обновлении конфигурации Apache HTTP Server с версии 2.2 на версию 2.4 можно получить по ссылке:\\
http://httpd.apache.org/docs/2.4/upgrading.html.



\subsection{Выполнение службы httpd}

В данном разделе описывается, как запустить, остановить, перезапустить и проверить текущий статус сервера Apache HTTP. Для возможности использовать службу httpd, убедитесь, что в системе установлен httpd. Это можно сделать, выполнив команду:
\begin{verbatim}
# yum install httpd
\end{verbatim} 


\subsubsection{Запуск службы}
Чтобы запустить службу httpd, введите следующую команду  с правами пользователя root: 
\begin{verbatim}
# systemctl start httpd.service
\end{verbatim} 

Для автоматического запуска службы при загрузке системы выполите:
\begin{verbatim}
# systemctl enable httpd.service
Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service
\end{verbatim} 


\so{Внимание}\\
Если сервер Apache HTTP работает как защищённый сервер, то при использовании зашифрованного закрытого ключа SSL, при загрузке машины потребуется ввести пароль.



\subsubsection{Остановка службы}
Чтобы остановить выполняющуюся службу httpd, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# systemctl stop httpd.service
\end{verbatim} 

Чтобы предотвратить автоматический запуск службы при загрузке системы, введите:
\begin{verbatim}
# systemctl disable httpd.service
Removed symlink /etc/systemd/system/multi-user.target.wants/httpd.service
\end{verbatim}


\subsubsection{Перезапуск службы}
Существует три разных способа перезапустить выполняющуюся службу httpd:

\begin{enumerate}
 \item Чтобы полностью перезапустить службу, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# systemctl restart httpd.service
\end{verbatim} 
Это действие останавливает выполняющуюся службу httpd и немедленно запускает её снова. Эта команда используется после установки или удаления динамически загружаемого модуля, например, PHP.
\item Чтобы просто перезагрузить конфигурацию, введите с правами пользователя root: 
\begin{verbatim}
# systemctl reload httpd.service
\end{verbatim} 
Это действие заставит работающую службу httpd перезагрузить файл конфигурации. Все запросы, обрабатываемые в это время, будут прерваны, что может вызвать показ сообщения об ошибке в браузере клиента или неполную загрузку страницы.
\item Для перезагрузки конфигурации, не отражающейся на активных запросах, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# apachectl graceful\end{verbatim} 
Это действие заставит работающую службу httpd перезагрузить файл конфигурации. Все запросы, обрабатываемые в это время, будут использовать старую конфигурацию.
\end{enumerate}


\subsubsection{Проверка статуса службы}
Для проверки, работает ли служба httpd, введите следующую команду в консоли:
\begin{verbatim}
# systemctl is-active httpd.service
Active
\end{verbatim} 


\subsection{Редактирование файлов конфигурации}
При запуске служба httpd по умолчанию читает конфигурационные файлы из местоположений в системе, перечисленных ниже в таблице «Конфигурационные файлы службы httpd»

⁠
Таблица: конфигурационные файлы службы httpd

\begin{longtable}{ | m{5cm} | m{10cm} | }\hline  
\textbf{Путь} & \textbf{Описание}\\\hline
 /etc/httpd/conf/httpd.conf & Главный файл\\\hline
 /etc/httpd/conf.d/ & Вспомогательный каталог для конфигурационных файлов, включаемых в главный файл\\\hline
\end{longtable}


Хотя параметры по умолчанию обычно подходят для большинства ситуаций, желательно познакомиться с некоторыми из наиболее важных параметров конфигурации. Обратите внимание, что для того, чтобы изменения конфигурации вступили в силу, сервер сначала нужно перегрузить (см. раздел «Перезапуск службы» выше).

Чтобы проверить конфигурацию на наличие ошибок, введите:
\begin{verbatim}
# apachectl configtest
Syntax OK
\end{verbatim} 

Чтобы облегчить процесс устранения ошибок, рекомендуется сделать резервную копию исходного файла перед его изменением.


\subsection{Работа с модулями}
Являясь модульным приложением, служба httpd поставляется вместе с некоторым числом динамических общих объектов (DSO)ю. Которые при необходимости можно динамически загружать и выгружать в рабочем режиме. В ОС ROSA Enterprise Linux Server эти модули располагаются в каталоге /usr/lib64/httpd/modules/.

\subsubsection{Загрузка модулей}
Чтобы загрузить модуль DSO, используйте директиву \textbf{LoadModule}. Обратите внимание, что модули, предоставляемые в отдельных пакетах, часто имеют свой собственный конфигурационный файл в каталоге /etc/httpd/conf.d/.
⁠
\textbf{\so{Пример:} загрузка динамического разделяемого модуля mod\_ssl}

\begin{verbatim}
 LoadModule ssl_module modules/mod_ssl.so
\end{verbatim} 

Дождавшись выполнения команды, перезагрузите сервер для обновления конфигурации.


\subsubsection{Написание модулей}
Администраторам, желающим написать свой собственный динамический разделяемый модуль, нужно убедиться в том, что в системе установлен пакет httpd-devel. Для этого введите следующую команду с правами пользователя root: 
\begin{verbatim}
# yum install httpd-devel
\end{verbatim} 
В этом пакете содержатся файлы include, файлы заголовков и утилита APache eXtenSion (apxs), необходимая для компиляции модуля.

После написания модуля, соберите его с помощью следующей команды:
\begin{verbatim}
# apxs -i -a -c <module_name>.c
\end{verbatim} 
Если результат сборки был удачен, модуль можно загружать точно также, как и любой другой модуль, идущий в составе сервера Apache HTTP.
⁠

\subsection{Настройка межсетевого экрана для разрешения трафика HTTP и HTTPS} 
ОС ROSA Enterprise Linux Server по умолчанию не разрешает трафик HTTP и HTTPS. Для того, чтобы дать возможность системе работать как веб-сервер, убедитесь, что службы, поддерживаемые firewalld, разрешают пропуск трафика HTTP и HTTPS сквозь межсетевой экран.

Чтобы включить HTTP в консоли, введите следующую команду с правами пользователя root: 
\begin{verbatim}
# firewall-cmd --add-service http
Success
\end{verbatim} 

Чтобы включить HTTPS в консоли, введите следующую команду с правами пользователя root:

\begin{verbatim}
# firewall-cmd --add-service https
 Success
\end{verbatim} 

Обратите внимание, что эти изменения будут действовать только до следующей перезагрузки системы. Чтобы сделать это изменение постоянным, повторно введите команду с параметром \textit{\textbf{--permanent}}. 


\subsubsection{Проверка сетевого доступа для входящего трафика HTTPS и HTTPS}
Чтобы проверить, какие службы разрешены в межсетевом экране, введите следующую команду с правами пользователя root: 
\begin{verbatim}
 # firewall-cmd --list-all
public (default, active)
  interfaces: em1
  sources: 
  services: dhcpv6-client ssh
output truncated
\end{verbatim} 

В этом примере с настройками установки по умолчанию, межсетевой кран включен, но службам HTTP и HTTPS проход запрещён. После разрешения трафика HTTP и HTTPS, будет выведена примерно такая строка:
\begin{verbatim}
services: dhcpv6-client http https ssh
\end{verbatim} 


Информация о некоторых полезных параметрах файла /etc/httpd/conf/httpd.conf :

\begin{itemize}
 \item \textbf{Пользователь http}\\
По соображениям безопасности, при запуске сервера Apache от имени суперпользователя (напрямую или через сценарий инициализации) происходит смена идентификатора пользователя (UID), от имени которого выполняется процесс сервера. По умолчанию используется пользователь http, который создаётся при установке и не имеет привилегированных полномочий в системе.
\item \textbf{Listen 80}\\
Это порт, через который Apache принимает входящие соединения. Если сервер имеет выход в интернет через маршрутизатор, необходимо будет настроить перенаправление этого порта.\\
Если Apache используется для разработки и тестирования, лучше разрешить только локальный доступ к нему. Для этого укажите \begin{verbatim}
Listen 127.0.0.1:80                                                                                                                          \end{verbatim}
\item \textbf{ServerAdmin you@example.com}\\
Адрес электронной почты администратора, который будет выводиться, например, на странице ошибки Apache.
\item \textbf{DocumentRoot "/srv/http"}\\
Это корневая директория Apache, в которой можно разместить веб-страницы.\\
Измените ее, если нужно, но не забудьте также поменять путь в директиве <Directory "/srv/http"> на новое расположение DocumentRoot, иначе вы, скорее всего, получите сообщение об ошибке 403 Error (недостаточно полномочий) при попытке получить доступ к новому корневому каталогу Apache. Также не забудьте изменить строку \textbf{Require all denied} на \textbf{Require all granted}, иначе снова получите ошибку 403 Error. Помните, что директория \textbf{DocumentRoot} и ее родительские папки должны иметь разрешения на запуск для всех (можно установить командой 
\begin{verbatim}
chmod o+x /path/to/DocumentRoot>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \end{verbatim} ), в противном случае вы получите ошибку 403 Error.
\item \textbf{AllowOverride None}\\
Запрещает переопределение настроек. Если в секции <Directory> указана эта директива, Apache будет полностью игнорировать настройки в файле .htaccess. Обратите внимание, что теперь такая настройка для Apache 2.4 является настройкой по умолчанию, поэтому если планируется использовать .htaccess, необходимо дать соответствующие разрешения. Если вы собираетесь включить модуль mod\_rewrite или использовать настройки в .htaccess, вы можете определить какие из директив, объявленных в этих файлах, могут перезаписывать конфигурацию сервера. Для получения дополнительной информации обратитесь к документации Apache: http://httpd.apache.org/docs/current/mod/core.html\#allowoverride 
\item Дополнительные настройки можно найти в /etc/httpd/conf/extra/httpd-default.conf.
\item Чтобы полностью отключить вывод версии Apache в генерируемых сервером страницах, добавьте:\\
\begin{verbatim}
 ServerSignature Off
\end{verbatim} 
\item Чтобы подавить вывод такой информации, как версии Apache и PHP, добавьте:
\begin{verbatim}
 ServerTokens Prod
\end{verbatim} 
\end{itemize}


\subsection{Пользовательские каталоги}
По умолчанию доступ к каталогам пользователей возможен по адресу http://localhost/~''user''/, который показывает содержимое каталога ~/public\_html (его имя и расположение задается в файле /etc/httpd/conf/extra/httpd-userdir.conf).

Если вы не хотите, чтобы пользовательские каталоги были доступны через web, закомментируйте следующую строку в /etc/httpd/conf/httpd.conf:
\begin{verbatim}
 Include conf/extra/httpd-userdir.conf
\end{verbatim} 
Убедитесь, что права доступа к вашему домашнему каталогу и ~/public\_html позволяют получать доступ к файлам в них всем пользователям:

\begin{verbatim}
$ chmod o+x ~
$ chmod o+x ~/public_html
$ chmod -R o+r ~/public_html
\end{verbatim} 
Однако, с точки зрения безопасности вышеприведенное решение слишком фривольно. Правильнее поступить по-другому. Сначала добавьте пользователя http в группу, которой принадлежит ваша домашняя папка. Например, если ваша домашняя папка и все ее подкаталоги принадлежат группе piter, можно проделать следующее:
\begin{verbatim}
 # usermod -aG piter http
\end{verbatim} 
или
\begin{verbatim}
 # gpasswd -a http piter
\end{verbatim} 
После этого назначьте права на чтение и исполнение для каталогов ~/, ~/public\_html и, рекурсивно, на остальные подкаталоги для ~/public\_html для членов группы (в нашем примере для членов группы piter). Опираясь на нижеприведенный шаблон, осуществите эти мероприятия:
\begin{verbatim}
$ chmod g+xr-w /home/yourusername
$ chmod -R g+xr-w /home/yourusername/public_html
\end{verbatim} 

\so{Примечание:} таким образом, только пользователь http и все потенциальные пользователи группы piter будут иметь разделяемый доступ к вашему домашнему каталогу.

Перезапустите службу httpd, чтобы изменения вступили в силу.

\subsection{TLS/SSL}
\so{Внимание:} при планировании использования SSL/TLS, имейте в виду, что некоторые их разновидности и реализации всё ещё уязвимы к атакам. (См.: https://weakdh.org/\#affected и https://en.wikipedia.org/wiki/Transport\_Layer\_Security\#Attacks\_against\_TLS.2FSSL ) Подробности о текущих уязвимостях SSL/TLS и о том, как применить соответствующие изменения для веб-сервера, можно найти на этих страницах: http://disablessl3.com/ и https://weakdh.org/sysadmin.html

Для использования TLS/SSL необходимо установить пакет, содержащий openssl.

Создайте закрытый ключ и запрос на получение сертификата (CSR). Также вы можете самозаверить CSR (который создаст сертификат):
\begin{verbatim}
# cd /etc/httpd/conf
# openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out server.key
# chmod 600 server.key
# openssl req -new -sha256 -key server.key -out server.csr
# openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
\end{verbatim} 

\so{Примечание:} можно настроить длину ключа в битах (rsa\_keygen\_bits:2048). Также возможно убрать опцию \textit{-sha256} для использования SHA-1 вместо SHA-2 или изменить время его действия в днях (\textbf{-days 365}).

Теперь раскомментируйте следующие строки в \textit{/etc/httpd/conf/httpd.conf}:

\begin{verbatim}
LoadModule ssl_module modules/mod_ssl.so
LoadModule socache_shmcb_module modules/mod_socache_shmcb.so
Include conf/extra/httpd-ssl.conf
\end{verbatim} 

Перезапустите службу httpd.service, чтобы изменения вступили в силу.

\subsubsection{Виртуальные хосты}
\so{Примечание:} для поддержки SSL на виртуальном хосте необходимо добавить отдельную секцию \textbf{<VirtualHost dommainame:443>}. 

Если необходимо, чтобы Apache обслуживал не один, а несколько хостов, раскомментируйте следующую строку в файле /etc/httpd/conf/httpd.conf:
\begin{verbatim}
 Include conf/extra/httpd-vhosts.conf
\end{verbatim} 

Укажите виртуальные хосты в /etc/httpd/conf/extra/httpd-vhosts.conf. Файл уже содержит пример полностью рабочих настроек, что поможет быстро выполнить настройки под конкретные нужды.

Для проверки виртуальных хостов на локальной машине добавьте их виртуальные имена в файл /etc/hosts:
\begin{verbatim}
127.0.0.1 domainname1.dom 
127.0.0.1 domainname2.dom
\end{verbatim} 
Перезапустите httpd.service, чтобы изменения вступили в силу.

\paragraph{Управление большим количеством виртуальных хостов}
Если Apache используется для обслуживания очень большого количества виртуальных хостов, вам может быть полезна возможность их легко включать и отключать. Для этого рекомендуется создавать собственный файл настроек на каждый хост и хранить все эти файлы в одном каталоге, например /etc/httpd/conf/vhosts.

Сначала создайте каталог:
\begin{verbatim}
# mkdir /etc/httpd/conf/vhosts
\end{verbatim} 
Теперь создайте в нем отдельные конфигурационные файлы:
\begin{verbatim}
# nano /etc/httpd/conf/vhosts/domainname1.dom
# nano /etc/httpd/conf/vhosts/domainname2.dom
\end{verbatim} 

И включите эти файлы в основной файл настроек /etc/httpd/conf/httpd.conf:
\begin{verbatim}
#Enabled Vhosts:
Include conf/vhosts/domainname1.dom
Include conf/vhosts/domainname2.dom
\end{verbatim} 

Теперь можно быстро включать/отключать требуемые виртуальные хосты, просто закомментировав или раскомментировав соответствующие директивы \textbf{Include} в основном файле настроек.

Очень простой файл виртуального хоста будет выглядеть следующим образом:
\begin{verbatim}
 /etc/httpd/conf/vhosts/domainname1.dom
<VirtualHost *:80>
    ServerAdmin webmaster@domainname1.dom
    DocumentRoot "/home/user/http/domainname1.dom"
    ServerName domainname1.dom
    ServerAlias domainname1.dom
    ErrorLog "/var/log/httpd/domainname1.dom-error_log"
    CustomLog "/var/log/httpd/domainname1.dom-access_log" common

    <Directory "/home/user/http/domainname1.dom">
        Require all granted
    </Directory>
</VirtualHost>

<VirtualHost *:443>
    ServerAdmin webmaster@domainname1.dom
    DocumentRoot "/home/user/http/domainname1.dom"
    ServerName domainname1.dom:443
    ServerAlias domainname1.dom:443
    SSLEngine on
    SSLCertificateFile "/etc/httpd/conf/server.crt"
    SSLCertificateKeyFile "/etc/httpd/conf/server.key"
    ErrorLog "/var/log/httpd/domainname1.dom-error_log"
    CustomLog "/var/log/httpd/domainname1.dom-access_log" common

    <Directory "/home/user/http/domainname1.dom">
        Require all granted
    </Directory>
</VirtualHost>
\end{verbatim} 

\subsection{Расширения} 
\subsubsection{PHP}
Для установки PHP установите пакеты \textit{php} и \textit{php-apache}.

Чтобы включить PHP, отредактируйте файл /etc/httpd/conf/httpd.conf:

\begin{itemize}
 \item В конце списка \textbf{LoadModule} добавьте:\\
\begin{verbatim}
LoadModule php7_module modules/libphp7.so
AddHandler php7-script php
\end{verbatim} 
\item В конце списка \textbf{Include} добавьте:
\begin{verbatim}
 Include conf/extra/php7_module.conf
\end{verbatim} 
\item Перезапустите службу httpd.service средствами systemd
\end{itemize}



Чтобы убедиться в том, что PHP настроен корректно, создайте файл test.php в каталоге DocumentRoot (то есть в /srv/http/ или ~/public\_html) и поместите в него следующий код:
\begin{verbatim}
<?php phpinfo(); ?>
\end{verbatim} 

По адресу http://localhost/test.php или http://localhost/''~пользователь''/test.php должна появиться информационная страница PHP.

Если PHP-код не исполняется, а на странице браузера видно содержимое test.php, проверьте, добавлены ли \textbf{Includes} в строку \textbf{Options} для корневого каталога в /etc/httpd/conf/httpd.conf. Кроме того, убедитесь, что TypesConfig conf/mime.types раскомментирован в секции <IfModule mime\_module>. Также можно попробовать добавить нижеследующую строку в секцию <IfModule mime\_module> файла httpd.conf:

\begin{verbatim}
AddHandler application/x-httpd-php .php
\end{verbatim} 

\subsubsection{Использование php-fpm и mod\_proxy\_fcgi}
Внимание: в отличие от широко распространённой установки с ProxyPass, настройка прокси с SetHandler принимает во внимание другие директивы Apache, например, DirectoryIndex. Это гарантирует лучшую совместимость с программами, созданными для libphp7, mod\_fastcgi и mod\_fcgid. Тем не менее, если необходимо попробовать ProxyPass, протестируйте такую строчку:

\begin{verbatim}
 ProxyPassMatch ^/(.*\.php(/.*)?)$ unix:/run/php-fpm/php-fpm.sock|fcgi://localhost/srv/http/$1
\end{verbatim} 

\begin{itemize}
 \item Установите пакет \textbf{php-fpm}
\item Включите модули прокси:
\begin{verbatim}
/etc/httpd/conf/httpd.conf
LoadModule proxy_module modules/mod_proxy.so
LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so
\end{verbatim} 
\item Создайте файл /etc/httpd/conf/extra/php-fpm.conf следующего содержания:
\begin{verbatim}
 /etc/httpd/conf/extra/php-fpm.conf
<FilesMatch \.php$>
    SetHandler "proxy:unix:/run/php-fpm/php-fpm.sock|fcgi://localhost/"
</FilesMatch>
\end{verbatim}
И добавьте его в конец файла /etc/httpd/conf/httpd.conf:
\begin{verbatim}
Include conf/extra/php-fpm.conf
\end{verbatim} 
Внимание: до и после символа вертикальной линии не должно быть пробелов. Localhost можно заменить любой строкой. Подробности см. здесь: https://httpd.apache.org/docs/2.4/mod/mod\_proxy\_fcgi.html\\
Можно настроить PHP-FPM в файле /etc/php/php-fpm.d/www.conf, но параметры по умолчанию должны хорошо работать.\\ 
\so{Внимание:}\\
Если ранее были добавлены следующие строки в httpd.conf, удалите их, т.к. они более не нужны:
\begin{verbatim}
 LoadModule php7_module modules/libphp7.so
Include conf/extra/php7_module.conf
\end{verbatim} 
\item Перезапустите службы httpd.service и php-fpm.service.
\end{itemize}



\subsubsection{HTTP2}
\begin{itemize}
 \item Для включения поддержки HTTP/2 установите пакет nghttp2.
\item Затем раскомментируйте следующую строку в httpd.conf:
\begin{verbatim}
LoadModule http2_module modules/mod_http2.so
\end{verbatim} 
\item И добавьте следующую строку:
\begin{verbatim}
Protocols h2 http/1.1
\end{verbatim} 
\end{itemize}

Подробности см. в документации для mod\_http2 : https://httpd.apache.org/docs/2.4/mod/mod\_http2.html

\subsection{Решение проблем}
\subsubsection{Просмотр журнала и текущего состояния Apache}
Текущее состояние службы httpd можно узнать с помощью команды
\begin{verbatim}
systemctl status httpd
\end{verbatim} 

Файлы журнала Apache расположены в каталоге /var/log/httpd.

При возникновении ошибки:
\begin{verbatim}
PID file /run/httpd/httpd.pid not readable (yet?) after start
\end{verbatim} 
Закомментируйте строку в файле параметров Apache:
\begin{verbatim}
LoadModule unique_id_module modules/mod_unique_id.so
\end{verbatim} 


Если не удалось запустить php5\_module при старте httpd.service и вы получаете следующее сообщение об ошибке:
\begin{verbatim}
Apache is running a threaded MPM, but your PHP Module is not compiled to be threadsafe.  You need to recompile PHP.                                                                                                                   \end{verbatim} 
Это значит, что Apache работает c поточным MPM, но используется не потокобезопасная версия PHP. В этом случае, следует заменить \textbf{mpm\_event\_module} на \textbf{mpm\_prefork\_module}:
\begin{verbatim}
 /etc/httpd/conf/httpd.conf
# LoadModule mpm_event_module modules/mod_mpm_event.so
LoadModule mpm_prefork_module modules/mod_mpm_prefork.so
\end{verbatim} 
и перезапустить httpd.service.



\subsection{Установленная и устанавливаемая документация по Apache}
\begin{longtable}{  m{3cm}  m{10cm}  }  
httpd(8) & руководство по службе httpd с полным списком консольных параметров\\
genkey(1) & руководство для утилиты genkey, поставляемой в пакете crypto-utils\\
apachectl(8) & руководство по Apache HTTP Server Control Interface\\
\end{longtable}

http://localhost/manual/ — официальная документация для HTTP сервера Apache с полным описанием всех директив и доступных модулей. Обратите внимание, что для чтения этой документации необходимо установить пакет \textbf{httpd-manual} и запустить веб-сервер.

Перед чтением документации введите следующую команду с правами пользователя root: 
\begin{verbatim}
# yum install httpd-manual
# apachectl graceful
\end{verbatim} 

\section{Nginx}
\subsection{Установка nginx}

Asdgsdfg

\subsection{Простое введение в nginx}
В этом руководстве описывается, как запустить и остановить nginx и перезагрузить его конфигурацию, объясняется, как устроен конфигурационный файл, и описывается, как настроить nginx для раздачи статического содержимого, как настроить прокси-сервер на nginx, и как связать nginx с приложением \textbf{FastCGI}.

У nginx есть один главный и несколько рабочих процессов. Основная задача главного процесса — чтение и проверка конфигурации и управление рабочими процессами. Рабочие процессы выполняют фактическую обработку запросов. nginx использует модель, основанную на событиях, и зависящие от операционной системы механизмы для эффективного распределения запросов между рабочими процессами. Количество рабочих процессов задаётся в конфигурационном файле и может быть фиксированным для данной конфигурации или автоматически устанавливаться равным числу доступных процессорных ядер.

Как работают nginx и его модули, определяется в конфигурационном файле. По умолчанию, конфигурационный файл называется nginx.conf и расположен в каталоге /usr/local/nginx/conf, /etc/nginx или /usr/local/etc/nginx.

\subsubsection{Простое введение в nginx}
Чтобы запустить nginx, нужно выполнить исполняемый файл. Когда nginx запущен, им можно управлять, вызывая исполняемый файл с параметром \textbf{-s}. Используйте следующий синтаксис:
\begin{verbatim}
nginx -s сигнал
\end{verbatim} 
Где сигнал может быть одним из нижеследующих:

\begin{itemize}
\item stop — быстрое завершение
\item quit — плавное завершение
\item reload — перезагрузка конфигурационного файла
\item reopen — переоткрытие лог-файлов
\end{itemize}

Например, чтобы остановить процессы nginx с ожиданием окончания обслуживания текущих запросов рабочими процессами, можно выполнить следующую команду:
\begin{verbatim}
 nginx -s quit
\end{verbatim} 
Команда должна быть выполнена под тем же пользователем, под которым был запущен nginx.

Изменения, сделанные в конфигурационном файле, не будут применены, пока команда перезагрузить конфигурацию не будет вручную отправлена nginx’у или он не будет перезапущен. Для перезагрузки конфигурации выполните:

\begin{verbatim}
 nginx -s reload
\end{verbatim} 
Получив сигнал, главный процесс проверяет правильность синтаксиса нового конфигурационного файла и пытается применить конфигурацию, содержащуюся в нём. Если это ему удаётся, главный процесс запускает новые рабочие процессы и отправляет сообщения старым рабочим процессам с требованием завершиться. В противном случае, главный процесс откатывает изменения и продолжает работать со старой конфигурацией. Старые рабочие процессы, получив команду завершиться, прекращают принимать новые запросы и продолжают обслуживать текущие запросы до тех пор, пока все такие запросы не будут обслужены. После этого старые рабочие процессы завершаются.

Посылать сигналы процессам nginx можно также средствами Unix, такими как утилита kill. В этом случае сигнал отправляется напрямую процессу с данным ID. ID главного процесса nginx записывается по умолчанию в файл nginx.pid в каталоге /usr/local/nginx/logs или /var/run. Например, если ID главного процесса равен 1628, для отправки сигнала QUIT, который приведёт к плавному завершению nginx, нужно выполнить:
\begin{verbatim}
 kill -s QUIT 1628
\end{verbatim} 

Для просмотра списка всех запущенных процессов nginx может быть использована утилита ps, например, следующим образом:
\begin{verbatim}
 ps -ax | grep nginx
\end{verbatim} 

\subsection{Структура конфигурационного файла}
nginx состоит из модулей, которые настраиваются директивами, указанными в конфигурационном файле. Директивы делятся на простые и блочные. Простая директива состоит из имени и параметров, разделённых пробелами, и оканчивается точкой с запятой (;). Блочная директива устроена так же, как и простая директива, но вместо точки с запятой после имени и параметров следует набор дополнительных инструкций, помещённых внутри фигурных скобок ({ и }). Если у блочной директивы внутри фигурных скобок можно задавать другие директивы, то она называется контекстом (примеры: \textbf{events}, \textbf{http}, \textbf{server} и \textbf{location}).

Директивы, помещённые в конфигурационном файле вне любого контекста, считаются находящимися в контексте main. Директивы events и http располагаются в контексте main, server — в http, а location — в server.

Часть строки после символа \# считается комментарием.

\subsection{Раздача статического содержимого}
Одна из важных задач конфигурации nginx — раздача файлов, таких как изображения или статические HTML-страницы. Рассмотрим пример, в котором в зависимости от запроса файлы будут раздаваться из разных локальных каталогов: /data/www, который содержит HTML-файлы, и /data/images, содержащий файлы с изображениями. Для этого потребуется отредактировать конфигурационный файл и настроить блок server внутри блока http с двумя блоками location.

Во-первых, создайте каталог /data/www и положите в него файл index.html с любым текстовым содержанием, а также создайте каталог /data/images и положите в него несколько файлов с изображениями.

Далее, откройте конфигурационный файл. Конфигурационный файл по умолчанию уже включает в себя несколько примеров блока server, большей частью закомментированных. Для нашей текущей задачи лучше закомментировать все такие блоки и добавить новый блок server:

\begin{verbatim}
 http {
    server {
    }
}
\end{verbatim} 
В общем случае конфигурационный файл может содержать несколько блоков \textbf{server}, различаемых по портам, на которых они слушают, и по имени сервера. Определив, какой server будет обрабатывать запрос, nginx сравнивает URI, указанный в заголовке запроса, с параметрами директив \textbf{location}, определённых внутри блока \textbf{server}.

В блок server добавьте блок location следующего вида:

\begin{verbatim}
 location / {
    root /data/www;
}
\end{verbatim} 
Этот блок location задаёт “/” в качестве префикса, который сравнивается с URI из запроса. Для подходящих запросов добавлением URI к пути, указанному в директиве root, то есть, в данном случае, к /data/www, получается путь к запрашиваемому файлу в локальной файловой системе. Если есть совпадение с несколькими блоками \textbf{location}, nginx выбирает блок с самым длинным префиксом. В блоке location выше указан самый короткий префикс, длины один, и поэтому этот блок будет использован, только если не будет совпадения ни с одним из остальных блоков location.

Далее, добавьте второй блок location:

\begin{verbatim}
 location /images/ {
    root /data;
}
\end{verbatim} 
Он будет давать совпадение с запросами, начинающимися с /images/ (location / для них тоже подходит, но указанный там префикс короче).

Итоговая конфигурация блока server должна выглядеть следующим образом:

\begin{verbatim}
 server {
    location / {
        root /data/www;
    }

    location /images/ {
        root /data;
    }
}
\end{verbatim} 
Это уже работающая конфигурация сервера, слушающего на стандартном порту 80 и доступного на локальном компьютере по адресу http://localhost/. В ответ на запросы, URI которых начинаются с /images/, сервер будет отправлять файлы из каталога /data/images. Например, на запрос http://localhost/images/example.png nginx отправит в ответ файл /data/images/example.png. Если же этот файл не существует, nginx отправит ответ, указывающий на ошибку 404. Запросы, URI которых не начинаются на /images/, будут отображены на каталог /data/www. Например, в результате запроса http://localhost/some/example.html в ответ будет отправлен файл /data/www/some/example.html.

Чтобы применить новую конфигурацию, запустите nginx, если он ещё не запущен, или отправьте сигнал reload главному процессу nginx, выполнив:

\begin{verbatim}
 nginx -s reload
\end{verbatim} 
В случае если что-то работает не как ожидалось, можно попытаться выяснить причину с помощью файлов \textbf{access.log} и \textbf{error.log} из каталога /usr/local/nginx/logs или /var/log/nginx.

\subsection{Настройка простого прокси-сервера}
Одним из частых применений nginx является использование его в качестве прокси-сервера, то есть сервера, который принимает запросы, перенаправляет их на проксируемые сервера, получает ответы от них и отправляет их клиенту.

Мы настроим базовый прокси-сервер, который будет обслуживать запросы изображений из локального каталога и отправлять все остальные запросы на проксируемый сервер. В этом примере оба сервера будут работать в рамках одного экземпляра nginx.

Во-первых, создайте проксируемый сервер, добавив ещё один блок server в конфигурационный файл nginx со следующим содержимым:

\begin{verbatim}
 server {
    listen 8080;
    root /data/up1;

    location / {
    }
}
\end{verbatim} 
Это будет простой сервер, слушающий на порту 8080 (ранее директива \textbf{listen} не указывалась, потому что использовался стандартный порт 80) и отображающий все запросы на каталог /data/up1 в локальной файловой системе. Создайте этот каталог и положите в него файл index.html. Обратите внимание, что директива root помещена в контекст \textbf{server}. Такая директива root будет использована, когда директива location, выбранная для выполнения запроса, не содержит собственной директивы root.

Далее, используйте конфигурацию сервера из предыдущего раздела и видоизмените её, превратив в конфигурацию прокси-сервера. В первый блок location добавьте директиву \textbf{proxy\_pass}, указав протокол, имя и порт проксируемого сервера в качестве параметра (в нашем случае это http://localhost:8080):

\begin{verbatim}
 server {
    location / {
        proxy_pass http://localhost:8080;
    }

    location /images/ {
        root /data;
    }
}
\end{verbatim} 
Мы изменим второй блок location, который на данный момент отображает запросы с префиксом /images/ на файлы из каталога /data/images так, чтобы он подходил для запросов изображений с типичными расширениями файлов. Изменённый блок location выглядит следующим образом:

\begin{verbatim}
 location ~ \.(gif|jpg|png)$ {
    root /data/images;
}
\end{verbatim} 
Параметром является регулярное выражение, дающее совпадение со всеми URI, оканчивающимися на \textbf{.gif}, \textbf{.jpg} или \textbf{.png}. Регулярному выражению должен предшествовать символ \textbf{~}. Соответствующие запросы будут отображены на каталог /data/images.

Когда nginx выбирает блок \textbf{location}, который будет обслуживать запрос, то вначале он проверяет директивы location, задающие префиксы, запоминая location с самым длинным подходящим префиксом, а затем проверяет регулярные выражения. Если есть совпадение с регулярным выражением, nginx выбирает соответствующий location, в противном случае берётся запомненный ранее location.

Итоговая конфигурация прокси-сервера выглядит следующим образом:

\begin{verbatim}
 server {
    location / {
        proxy_pass http://localhost:8080/;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
\end{verbatim} 
Этот сервер будет фильтровать запросы, оканчивающиеся на \textbf{.gif}, \textbf{.jpg} или \textbf{.png}, и отображать их на каталог /data/images (добавлением URI к параметру директивы root) и перенаправлять все остальные запросы на проксируемый сервер, сконфигурированный выше.

Чтобы применить новую конфигурацию, отправьте сигнал \textbf{reload} для nginx, как описывалось в предыдущих разделах.

Существует множество других директив для дальнейшей настройки прокси-соединения.

\subsubsection{Настройка проксирования FastCGI}
nginx можно использовать для перенаправления запросов на FastCGI-серверы. На них могут исполняться приложения, созданные с использованием разнообразных фреймворков и языков программирования, например, PHP.

Базовая конфигурация nginx для работы с проксируемым FastCGI-сервером включает в себя использование директивы \textbf{fastcgi\_pass} вместо директивы \textbf{proxy\_pass}, и директив \textbf{fastcgi\_param} для настройки параметров, передаваемых FastCGI-серверу. Представьте, что FastCGI-сервер доступен по адресу localhost:9000. Взяв за основу конфигурацию прокси-сервера из предыдущего раздела, замените директиву \textbf{proxy\_pass} на директиву \textbf{fastcgi\_pass} и измените параметр на localhost:9000. В PHP параметр \textbf{SCRIPT\_FILENAME} используется для определения имени скрипта, а в параметре \textbf{QUERY\_STRING} передаются параметры запроса. Получится следующая конфигурация:

\begin{verbatim}
 server {
    location / {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param QUERY_STRING    $query_string;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
\end{verbatim} 
Таким образом будет настроен сервер, который будет перенаправлять все запросы, кроме запросов статических изображений, на проксируемый сервер, работающий по адресу localhost:9000, по протоколу FastCGI.


\subsection{Управление nginx}
Управлять nginx можно с помощью сигналов. Номер главного процесса по умолчанию записывается в файл /usr/local/nginx/logs/nginx.pid. Изменить имя этого файла можно при конфигурации сборки или же в nginx.conf директивой pid. Главный процесс поддерживает следующие сигналы:

\begin{longtable}{  m{5cm}  m{10cm}  }  
TERM, INT & быстрое завершение\\
QUIT & плавное завершение\\
HUP & изменение конфигурации, обновление изменившейся временной зоны (только для FreeBSD и Linux), запуск новых рабочих процессов с новой конфигурацией, плавное завершение старых рабочих процессов\\
USR1 & переоткрытие лог-файлов\\
USR2 & обновление исполняемого файла\\
WINCH & плавное завершение рабочих процессов\\
\end{longtable}
Управлять рабочими процессами по отдельности не нужно. Тем не менее, они тоже поддерживают некоторые сигналы:

\begin{longtable}{  m{5cm}  m{10cm}  }
TERM, INT & быстрое завершение\\
QUIT & плавное завершение\\
USR1 & переоткрытие лог-файлов\\
WINCH & аварийное завершение для отладки (требует включения \textbf{debug\_points})\\
\end{longtable}



\subsection{Изменение конфигурации}
Для того чтобы nginx перечитал файл конфигурации, нужно послать главному процессу сигнал HUP. Главный процесс сначала проверяет синтаксическую правильность конфигурации, а затем пытается применить новую конфигурацию, то есть, открыть лог-файлы и новые listen сокеты. Если ему это не удаётся, то он откатывает изменения и продолжает работать со старой конфигурацией. Если же удаётся, то он запускает новые рабочие процессы, а старым шлёт сообщение о плавном выходе. Старые рабочие процессы закрывают listen сокеты и продолжают обслуживать старых клиентов. После обслуживания всех клиентов старые рабочие процессы завершаются.

Предположим, на FreeBSD 4.x команда

\begin{verbatim}
 ps axw -o pid,ppid,user,%cpu,vsz,wchan,command | egrep '(nginx|PID)'
\end{verbatim} 
показывает примерно такую картину:

\begin{verbatim}
   PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
33127 33126 nobody   0.0  1380 kqread nginx: worker process (nginx)
33128 33126 nobody   0.0  1364 kqread nginx: worker process (nginx)
33129 33126 nobody   0.0  1364 kqread nginx: worker process (nginx)
\end{verbatim} 
Если послать сигнал HUP главному процессу, то картина может быть такой:

\begin{verbatim}
   PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33129 33126 nobody   0.0  1380 kqread nginx: worker process is shutting down (nginx)
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
\end{verbatim} 
Один старый рабочий процесс 33129 всё ещё продолжает работать. По истечении некоторого времени он завершается:

\begin{verbatim}
   PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
\end{verbatim} 

\subsection{Ротация лог-файлов}
Лог-файлы нужно переименовать, а затем послать сигнал USR1 главному процессу. Он откроет заново все текущие открытые файлы и назначит им в качестве владельца непривилегированного пользователя, под которым работают рабочие процессы. После успешного открытия главный процесс закрывает все открытые файлы и посылает сообщение о переоткрытии файлов рабочим процессам. Они также открывают новые файлы и сразу же закрывают старые. В результате старые файлы практически сразу же готовы для дальнейшей обработки, например, их можно сжимать.

\subsubsection{Обновление исполняемого файла на лету}
Для обновления исполняемого файла сервера вначале нужно записать на место старого файла новый. Затем нужно послать сигнал USR2 главному процессу — он переименует свой файл с номером процесса в файл с суффиксом .oldbin, например, /usr/local/nginx/logs/nginx.pid.oldbin, после чего запустит новый исполняемый файл, а тот в свою очередь — свои рабочие процессы:

\begin{verbatim}
   PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1380 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
\end{verbatim} 
Теперь все рабочие процессы наравне принимают запросы. Если послать сигнал WINCH первому главному процессу, то он пошлёт своим рабочим процессам сообщение о плавном выходе, и они будут постепенно выходить:

\begin{verbatim}
   PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33135 33126 nobody   0.0  1380 kqread nginx: worker process is shutting down (nginx)
36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
\end{verbatim} 
По истечении времени запросы будут обрабатывать только новые рабочие процессы:

\begin{verbatim}
   PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
\end{verbatim} 
Нужно заметить, что старый процесс не закрывает свои listen сокеты и при необходимости ему можно сказать, чтобы он снова запустил свои рабочие процессы. Если работа нового исполняемого файла по каким-то причинам не устраивает, можно проделать одно из следующих действий:

Послать старому главному процессу сигнал HUP. Старый главный процесс, не перечитывая конфигурации, запустит новые рабочие процессы. После этого можно плавно завершить все новые процессы, послав новому главному процессу сигнал QUIT.

Послать новому главному процессу сигнал TERM. В ответ на это он пошлёт сообщение о немедленном выходе своим рабочим процессам, и все они практически сразу же завершатся. (Если новые процессы по каким-то причинам не завершаются, нужно послать им сигнал KILL, который заставит их завершиться.) По завершению нового главного процесса старый главный процесс автоматически запустит новые рабочие процессы.

Если новый главный процесс выходит, то старый главный процесс убирает суффикс .oldbin из имени файла с номером процесса.

Если же обновление прошло удачно, то старому процессу нужно послать сигнал QUIT, и останутся только новые процессы:

\begin{verbatim}
   PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
36264     1 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
\end{verbatim} 


\subsection{Параметры командной строки nginx}
nginx поддерживает следующие параметры командной строки:

\begin{longtable}{  m{5cm}  m{10cm}  }  
-? | -h & вывод справки по параметрам командной строки\\
-c файл & использование альтернативного конфигурационного файла файл вместо файла по умолчанию\\
-g директивы & задание глобальных директив конфигурации, например\\
 & \textbf{nginx -g "pid /var/run/nginx.pid; worker_processes `sysctl -n hw.ncpu`;"}\\
-p префикс & задание префикса пути nginx, т.е. каталога, в котором будут находиться файлы сервера (по умолчанию — каталог /usr/local/nginx)\\
-q & вывод только сообщений об ошибках при тестировании конфигурации\\
-s сигнал & отправка сигнала главному процессу. Аргументом сигнал может быть:
\begin{itemize}
 \item stop — быстрое завершение
\item quit — плавное завершение
\item reload — перезагрузка конфигурации, старт нового рабочего процесса с новой конфигурацией, плавное завершение старых рабочих процессов.
\item reopen — повторное открытие лог-файлов
\end{itemize}\\
-t & тестирование конфигурационного файла: nginx проверяет синтаксическую правильность конфигурации, а затем пытается открыть файлы, описанные в конфигурации\\
-T & то же, что и -t, а также вывод конфигурационных файлов в стандартный поток вывода (1.9.2)\\
-v & вывод версии nginx\\
-V & вывод версии nginx, версии компилятора и параметров конфигурации сборки\\
\end{longtable}


\subsubsection{Пример конфигурации}
\begin{verbatim}
 user www www;
worker_processes 2;

error_log /var/log/nginx-error.log info;

events {
    use kqueue;
    worker_connections 2048;
}

...
\end{verbatim}

\subsection{Директивы}

\begin{itemize}
 \item \textbf{Синтаксис:} accept\_mutex on | off;\\
\underline{Умолчание:} 
\begin{verbatim}
accept\_mutex off;
\end{verbatim} \\
\underline{Контекст:} \textbf{events}\\
Если accept\_mutex включён, рабочие процессы будут принимать новые соединения по очереди. В противном случае о новых соединениях будет сообщаться сразу всем рабочим процессам, и при низкой интенсивности поступления новых соединений часть рабочих процессов может работать вхолостую.\\
\\
Нет необходимости включать accept\_mutex на системах, поддерживающих флаг EPOLLEXCLUSIVE (1.11.3), или при использовании \textbf{reuseport}.
До версии 1.11.3 по умолчанию использовалось значение \textbf{on}.

\item \textbf{Синтаксис:} accept\_mutex\_delay время;\\
\underline{Умолчание:}
\begin{verbatim}
accept_mutex_delay 500ms;
\end{verbatim} 
\underline{Контекст:} \textbf{events}\\
При включённом accept\_mutex задаёт максимальное время, в течение которого рабочий процесс вновь попытается начать принимать новые соединения, если в настоящий момент новые соединения принимает другой рабочий процесс.

\item \textbf{Синтаксис:} daemon on | off;\\
\underline{Умолчание:}
\begin{verbatim}
daemon on;
\end{verbatim} 
\underline{Контекст:} \textbf{main}\\
Определяет, будет ли nginx запускаться в режиме демона. Используется в основном для разработки.
\item \textbf{Синтаксис:} debug\_connection адрес | CIDR | unix:;\\
\underline{Умолчание:}
\begin{verbatim}
—
\end{verbatim} 
\underline{Контекст:} \textbf{events}\\
Включает отладочный лог для отдельных клиентских соединений. Для остальных соединений используется уровень лога, заданный директивой error\_log. Отлаживаемые соединения задаются IPv4 или IPv6 (1.3.0, 1.2.1) адресом или сетью. Соединение может быть также задано при помощи имени хоста. Отладочный лог для соединений через UNIX-сокеты (1.3.0, 1.2.1) включается параметром “unix:”.

\begin{verbatim}
 events {
    debug_connection 127.0.0.1;
    debug_connection localhost;
    debug_connection 192.0.2.0/24;
    debug_connection ::1;
    debug_connection 2001:0db8::/32;
    debug_connection unix:;
    ...
}
\end{verbatim} 
Для работы директивы необходимо сконфигурировать nginx с параметром \textit{\textbf{--with-debug}}.

\item \textbf{Синтаксис:} debug\_points abort | stop;\\
\underline{Умолчание:}
\begin{verbatim}
 —
\end{verbatim} 
\underline{Контекст:} \textbf{main}\\
Эта директива используется для отладки.

В случае обнаружения внутренней ошибки, например, утечки сокетов в момент перезапуска рабочих процессов, включение debug\_points приводит к созданию core-файла (abort) или остановке процесса (stop) с целью последующей диагностики с помощью системного отладчика.

\item \textbf{Синтаксис:} error\_log файл [уровень];\\
\underline{Умолчание:}
\begin{verbatim}
error_log logs/error.log error;
\end{verbatim} 
\underline{Контекст:} \textbf{main, http, mail, stream, server, location}\\
Конфигурирует запись в лог. На одном уровне может использоваться несколько логов (1.5.2). Если на уровне конфигурации main запись лога в файл явно не задана, то используется файл по умолчанию.

Первый параметр задаёт файл, который будет хранить лог. Специальное значение stderr выбирает стандартный файл ошибок. Запись в syslog настраивается указанием префикса “syslog:”. Запись в кольцевой буфер в памяти настраивается указанием префикса “memory:” и размера буфера и как правило используется для отладки (1.7.11).

Второй параметр определяет уровень лога и может принимать одно из следующих значений: \textbf{debug, info, notice, warn, error, crit, alert} или \textbf{emerg}. Уровни лога, указанные выше, перечислены в порядке возрастания важности. При установке определённого уровня в лог попадают все сообщения указанного уровня и уровней большей важности. Например, при стандартном уровне \textbf{error} в лог попадают сообщения уровней \textbf{error, crit, alert} и \textbf{emerg}. Если этот параметр не задан, используется \textbf{error}.

Для работы уровня лога debug необходимо сконфигурировать nginx с \textbf{\textit{--with-debug}}.\\
Директива может быть указана на уровне \textbf{stream} начиная с версии 1.7.11 и на уровне \textbf{mail} начиная с версии 1.9.0.

\item \textbf{Синтаксис:} env переменная[=значение];\\
\underline{Умолчание:}
\begin{verbatim}
env TZ;
\end{verbatim} 
\underline{Контекст:} \textbf{main}\\
По умолчанию nginx удаляет все переменные окружения, унаследованные от своего родительского процесса, кроме переменной TZ. Эта директива позволяет сохранить часть унаследованных переменных, поменять им значения или же создать новые переменные окружения. Эти переменные затем:
\begin{itemize}
 \item наследуются во время обновления исполняемого файла на лету;
\item используются модулем ngx\_http\_perl\_module;
\item используются рабочими процессами. Следует иметь в виду, что управление поведением системных библиотек подобным образом возможно не всегда, поскольку зачастую библиотеки используют переменные только во время инициализации, то есть ещё до того, как их можно задать с помощью данной директивы. Исключением из этого является упомянутое выше обновление исполняемого файла на лету.\\
Если переменная TZ не описана явно, то она всегда наследуется и всегда доступна модулю ngx\_http\_perl\_module.
\end{itemize}

Пример использования:

\begin{verbatim}
env MALLOC_OPTIONS;
env PERL5LIB=/data/site/modules;
env OPENSSL_ALLOW_PROXY_CERTS=1;
\end{verbatim} 
Переменная окружения NGINX используется для внутренних целей nginx и не должна устанавливаться непосредственно самим пользователем.

\item \textbf{Синтаксис:} events { ... }\\
\underline{Умолчание:}
\begin{verbatim}
 —
\end{verbatim} 
\underline{Контекст:} \textbf{main}\\
Предоставляет контекст конфигурационного файла, в котором указываются директивы, влияющие на обработку соединений.

\item \textbf{Синтаксис:} include файл | маска;\\
\underline{Умолчание:}
\begin{verbatim}
 —
\end{verbatim} 
\underline{Контекст:} \textbf{любой}\\
Включает в конфигурацию другой файл или файлы, подходящие под заданную маску. Включаемые файлы должны содержать синтаксически верные директивы и блоки.

Пример использования:

\begin{verbatim}
include mime.types;
include vhosts/*.conf;
\end{verbatim} 

\item \textbf{Синтаксис:} load\_module файл;\\
\underline{Умолчание:}
\begin{verbatim}
—
\end{verbatim} 
\underline{Контекст:} \textbf{main}\\
Эта директива появилась в версии 1.9.11.\\
Загружает динамический модуль.

Пример:
\begin{verbatim}
 load_module modules/ngx_mail_module.so;
\end{verbatim} 
\item \textbf{Синтаксис:} lock\_file файл;\\
\underline{Умолчание:}
\begin{verbatim}
lock_file logs/nginx.lock;\end{verbatim} 
\underline{Контекст:} \textbf{main}\\
Для реализации accept\_mutex и сериализации доступа к разделяемой памяти nginx использует механизм блокировок. На большинстве систем блокировки реализованы с помощью атомарных операций, и эта директива игнорируется. Для остальных систем применяется механизм файлов блокировок. Эта директива задаёт префикс имён файлов блокировок.

\item \textbf{Синтаксис:} master\_process on | off;\\
\underline{Умолчание:}
\begin{verbatim}
master_process on;
\end{verbatim} 
\underline{Контекст:} \textbf{main}\\
Определяет, будут ли запускаться рабочие процессы. Эта директива предназначена для разработчиков nginx.

\item \textbf{Синтаксис:} multi\_accept on | off;\\
\underline{Умолчание:}
\begin{verbatim}
 multi_accept off;
\end{verbatim} 
\underline{Контекст:} \textbf{events}\\
Если multi\_accept выключен, рабочий процесс за один раз будет принимать только одно новое соединение. В противном случае рабочий процесс за один раз будет принимать сразу все новые соединения.

Директива игнорируется в случае использования метода обработки соединений kqueue, т.к. данный метод сам сообщает число новых соединений, ожидающих приёма.

\item \textbf{Синтаксис:} pcre\_jit on | off;\\
\underline{Умолчание:}
\begin{verbatim}
 pcre_jit off;
\end{verbatim} 
\underline{Контекст:} \textbf{main}\\
Эта директива появилась в версии 1.1.12.\\
Разрешает или запрещает использование JIT-компиляции (PCRE JIT) для регулярных выражений, известных на момент парсинга конфигурации.

Использование PCRE JIT способно существенно ускорить обработку регулярных выражений.

Для работы JIT необходима библиотека PCRE версии 8.20 или выше, собранная с параметром конфигурации \textbf{\textit{--enable-jit}}. При сборке библиотеки PCRE вместе с nginx (\textbf{\textit{--with-pcre=}}), для включения поддержки JIT необходимо использовать параметр конфигурации \textit{\textbf{--with-pcre-jit}}.

\item \textbf{Синтаксис:} pid файл;\\
\underline{Умолчание:}
\begin{verbatim}
pid nginx.pid;
\end{verbatim} 
\underline{Контекст:} \textbf{main}\\
Задаёт файл, в котором будет храниться номер (PID) главного процесса.

\item \textbf{Синтаксис:} ssl\_engine устройство;\\
\underline{Умолчание:}
\begin{verbatim}
 —
\end{verbatim} 
\underline{Контекст:} \textbf{main}\\
Задаёт название аппаратного SSL-акселератора.

\item \textbf{Синтаксис:} thread\_pool имя threads=число [max\_queue=число];\\
\underline{Умолчание:}
\begin{verbatim}
 thread_pool default threads=32 max_queue=65536;
\end{verbatim} 
\underline{Контекст:} \textbf{main}\\
Эта директива появилась в версии 1.7.11.\\
Задаёт именованные пулы потоков, используемые для многопоточной обработки операций чтения и отправки файлов без блокирования рабочего процесса.

Параметр \textbf{threads} задаёт число потоков в пуле.

Если все потоки из пула заняты выполнением заданий, новое задание будет ожидать своего выполнения в очереди. Параметр max\_queue ограничивает число заданий, ожидающих своего выполнения в очереди. По умолчанию в очереди может находиться до 65536 заданий. При переполнении очереди задание завершается с ошибкой.

Синтаксис:	timer_resolution интервал;
Умолчание:	—
Контекст:	main
Уменьшает разрешение таймеров времени в рабочих процессах, за счёт чего уменьшается число системных вызовов gettimeofday(). По умолчанию gettimeofday() вызывается после каждой операции получения событий из ядра. При уменьшении разрешения gettimeofday() вызывается только один раз за указанный интервал.

Пример использования:

timer_resolution 100ms;
Внутренняя реализация интервала зависит от используемого метода:

фильтр EVFILT_TIMER при использовании kqueue;
timer_create() при использовании eventport;
и setitimer() во всех остальных случаях.

Синтаксис:	use метод;
Умолчание:	—
Контекст:	events
Задаёт метод, используемый для обработки соединений. Обычно нет необходимости задавать его явно, поскольку по умолчанию nginx сам выбирает наиболее эффективный метод.

Синтаксис:	user пользователь [группа];
Умолчание:	
user nobody nobody;
Контекст:	main
Задаёт пользователя и группу, с правами которого будут работать рабочие процессы. Если группа не задана, то используется группа, имя которой совпадает с именем пользователя.

Синтаксис:	worker_aio_requests число;
Умолчание:	
worker_aio_requests 32;
Контекст:	events
Эта директива появилась в версиях 1.1.4 и 1.0.7.
При использовании aio совместно с методом обработки соединений epoll, задаёт максимальное число ожидающих обработки операций асинхронного ввода-вывода для одного рабочего процесса.

Синтаксис:	worker_connections число;
Умолчание:	
worker_connections 512;
Контекст:	events
Задаёт максимальное число соединений, которые одновременно может открыть рабочий процесс.

Следует иметь в виду, что в это число входят все соединения (в том числе, например, соединения с проксируемыми серверами), а не только соединения с клиентами. Стоит также учитывать, что фактическое число одновременных соединений не может превышать действующего ограничения на максимальное число открытых файлов, которое можно изменить с помощью worker_rlimit_nofile.

Синтаксис:	worker_cpu_affinity маска_CPU ...;
worker_cpu_affinity auto [маска_CPU];
Умолчание:	—
Контекст:	main
Привязывает рабочие процессы к группам процессоров. Каждая группа процессоров задаётся битовой маской разрешённых к использованию процессоров. Для каждого рабочего процесса должна быть задана отдельная группа. По умолчанию рабочие процессы не привязаны к конкретным процессорам.

Например,

worker_processes    4;
worker_cpu_affinity 0001 0010 0100 1000;
привязывает каждый рабочий процесс к отдельному процессору, тогда как

worker_processes    2;
worker_cpu_affinity 0101 1010;
привязывает первый рабочий процесс к CPU0/CPU2, а второй — к CPU1/CPU3. Второй пример пригоден для hyper-threading.

Специальное значение auto (1.9.10) позволяет автоматически привязать рабочие процессы к доступным процессорам:

worker_processes auto;
worker_cpu_affinity auto;
С помощью необязательной маски можно ограничить процессоры, доступные для автоматической привязки:

worker_cpu_affinity auto 01010101;
Директива доступна только на FreeBSD и Linux.

Синтаксис:	worker_priority число;
Умолчание:	
worker_priority 0;
Контекст:	main
Задаёт приоритет планирования рабочих процессов подобно тому, как это делается командой nice: отрицательное число означает более высокий приоритет. Диапазон возможных значений, как правило, варьируется от -20 до 20.

Пример использования:

worker_priority -10;
Синтаксис:	worker_processes число | auto;
Умолчание:	
worker_processes 1;
Контекст:	main
Задаёт число рабочих процессов.

Оптимальное значение зависит от множества факторов, включая (но не ограничиваясь ими) число процессорных ядер, число жёстких дисков с данными и картину нагрузок. Если затрудняетесь в выборе правильного значения, можно начать с установки его равным числу процессорных ядер (значение “auto” пытается определить его автоматически).

Параметр auto поддерживается только начиная с версий 1.3.8 и 1.2.5.

Синтаксис:	worker_rlimit_core размер;
Умолчание:	—
Контекст:	main
Изменяет ограничение на наибольший размер core-файла (RLIMIT_CORE) для рабочих процессов. Используется для увеличения ограничения без перезапуска главного процесса.

Синтаксис:	worker_rlimit_nofile число;
Умолчание:	—
Контекст:	main
Изменяет ограничение на максимальное число открытых файлов (RLIMIT_NOFILE) для рабочих процессов. Используется для увеличения ограничения без перезапуска главного процесса.

Синтаксис:	worker_shutdown_timeout время;
Умолчание:	—
Контекст:	main
Эта директива появилась в версии 1.11.11.
Задаёт таймаут в секундах для плавного завершения рабочих процессов. По истечении указанного времени nginx попытается закрыть все открытые соединения для ускорения завершения.

Синтаксис:	working_directory каталог;
Умолчание:	—
Контекст:	main
Задаёт каталог, который будет текущим для рабочего процесса. Основное применение — запись core-файла, в этом случае рабочий процесс должен иметь права на запись в этот каталог.
\end{itemize}

Настройка HTTPS-серверов

Чтобы настроить HTTPS-сервер, необходимо включить параметр ssl на слушающих сокетах (https://nginx.ru/ru/docs/http/ngx_http_core_module.html#listen)  в блоке server (https://nginx.ru/ru/docs/http/ngx_http_core_module.html#server), а также указать местоположение файлов с сертификатом сервера (https://nginx.ru/ru/docs/http/ngx_http_ssl_module.html#ssl_certificate) и секретным ключом (https://nginx.ru/ru/docs/http/ngx_http_ssl_module.html#ssl_certificate_key):

server {
    listen              443 ssl;
    server_name         www.example.com;
    ssl_certificate     www.example.com.crt;
    ssl_certificate_key www.example.com.key;
    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers         HIGH:!aNULL:!MD5;
    ...
}
Сертификат сервера является публичным. Он посылается каждому клиенту, соединяющемуся с сервером. Секретный ключ следует хранить в файле с ограниченным доступом (права доступа должны позволять главному процессу nginx читать этот файл). Секретный ключ можно также хранить в одном файле с сертификатом:

    ssl_certificate     www.example.com.cert;
    ssl_certificate_key www.example.com.cert;
при этом права доступа к файлу следует также ограничить. Несмотря на то, что и сертификат, и ключ хранятся в одном файле, клиенту посылается только сертификат.

С помощью директив ssl_protocols (https://nginx.ru/ru/docs/http/ngx_http_ssl_module.html#ssl_protocols) и ssl_ciphers (https://nginx.ru/ru/docs/http/ngx_http_ssl_module.html#ssl_ciphers) можно ограничить соединения использованием только “сильных” версий и шифров SSL/TLS. По умолчанию nginx использует “ssl_protocols TLSv1 TLSv1.1 TLSv1.2” и “ssl_ciphers HIGH:!aNULL:!MD5”, поэтому их явная настройка в общем случае не требуется. Следует отметить, что значения по умолчанию этих директив несколько раз менялись.

Оптимизация HTTPS-сервера

SSL-операции потребляют дополнительные ресурсы процессора. На мультипроцессорных системах следует запускать несколько рабочих процессов  (https://nginx.ru/ru/docs/ngx_core_module.html#worker_processes) , не меньше числа доступных процессорных ядер. Наиболее ресурсоёмкой для процессора является операция SSL handshake, в рамках которой формируются криптографические параметры сессии. Существует два способа уменьшения числа этих операций, производимых для каждого клиента: использование постоянных (keepalive https://nginx.ru/ru/docs/http/ngx_http_core_module.html#keepalive_timeout) соединений, позволяющих в рамках одного соединения обрабатывать сразу несколько запросов, и повторное использование параметров SSL-сессии для предотвращения необходимости выполнения SSL handshake для параллельных и последующих соединений. Сессии хранятся в кэше SSL-сессий, разделяемом между рабочими процессами и настраиваемом директивой ssl_session_cache (https://nginx.ru/ru/docs/http/ngx_http_ssl_module.html#ssl_session_cache) . В 1 мегабайт кэша помещается около 4000 сессий. Таймаут кэша по умолчанию равен 5 минутам. Он может быть увеличен с помощью директивы ssl_session_timeout (https://nginx.ru/ru/docs/http/ngx_http_ssl_module.html#ssl_session_timeout). Вот пример конфигурации, оптимизированной под многоядерную систему с 10-мегабайтным разделяемым кэшем сессий:

worker_processes auto;

http {
    ssl_session_cache   shared:SSL:10m;
    ssl_session_timeout 10m;

    server {
        listen              443 ssl;
        server_name         www.example.com;
        keepalive_timeout   70;

        ssl_certificate     www.example.com.crt;
        ssl_certificate_key www.example.com.key;
        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers         HIGH:!aNULL:!MD5;
        ...
Цепочки SSL-сертификатов

Некоторые браузеры могут выдавать предупреждение о сертификате, подписанном общеизвестным центром сертификации, в то время как другие браузеры без проблем принимают этот же сертификат. Так происходит потому, что центр, выдавший сертификат, подписал его промежуточным сертификатом, которого нет в базе данных сертификатов общеизвестных доверенных центров сертификации, распространяемой вместе с браузером. В подобном случае центр сертификации предоставляет “связку” сертификатов, которую следует присоединить к сертификату сервера. Сертификат сервера следует разместить перед связкой сертификатов в скомбинированном файле:

$ cat www.example.com.crt bundle.crt > www.example.com.chained.crt
Полученный файл следует указать в директиве ssl_certificate (https://nginx.ru/ru/docs/http/ngx_http_ssl_module.html#ssl_certificate):

server {
    listen              443 ssl;
    server_name         www.example.com;
    ssl_certificate     www.example.com.chained.crt;
    ssl_certificate_key www.example.com.key;
    ...
}
Если сертификат сервера и связка сертификатов были соединены в неправильном порядке, nginx откажется запускаться и выдаст сообщение об ошибке:

SSL_CTX_use_PrivateKey_file(" ... /www.example.com.key") failed
   (SSL: error:0B080074:x509 certificate routines:
    X509_check_private_key:key values mismatch)
поскольку nginx попытается использовать секретный ключ с первым сертификатом из связки вместо сертификата сервера.

Браузеры обычно сохраняют полученные промежуточные сертификаты, подписанные доверенными центрами сертификации, поэтому активно используемые браузеры уже могут иметь требуемые промежуточные сертификаты и не выдать предупреждение о сертификате, присланном без связанной с ним цепочки сертификатов. Убедиться в том, что сервер присылает полную цепочку сертификатов, можно при помощи утилиты командной строки openssl, например:

$ openssl s_client -connect www.godaddy.com:443
...
Certificate chain
 0 s:/C=US/ST=Arizona/L=Scottsdale/1.3.6.1.4.1.311.60.2.1.3=US
     /1.3.6.1.4.1.311.60.2.1.2=AZ/O=GoDaddy.com, Inc
     /OU=MIS Department/CN=www.GoDaddy.com
     /serialNumber=0796928-7/2.5.4.15=V1.0, Clause 5.(b)
   i:/C=US/ST=Arizona/L=Scottsdale/O=GoDaddy.com, Inc.
     /OU=http://certificates.godaddy.com/repository
     /CN=Go Daddy Secure Certification Authority
     /serialNumber=07969287
 1 s:/C=US/ST=Arizona/L=Scottsdale/O=GoDaddy.com, Inc.
     /OU=http://certificates.godaddy.com/repository
     /CN=Go Daddy Secure Certification Authority
     /serialNumber=07969287
   i:/C=US/O=The Go Daddy Group, Inc.
     /OU=Go Daddy Class 2 Certification Authority
 2 s:/C=US/O=The Go Daddy Group, Inc.
     /OU=Go Daddy Class 2 Certification Authority
   i:/L=ValiCert Validation Network/O=ValiCert, Inc.
     /OU=ValiCert Class 2 Policy Validation Authority
     /CN=http://www.valicert.com//emailAddress=info@valicert.com
...
В этом примере субъект (“s”) сертификата №0 сервера www.GoDaddy.com подписан издателем (“i”), который в свою очередь является субъектом сертификата №1, подписанного издателем, который в свою очередь является субъектом сертификата №2, подписанного общеизвестным издателем ValiCert, Inc., чей сертификат хранится во встроенной в браузеры базе данных сертификатов (которая в тёмном чулане хранится в доме, который построил Джек).

Если связку сертификатов не добавили, будет показан только сертификат сервера №0.

Единый HTTP/HTTPS сервер

Можно настроить единый сервер, который обслуживает как HTTP-, так и HTTPS-запросы:

server {
    listen              80;
    listen              443 ssl;
    server_name         www.example.com;
    ssl_certificate     www.example.com.crt;
    ssl_certificate_key www.example.com.key;
    ...
}
До версии 0.7.14 SSL нельзя было включить выборочно для отдельных слущающих сокетов, как показано выше. SSL можно было включить только для всего сервера целиком, с помощью директивы ssl (https://nginx.ru/ru/docs/http/ngx_http_ssl_module.html#ssl), что не позволяло настроить единый HTTP/HTTPS сервер. Для решения этой задачи был добавлен параметр ssl директивы listen (https://nginx.ru/ru/docs/http/ngx_http_core_module.html#listen) . Поэтому использование директивы ssl в современных версиях не рекомендуется.

Выбор HTTPS-сервера по имени

Типичная проблема возникает при настройке двух и более серверов HTTPS, слушающих на одном и том же IP-адресе:

server {
    listen          443 ssl;
    server_name     www.example.com;
    ssl_certificate www.example.com.crt;
    ...
}

server {
    listen          443 ssl;
    server_name     www.example.org;
    ssl_certificate www.example.org.crt;
    ...
}
В такой конфигурации браузер получит сертификат сервера по умолчанию, т.е. www.example.com, независимо от запрашиваемого имени сервера. Это связано с поведением протокола SSL. SSL-соединение устанавливается до того, как браузер посылает HTTP-запрос, и nginx не знает имени запрашиваемого сервера. Следовательно, он лишь может предложить сертификат сервера по умолчанию.

Наиболее старым и надёжным способом решения этой проблемы является назначение каждому HTTPS-серверу своего IP-адреса:

server {
    listen          192.168.1.1:443 ssl;
    server_name     www.example.com;
    ssl_certificate www.example.com.crt;
    ...
}

server {
    listen          192.168.1.2:443 ssl;
    server_name     www.example.org;
    ssl_certificate www.example.org.crt;
    ...
}
SSL-сертификат с несколькими именами

Существуют и другие способы, которые позволяют использовать один и тот же IP-адрес сразу для нескольких HTTPS-серверов. Все они, однако, имеют свои недостатки. Одним из таких способов является использование сертификата с несколькими именами в поле SubjectAltName сертификата, например www.example.com и www.example.org. Однако, длина поля SubjectAltName ограничена.

Другим способом является использование wildcard-сертификата, например *.example.org. Такой сертификат защищает все поддомены указанного домена, но только на заданном уровне. Под такой сертификат подходит www.example.org, но не подходят example.org и www.sub.example.org. Два вышеуказанных способа можно комбинировать. Сертификат может одновременно содержать и точное, и wildcard имена в поле SubjectAltName, например example.org и *.example.org.

Лучше поместить сведения о файле сертификата с несколькими именами и файле с его секретным ключом на уровне конфигурации http, чтобы все серверы унаследовали их единственную копию в памяти:

ssl_certificate     common.crt;
ssl_certificate_key common.key;

server {
    listen          443 ssl;
    server_name     www.example.com;
    ...
}

server {
    listen          443 ssl;
    server_name     www.example.org;
    ...
}
Указание имени сервера

Более общее решение для работы нескольких HTTPS-серверов на одном IP-адресе — расширение Server Name Indication протокола TLS (SNI, RFC 6066), которое позволяет браузеру передать запрашиваемое имя сервера во время SSL handshake, а значит сервер будет знать, какой сертификат ему следует использовать для соединения. Сейчас SNI поддерживается большинством современных браузеров, однако может не использоваться некоторыми старыми или специализированными клиентами.

В SNI можно передавать только доменные имена, однако некоторые браузеры могут ошибочно передавать IP-адрес сервера в качестве его имени, если в запросе указан IP-адрес. Полагаться на это не следует.
Чтобы использовать SNI в nginx, соответствующая поддержка должна присутствовать как в библиотеке OpenSSL, использованной при сборке бинарного файла nginx, так и в библиотеке, подгружаемой в момент работы. OpenSSL поддерживает SNI начиная с версии 0.9.8f, если она была собрана с опцией конфигурации “--enable-tlsext”. Начиная с OpenSSL 0.9.8j эта опция включена по умолчанию. Если nginx был собран с поддержкой SNI, то при запуске nginx с ключом “-V” об этом сообщается:

$ nginx -V
...
TLS SNI support enabled
...
Однако, если nginx, собранный с поддержкой SNI, в процессе работы подгружает библиотеку OpenSSL, в которой нет поддержки SNI, nginx выдаёт предупреждение:

nginx was built with SNI support, however, now it is linked
dynamically to an OpenSSL library which has no tlsext support,
therefore SNI is not available

Совместимость
Статус поддержки SNI отображается по ключу “-V” начиная с версий 0.8.21 и 0.7.62.
Параметр ssl директивы listen поддерживается начиная с версии 0.7.14. До версии 0.8.21 его можно было указывать только совместно с параметром default.
SNI поддерживается начиная с версии 0.5.23.
Разделяемый кэш SSL-сессий поддерживается начиная с версии 0.5.6.
Версия 1.9.1 и более поздние: протоколами SSL по умолчанию являются TLSv1, TLSv1.1 и TLSv1.2 (если поддерживается библиотекой OpenSSL).
Версия 0.7.65, 0.8.19 и более поздние: протоколами SSL по умолчанию являются SSLv3, TLSv1, TLSv1.1 и TLSv1.2 (если поддерживается библиотекой OpenSSL).
Версия 0.7.64, 0.8.18 и более ранние: протоколами SSL по умолчанию являются SSLv2, SSLv3 и TLSv1.
Версия 1.0.5 и более поздние: шифрами SSL по умолчанию являются “HIGH:!aNULL:!MD5”.
Версия 0.7.65, 0.8.20 и более поздние: шифрами SSL по умолчанию являются “HIGH:!ADH:!MD5”.
Версия 0.8.19: шифрами SSL по умолчанию являются “ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM”.
Версия 0.7.64, 0.8.18 и более ранние: шифрами SSL по умолчанию являются
“ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP”.








\end{document}

